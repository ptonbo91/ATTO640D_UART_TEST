-- File: sobel_filter.vhd
-- Generated by MyHDL 1.0dev
-- Date: Thu Mar 29 14:35:58 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity sobel_filter is
    generic (
        WINDOW: positive:=3;
        BITWIDTH : positive:= 14;
        VIDEO_XSIZE: positive:=640;
        VIDEO_YSIZE:positive:=480;
        PIX_BITS : positive:=10;
        LIN_BITS : positive:=9
       );
    port (
        clk: in std_logic;
        rst: in std_logic;
        clk_100: in std_logic;
        threshold_mult: in std_logic_vector(7 downto 0);
        video_i_v: in std_logic;
        video_i_h: in std_logic;
        video_i_dav: in std_logic;
        video_i_data: in std_logic_vector(BITWIDTH-1 downto 0);
        video_i_eoi: in std_logic;
        video_o_v: out std_logic;
        video_o_h: out std_logic;
        video_o_dav: out std_logic;
        video_o_data: out std_logic;
        video_o_data2: out std_logic_vector(BITWIDTH-1 downto 0);
        video_o_eoi: out std_logic;
        mean_out: out std_logic_vector(15 downto 0)
    );
end entity sobel_filter;


architecture MyHDL of sobel_filter is

--COMPONENT TOII_TUVE_ila

--PORT (
--    clk : IN STD_LOGIC;



--    probe0 : IN STD_LOGIC_VECTOR(195 DOWNTO 0)
--);
--END COMPONENT;

signal xcount_out: unsigned(PIX_BITS-1 downto 0);
signal xcount: unsigned(PIX_BITS-1 downto 0);
signal sum_reg_l3: unsigned(31 downto 0);
signal sum_reg_l2: unsigned(BITWIDTH downto 0);
signal oneby_num_pix: unsigned(31 downto 0);

type t_array_video_v is array(0 to WINDOW+1-1) of std_logic;
signal video_v: t_array_video_v;
type t_array_video_h is array(0 to WINDOW+1-1) of std_logic;
signal video_h: t_array_video_h;
type t_array_video_eoi is array(0 to WINDOW+1-1) of std_logic;
signal video_eoi: t_array_video_eoi;

type t_array_video_data2 is array(0 to WINDOW+1-1) of unsigned(BITWIDTH downto 0);
signal video_data2: t_array_video_data2;
type t_array_video_data is array(0 to WINDOW+1-1) of std_logic;
signal video_data: t_array_video_data;
type t_array_sum_reg_l1 is array(0 to WINDOW-1) of signed (BITWIDTH downto 0);
signal sum_reg_l1: t_array_sum_reg_l1;
type t_array_pix is array(0 to WINDOW-1) of unsigned(BITWIDTH-1 downto 0);
signal pix: t_array_pix;
type t_array_extra_pix_d is array(0 to WINDOW+1-1) of std_logic;
signal extra_pix_d: t_array_extra_pix_d;
type t_array_dav_d_o is array(0 to WINDOW+1-1) of std_logic;
signal dav_d_o: t_array_dav_d_o;
type t_array_dav_d is array(0 to WINDOW+1-1) of std_logic;
signal dav_d: t_array_dav_d;
signal pix_out: unsigned(63 downto 0);
signal mean_outi : unsigned(15 downto 0);

-------------------------------------------------
-- Debug signals
signal video_o_datai: std_logic;
--signal probe0: std_logic_vector(195 downto 0);

--ATTRIBUTE MARK_DEBUG : string;
--ATTRIBUTE MARK_DEBUG of video_data: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of video_i_v: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of video_i_h: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of video_i_eoi: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of video_i_data: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of video_i_dav: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of xcount: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of xcount_out: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of sum_reg_l2: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of sum_reg_l3: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of video_o_datai: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of dav_d_o: SIGNAL IS "TRUE";
--ATTRIBUTE MARK_DEBUG of mean_outi: SIGNAL IS "TRUE";

begin


oneby_num_pix <= to_unsigned(13981, 32);  -- 38836 for 384*288 

mean_out <= std_logic_vector(mean_outi);

SOBEL_FILTER_SHIFT_REG: process (clk, rst) is
begin
    if (rst = '1') then
        extra_pix_d(0) <= '0';
        extra_pix_d(1) <= '0';
        extra_pix_d(2) <= '0';
        extra_pix_d(3) <= '0';
        dav_d(0) <= '0';
        dav_d(1) <= '0';
        dav_d(2) <= '0';
        dav_d(3) <= '0';
        pix(0) <= to_unsigned(0, BITWIDTH);
        pix(1) <= to_unsigned(0, BITWIDTH);
        pix(2) <= to_unsigned(0, BITWIDTH);
        xcount <= to_unsigned(0, PIX_BITS);
    elsif rising_edge(clk) then
        extra_pix_d(0) <= '0';
        for i in 0 to 3-1 loop
            extra_pix_d((i + 1)) <= extra_pix_d(i);
        end loop;
        if ((xcount >= 1) and bool(video_i_dav)) then
            dav_d(0) <= '1';
        else
            dav_d(0) <= '0';
        end if;
        for i in 0 to WINDOW-1 loop
            dav_d((i + 1)) <= dav_d(i);
        end loop;
        if bool(video_i_h) then
            xcount <= to_unsigned(0, PIX_BITS);
            dav_d(WINDOW) <= '0';
            for i in 0 to WINDOW-1 loop
                dav_d(i) <= '0';
                pix(i) <= to_unsigned(0, BITWIDTH);
            end loop;
        end if;
        if bool(video_i_dav) then
            xcount <= (xcount + 1);
            pix(0) <= unsigned(video_i_data);
            for i in 0 to (WINDOW - 1)-1 loop
                pix((i + 1)) <= pix(i);
            end loop;
        end if;
        if ((xcount = 1) and bool(video_i_dav)) then
            pix(2) <= unsigned(video_i_data);
        end if;
        if ((xcount = VIDEO_XSIZE) and (dav_d(0) = '1')) then
            pix(0) <= pix(1);
            pix(2) <= pix(1);
            extra_pix_d(0) <= '1';
        end if;
    end if;
end process SOBEL_FILTER_SHIFT_REG;

SOBEL_FILTER_SUM_REG: process (clk, rst) is
begin
    if (rst = '1') then
        sum_reg_l2 <= to_unsigned(0, BITWIDTH+1);
        sum_reg_l1(0) <= to_signed(0, BITWIDTH+1);
        sum_reg_l1(1) <= to_signed(0, BITWIDTH+1);
        sum_reg_l1(2) <= to_signed(0, BITWIDTH+1);
    elsif rising_edge(clk) then
        sum_reg_l1(0) <= signed(resize(pix(0), BITWIDTH+1) - resize(pix(2), BITWIDTH+1));
        sum_reg_l1(1) <= signed(resize(pix(2), BITWIDTH+1) - resize(pix(0), BITWIDTH+1));
        if (sum_reg_l1(0)((BITWIDTH+1 - 1)) = '1') then
            sum_reg_l2 <= unsigned(sum_reg_l1(1)(BITWIDTH+1-1 downto 0));
        else
            sum_reg_l2 <= unsigned(sum_reg_l1(0)(BITWIDTH+1-1 downto 0));
        end if;
    end if;
end process SOBEL_FILTER_SUM_REG;

pix_out <= ((sum_reg_l3 * oneby_num_pix));

SOBEL_FILTER_MEAN_REG: process (clk, rst) is
begin
    if (rst = '1') then
        mean_outi <= to_unsigned(0, 16);
        sum_reg_l3 <= to_unsigned(0, 32);
    elsif rising_edge(clk) then
        if ((dav_d(2) = '1') or bool(extra_pix_d(2))) then
            sum_reg_l3 <= (sum_reg_l3 + sum_reg_l2);
        end if;
        if bool(video_i_v) then
            mean_outi <= pix_out((16 + 32)-1 downto 32);
            sum_reg_l3 <= to_unsigned(0, 32);
        end if;
    end if;
end process SOBEL_FILTER_MEAN_REG;

SOBEL_FILTER_PIX_OUT: process (clk, rst) is
begin
    if (rst = '1') then
        video_o_data2 <= std_logic_vector(to_unsigned(0, BITWIDTH));
        xcount_out <= to_unsigned(0, PIX_BITS);
        video_o_dav <= '0';
        video_o_datai <= '0';
        dav_d_o(0) <= '0';
        dav_d_o(1) <= '0';
        dav_d_o(2) <= '0';
        dav_d_o(3) <= '0';
        video_o_eoi <= '0';
        video_o_v <= '0';
        video_data(0) <= '0';
        video_data(1) <= '0';
        video_data(2) <= '0';
        video_data(3) <= '0';
        video_data2(0) <= to_unsigned(0, BITWIDTH+1);
        video_data2(1) <= to_unsigned(0, BITWIDTH+1);
        video_data2(2) <= to_unsigned(0, BITWIDTH+1);
        video_data2(3) <= to_unsigned(0, BITWIDTH+1);
        video_o_h <= '0';
        video_eoi(0) <= '0';
        video_eoi(1) <= '0';
        video_eoi(2) <= '0';
        video_eoi(3) <= '0';
        video_h(0) <= '0';
        video_h(1) <= '0';
        video_h(2) <= '0';
        video_h(3) <= '0';
        video_v(0) <= '0';
        video_v(1) <= '0';
        video_v(2) <= '0';
        video_v(3) <= '0';
    elsif rising_edge(clk) then
        dav_d_o(0) <= '0';
        if bool(video_i_h) then
            xcount_out <= to_unsigned(0, PIX_BITS);
        end if;
        video_data2(0) <= sum_reg_l2;
        for i in 0 to WINDOW-1 loop
            video_data2((i + 1)) <= video_data2(i);
        end loop;
        for i in 0 to WINDOW-1 loop
            dav_d_o((i + 1)) <= dav_d_o(i);
        end loop;
        if (sum_reg_l2 >= (unsigned(threshold_mult) * mean_outi)) then
            video_data(0) <= '1';
        else
            video_data(0) <= '0';
        end if;
        if (bool(dav_d(3)) or bool(extra_pix_d(3))) then
            xcount_out <= (xcount_out + 1);
            dav_d_o(0) <= '1';
            for i in 0 to WINDOW-1 loop
                video_data((i + 1)) <= video_data(i);
            end loop;
        end if;
        if ((xcount_out = 1) and (video_data(0) = '1')) then
            video_o_datai <= '1';
        elsif ((xcount_out = 2) and ((video_data(0) = '1') or (video_data(1) = '1'))) then
            video_o_datai <= '1';
        elsif ((signed(resize(xcount_out, 11)) = (VIDEO_XSIZE - 1)) and ((video_data(2) = '1') or (video_data(1) = '1'))) then
            video_o_datai <= '1';
        elsif ((xcount_out = VIDEO_XSIZE) and (video_data(2) = '1')) then
            video_o_datai <= '1';
        elsif ((video_data(0) = '1') or (video_data(1) = '1') or (video_data(2) = '1')) then
            video_o_datai <= '1';
        else
            video_o_datai <= '0';
        end if;
        video_o_data2 <= std_logic_vector(resize(video_data2(3), BITWIDTH));
        video_o_dav <= dav_d_o(2);
         video_eoi(0) <= video_i_eoi;
        video_h(0) <= video_i_h;
        video_v(0) <= video_i_v;
        for i in 0 to WINDOW-1 loop
            video_v((i + 1)) <= video_v(i);
            video_h((i + 1)) <= video_h(i);
            video_eoi((i + 1)) <= video_eoi(i);
        end loop;
        video_o_dav <= dav_d_o(2);
        video_o_eoi <= video_eoi(WINDOW);
        video_o_v <= video_v(WINDOW);
        video_o_h <= video_h(WINDOW);
    end if;
end process SOBEL_FILTER_PIX_OUT;

video_o_data <= video_o_datai;

--i_row_filter: TOII_TUVE_ila
--PORT MAP (
--    clk => clk_100,
--    probe0 => probe0
--);

--probe0 (108 downto 0) <= video_i_v & video_i_h & video_i_eoi & video_i_data & std_logic_vector(mean_outi) & std_logic_vector(sum_reg_l2) & video_data(0)
--& video_data(1) & video_data(2) & video_data(3) & dav_d_o(0) & dav_d_o(1) & dav_d_o(2) & dav_d_o(3) & video_o_datai &
--    std_logic_vector(xcount) & std_logic_vector(xcount_out) & std_logic_vector(sum_reg_l3);

--probe0(195 downto 109) <= (others=>'0');


end architecture MyHDL;
