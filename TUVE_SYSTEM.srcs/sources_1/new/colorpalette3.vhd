-- File: colorpalette3.vhd
-- Generated by MyHDL 1.0dev
-- Date: Wed Apr 11 13:02:11 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity colorpalette3 is
    generic (
            PIX_BITS : positive := 10;
            LIN_BITS : positive := 10
        );
    port (
        clk: in std_logic;
        rst: in std_logic;
        enable: in std_logic;
        palette_select: in std_logic_vector(4 downto 0);
        min_value: in std_logic_vector(7 downto 0);
        max_value: in std_logic_vector(7 downto 0);
        video_i_v: in std_logic;
        video_i_h: in std_logic;
        video_i_dav: in std_logic;
        video_i_data: in std_logic_vector(7 downto 0);
        video_i_eoi: in std_logic;
        video_i_xsize: in std_logic_vector(PIX_BITS-1 downto 0);
        video_i_ysize: in std_logic_vector(LIN_BITS-1 downto 0);
        video_o_v: out std_logic;
        video_o_h: out std_logic;
        video_o_dav: out std_logic;
        video_o_data: out std_logic_vector(23 downto 0);
        video_o_eoi: out std_logic;
        video_o_xsize: out std_logic_vector(PIX_BITS-1 downto 0);
        video_o_ysize: out std_logic_vector(LIN_BITS-1 downto 0)
    );
end entity colorpalette3;


architecture MyHDL of colorpalette3 is


signal addr: std_logic_vector(7 downto 0);
signal addr_0: std_logic_vector(7 downto 0);
signal addr_1: std_logic_vector(23 downto 0);


signal r_dout: std_logic_vector(7 downto 0);
signal g_dout: std_logic_vector(7 downto 0);
signal b_dout: std_logic_vector(7 downto 0);

signal video_dav: std_logic_vector(0 to 7);
type video_array is array (0 to 7) of std_logic_vector(7 downto 0);
signal video_data: video_array;
signal video_v: std_logic_vector(0 to 7);
signal video_h: std_logic_vector(0 to 7);
signal video_eoi: std_logic_vector(0 to 7);
signal palette_select_d: std_logic_vector(4 downto 0);
signal video_eoi_d0, video_eoi_d1, video_eoi_d2, video_eoi_d3: std_logic;
signal enable_d: std_logic;

signal min_value_d: std_logic_vector(min_value'range);
signal max_value_d: std_logic_vector(max_value'range);

signal dvsr, dvnd, quo, rmd: std_logic_vector(15 downto 0);
signal start, done: std_logic;
signal mult: std_logic_vector(15 downto 0);
signal i: integer;

begin

video_data(0) <= video_i_data;
video_v(0) <= video_i_v;
video_h(0) <= video_i_h;
video_dav(0) <= video_i_dav;
video_eoi(0) <= video_i_eoi;

-- Latency of 3 clk cycles
i_generic      : entity work.cp_generic
port map (clk=>clk, palette=>palette_select_d, addr=>addr, r_dout=>r_dout, g_dout=>g_dout, b_dout=>b_dout);

COLORPALETTE2_PALETTE_SELECT_LOGIC: process (clk, rst) is
begin
    if (rst = '1') then
        for i in 1 to 7 loop
            video_data(i) <= std_logic_vector(to_unsigned(0, 8));
            video_v(i) <= '0';
            video_h(i) <= '0';
            video_dav(i) <= '0';
            video_eoi(i) <= '0';
        end loop;
        enable_d <= '0';
        palette_select_d <=  (others =>'0');
        video_o_xsize <= (others =>'0');
        video_o_ysize <= (others =>'0');
        video_o_data <= (others=>'0');
        video_o_dav <= '0';
        min_value_d <= std_logic_vector(to_unsigned(0, min_value_d'length));
        max_value_d <= std_logic_vector(to_unsigned(255, max_value_d'length));
        start <= '0';
        video_o_v <= '0';
        video_o_h <= '0';
        video_o_eoi <= '0';
    elsif rising_edge(clk) then
        start <= '0';
        for i in 0 to 7-1 loop
            video_data(i+1) <= video_data(i)  ;
            video_v(i+1)      <= video_v(i)   ;
            video_h(i+1)      <= video_h(i)   ;
            video_dav(i+1)    <= video_dav(i) ;
            video_eoi(i+1)    <= video_eoi(i) ;
        end loop;
        video_o_xsize <= video_i_xsize;
        video_o_ysize <= video_i_ysize;
        video_o_v <= video_v(7);
        video_o_h <= video_h(7);
        video_o_eoi <= video_eoi(7);
        if (video_v(0)='1') then
            enable_d <= enable;
            palette_select_d <= (palette_select);
            min_value_d <= min_value;
            max_value_d <= max_value;
            if(palette_select(4)='1') then
                start <= '1';
                dvnd <= std_logic_vector(to_unsigned(255*2**8, dvsr'length));
                dvsr <= std_logic_vector(resize(unsigned(max_value)-unsigned(min_value), dvsr'length));
                mult <= quo;
            else
                mult <= std_logic_vector(to_unsigned(256, mult'length));
            end if;
        end if;
        if(unsigned(video_data(0))>=unsigned(min_value_d) and unsigned(video_data(0))<=unsigned(max_value_d) and palette_select_d(4)='1') then
            addr_0 <= std_logic_vector(unsigned(video_data(0)) - unsigned(min_value_d));
        else
            addr_0 <= video_data(0);
        end if;
        addr_1 <= std_logic_vector(unsigned(addr_0)*unsigned(mult));
        addr <= addr_1( 15 downto 8);
        if (enable_d='1') then
            if(palette_select_d(4)='1') then
                if(unsigned(video_data(7))>=unsigned(min_value_d) and unsigned(video_data(7))<=unsigned(max_value_d)) then
                    video_o_data <= r_dout & g_dout & b_dout;
                else
                    video_o_data <= video_data(7) & video_data(7) & video_data(7);
                end if;
            else
                video_o_data <= r_dout & g_dout & b_dout;
            end if;
        else
            video_o_data <= video_data(7) & video_data(7) & video_data(7);
        end if;
        video_o_dav <= video_dav(7);
    end if;
end process COLORPALETTE2_PALETTE_SELECT_LOGIC;


inst_div:entity WORK.div
    generic map (
        W => 16,
        CBIT => 5
        )
    port map (
        clk => clk,
        reset => rst,
        start => start,
        dvsr => dvsr,
        dvnd => dvnd,
        done_tick => done,
        quo => quo,
        rmd => rmd
        );


end architecture MyHDL;