-- File: box_filter.vhd
-- Generated by MyHDL 1.0dev
-- Date: Tue Mar 27 20:39:18 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity box_filter is
    generic (
        WINDOW: positive:=11;
        HW: positive:=5;
        BITWIDTH : positive:= 14;
        VIDEO_XSIZE: positive:=640;
        VIDEO_YSIZE:positive:=480;
        PIX_BITS : positive:=10;
        LIN_BITS : positive:=9
        );
    port (
        clk: in std_logic;
        rst: in std_logic;
        clk_100: in std_logic;
        enable: in std_logic;
        video_i_v: in std_logic;
        video_i_h: in std_logic;
        video_i_dav: in std_logic;
        video_i_data: in std_logic_vector(BITWIDTH-1 downto 0);
        video_i_eoi: in std_logic;
        video_o_v: out std_logic;
        video_o_h: out std_logic;
        video_o_dav: out std_logic;
        video_o_data: out std_logic_vector(BITWIDTH-1 downto 0);
        video_o_diff: out std_logic_vector(BITWIDTH downto 0);
        video_o_eoi: out std_logic
    );
end entity box_filter;


architecture MyHDL of box_filter is

COMPONENT TOII_TUVE_ila

PORT (
    clk : IN STD_LOGIC;



    probe0 : IN STD_LOGIC_VECTOR(195 DOWNTO 0)
);
END COMPONENT;


signal xcount: unsigned(PIX_BITS-1 downto 0);
signal pix_out: unsigned(47 downto 0);
signal pix_1byW: unsigned(15 downto 0);
signal enable_d: std_logic;
signal accum: unsigned(31 downto 0);
type t_array_video_v is array(0 to HW+1-1) of std_logic;
signal video_v: t_array_video_v;
type t_array_video_h is array(0 to HW+1-1) of std_logic;
signal video_h: t_array_video_h;
type t_array_video_eoi is array(0 to HW+1-1) of std_logic;
signal video_eoi: t_array_video_eoi;
type t_array_pix is array(0 to WINDOW-1) of unsigned(BITWIDTH-1 downto 0);
signal pix: t_array_pix;
type t_array_extra_pix is array(0 to HW+1-1) of std_logic;
signal extra_pix: t_array_extra_pix;
type t_array_dav_d is array(0 to HW+1-1) of std_logic;
signal dav_d: t_array_dav_d;
signal pix_reg: unsigned(BITWIDTH-1 downto 0);
signal pix_out_reg: unsigned(47 downto 0);


------------------------------------------------------------------------
--debug signals
signal video_o_dataii : std_logic_vector(video_o_data'range);
signal video_o_datai : std_logic_vector(video_o_diff'range);
signal probe0: std_logic_vector(195 downto 0);


ATTRIBUTE MARK_DEBUG : string;
ATTRIBUTE MARK_DEBUG of video_i_v: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_h: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_dav: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_eoi: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_data: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of pix_reg: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of pix_out_reg: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of dav_d: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_o_datai: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_o_dataii: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of xcount: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of accum: SIGNAL IS "TRUE";



begin

pix_1byW <= to_unsigned((2**16)/(WINDOW), 16);


BOX_FILTER_SHIFT_REG: process (clk, rst) is
begin
    if (rst = '1') then
        for i in 0 to WINDOW-1 loop
            pix(i) <= to_unsigned(0, BITWIDTH);
        end loop;
        xcount <= to_unsigned(0, PIX_BITS);
        accum <= to_unsigned(0, 32);
        for i in 0 to HW loop
            extra_pix(i) <= '0';
        end loop;
        for i in 0 to HW loop
            dav_d(i) <= '0';
        end loop;
    elsif rising_edge(clk) then
        extra_pix(0) <= '0';
        for i in 0 to HW-1 loop
            extra_pix((i + 1)) <= extra_pix(i);
        end loop;
        if bool(video_i_h) then
            xcount <= to_unsigned(0, PIX_BITS);
            accum <= to_unsigned(0, 32);
            for i in 0 to HW loop
                dav_d(i) <= '0';
            end loop;
            for i in 0 to WINDOW-1 loop
                pix(i) <= to_unsigned(0, BITWIDTH);
            end loop;
        end if;
        if bool(video_i_dav) then
            xcount <= (xcount + 1);
            pix(0) <= unsigned(video_i_data);
            for i in 0 to (WINDOW - 1)-1 loop
                pix((i + 1)) <= pix(i);
            end loop;
            if ((xcount > 0) and (xcount <= HW)) then
                accum <= (accum + shift_left(resize(unsigned(video_i_data), 32), 1));
            else
                accum <= resize(unsigned(signed(resize(accum, 33)) + (signed(resize(unsigned(video_i_data), BITWIDTH+1)) - signed(resize(pix((WINDOW - 1)), BITWIDTH+1)))), 32);
            end if;
        end if;
        if ((xcount >= HW) and bool(video_i_dav)) then
            dav_d(0) <= '1';
        else
            dav_d(0) <= '0';
        end if;
        for i in 0 to HW-1 loop
            dav_d((i + 1)) <= dav_d(i);
        end loop;
        for i in 0 to HW-1 loop
            if ((signed(resize(xcount, PIX_BITS+1)) = (i + 1)) and bool(video_i_dav)) then
                pix(((i + 1) * 2)) <= unsigned(video_i_data);
            end if;
        end loop;
        for j in 0 to HW-1 loop
            if ((signed(resize(xcount, PIX_BITS+1)) = (VIDEO_XSIZE + j)) and (dav_d(j) = '1')) then
                accum <= resize(unsigned(signed(resize(accum, 33)) + (signed(resize(pix(((j * 2) + 1)), BITWIDTH+1)) - signed(resize(pix((WINDOW - 1)), BITWIDTH+1)))), 32);
                xcount <= (xcount + 1);
                extra_pix(0) <= '1';
                for i in 0 to (WINDOW - 1)-1 loop
                    pix((i + 1)) <= pix(i);
                end loop;
                pix(0) <= pix(((j * 2) + 1));
            end if;
        end loop;
    end if;
end process BOX_FILTER_SHIFT_REG;

pix_out <= pix_1byW * accum;

BOX_FILTER_PIX_OUT_LOGIC: process (clk, rst) is
begin
    if (rst = '1') then
        video_o_dav <= '0';
        enable_d <= '0';
        video_o_diff <= std_logic_vector(to_signed(0, BITWIDTH+1));
        video_o_data <= std_logic_vector(to_unsigned(0, BITWIDTH));
        pix_out_reg <= to_unsigned(0, 48);
        pix_reg <= to_unsigned(0, BITWIDTH);
        video_o_datai <= (others=>'0');
        video_o_dataii <= (others=>'0');
    elsif rising_edge(clk) then
        pix_out_reg <= pix_out;
        pix_reg <= pix(HW);
        if bool(video_i_v) then
            enable_d <= enable;
        end if;
        if bool(enable_d) then
            video_o_data <= std_logic_vector(pix_out_reg((16 + BITWIDTH)-1 downto 16));
        else
            video_o_data <= std_logic_vector(pix_reg);
        end if;
        video_o_dataii <= std_logic_vector(pix_out_reg((16 + BITWIDTH)-1 downto 16));
        video_o_diff <= std_logic_vector(signed(resize(pix_reg, BITWIDTH+1) - resize(pix_out_reg((16 + BITWIDTH)-1 downto 16), BITWIDTH+1)));
        video_o_datai <= std_logic_vector(signed(resize(pix_reg, BITWIDTH+1) - resize(pix_out_reg((16 + BITWIDTH)-1 downto 16), BITWIDTH+1)));
        video_o_dav <= stdl(bool(dav_d(1)) or bool(extra_pix(1)));
    end if;
end process BOX_FILTER_PIX_OUT_LOGIC;

BOX_FILTER_DELAY_PROCESS: process (clk, rst) is
begin
    if (rst = '1') then
        for i in 0 to HW loop
            video_v(i) <= '0';
            video_h(i) <= '0';
            video_eoi(i) <= '0';
        end loop;
        video_o_eoi <= '0';
        video_o_h <= '0';
        video_o_v <= '0';
    elsif rising_edge(clk) then
        video_v(0) <= video_i_v;
        video_h(0) <= video_i_h;
        video_eoi(0) <= video_i_eoi;
        video_o_v <= video_v(HW);
        video_o_h <= video_h(HW);
        video_o_eoi <= video_eoi(HW);
        for i in 0 to HW-1 loop
            video_v((i + 1)) <= video_v(i);
            video_h((i + 1)) <= video_h(i);
            video_eoi((i + 1)) <= video_eoi(i);
        end loop;
    end if;
end process BOX_FILTER_DELAY_PROCESS;

--i_row_filter: TOII_TUVE_ila
--PORT MAP (
--    clk => clk_100,
--    probe0 => probe0
--);

--probe0(0)<=video_i_v;
--probe0(1)<=video_i_h;
--probe0(2)<=video_i_dav;
--probe0(3)<=video_i_eoi;
--probe0(17 downto 4) <= video_i_data;
--probe0(31 downto 18) <= std_logic_vector(pix_reg);
--probe0(63 downto 32) <= std_logic_vector(accum);
--probe0(64) <= dav_d(0);
--probe0(65) <= dav_d(1);
--probe0(75 downto 66)<= std_logic_vector(xcount);
--probe0(123 downto 76) <= std_logic_vector(pix_out_reg);
--probe0(138 downto 124) <= video_o_datai;
--probe0(152 downto 139) <= video_o_dataii;
--probe0(195 downto 153) <= (others=>'0');



end architecture MyHDL;
