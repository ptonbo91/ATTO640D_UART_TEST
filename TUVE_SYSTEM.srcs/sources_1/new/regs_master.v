
// File: regs_master.v
// Generated by MyHDL 1.0dev
// Date: Thu Nov  9 11:00:40 2017

//`define ILA_SDRAM
`timescale 1ns/10ps
          
module regs_master #(
    parameter SYS_FREQ      = 27000000,
//              SPI_FREQ      = 1000000,
              I2C_FREQ      = 100000,
              PIX_BITS      = 10,
              LIN_BITS      = 10,
              VIDEO_XSIZE   = 640,
              VIDEO_YSIZE   = 480,
              DMA_SIZE_BITS = 5
)(
    clk,
    rst,
    clk_27mhz,
    rst_27mhz, 
    sel_oled_analog_video_out,
    coarse_offset_calib_start,
    product_sel,
    bat_adc_en,
    trigger,
    sensor_trigger,
    sensor_power_on_init_done,
    adv_reset_n,
    tick_1ms,
    tick_1us,
    tick_1s,
    PAL_nNTSC_SEL_DONE,
    PAL_nNTSC,
    pal_ntsc_sel,
//    adv_sleep_mode_en,
//    oled_reinit_en,
    standby_en_valid,
    standby_en,
    oled_reset,
    oled_power_off,
    OLED_VGN_TEST,
    OLED_GAMMA_TABLE_SEL,
    OLED_POS_V,
    OLED_POS_V_VALID,  
    OLED_POS_H,   
    OLED_POS_H_VALID,   
    OLED_BRIGHTNESS,  
    OLED_BRIGHTNESS_VALID,
    OLED_CONTRAST,
    OLED_CONTRAST_VALID,  
    OLED_IDRF,
    OLED_IDRF_VALID, 
    OLED_DIMCTL,     
    OLED_DIMCTL_VALID, 
    OLED_IMG_FLIP,
    OLED_IMG_FLIP_VALID,  
    OLED_CATHODE_VOLTAGE,
    OLED_CATHODE_VOLTAGE_VALID,    
    OLED_ROW_START_MSB, 
    OLED_ROW_START_MSB_VALID,
    OLED_ROW_START_LSB, 
    OLED_ROW_START_LSB_VALID,
    OLED_ROW_END_MSB, 
    OLED_ROW_END_MSB_VALID,
    OLED_ROW_END_LSB, 
    OLED_ROW_END_LSB_VALID,
//    OLED_REG_DATA_IN,            
    OLED_DEV_ADDR,
    ADV_DEV_ADDR, 
    BAT_GAUGE_DEV_ADDR,  
    BAT_ADC_DEV_ADDR,
    OLED_VGN_ADC_DEV_ADDR,     
    MAX_VGN_SETTLE_TIME,
    MAX_OLED_VGN_RD_PERIOD,
    MAX_BAT_PARAM_RD_PERIOD,
    bat_control_reg_data,
    bat_status_reg_data,
    bat_temp_reg_data,
    bat_voltage_reg_data,
    bat_acc_charge_reg_data,
    
    magneto_x_data,
    magneto_y_data,
    magneto_z_data,

    accel_x_data,
    accel_y_data,
    accel_z_data,
    
    qspi_init_cmd_done, 
    BT656_START, 
    video_start,
    battery_disp_start,
    LOGO_WR_EN,
    LOGO_WR_DATA,
    RETICLE_WR_EN,
    RETICLE_WR_DATA,
    RETICLE_OFFSET_WR_EN,
    RETICLE_OFFSET_WR_DATA,    
    DMA_WRITE_FREE,
    RETICLE_POS_X,
    RETICLE_POS_Y,
    RETICLE_OFFSET_X,
    RETICLE_OFFSET_Y,
//    update_gfid_gsk,
//    new_gfid_gsk_start_addr,
    update_sensor_param,
    new_sensor_param_start_addr,
    sensor_init_data_len,
    SNSR_FPGA_NRST_SPI_CS,
    SNSR_FPGA_I2C2_SCL_SPI_SCK, 
    SNSR_FPGA_I2C2_SDA_SPI_SDO,
    
    qspi_reticle_transfer_rq,
    qspi_reticle_transfer_rq_ack,
    qspi_reticle_transfer_done,
    reticle_sel,
//    mux_zoom_mode,
                             
    OSD_MARK_BP              ,      
    OSD_MARK_BP_VALID        ,      
    OSD_UNMARK_BP            ,      
    OSD_UNMARK_BP_VALID      ,      
    OSD_SAVE_BP              ,      
    OSD_LOAD_USER_SETTINGS   ,      
    OSD_LOAD_FACTORY_SETTINGS,      
    OSD_SAVE_USER_SETTINGS   ,  
        
    user_settings_mem_wr_addr,
    user_settings_mem_wr_data,
    user_settings_mem_wr_req,
    user_settings_mem_rd_req,
    user_settings_mem_rd_data,
    user_settings_mem_rd_addr,
    user_settings_init_start,
    user_settings_init_done, 
    
    
    av_uart_address,
    av_uart_read,
    av_uart_readdata,
    av_uart_readdatavalid,
    av_uart_write,
    av_uart_writedata,
    av_uart_waitrequest,
    av_fpga_address,
    av_fpga_read,
    av_fpga_readdata,
    av_fpga_readdatavalid,
    av_fpga_write,
    av_fpga_writedata,
    av_fpga_waitrequest,
    av_rdsdram_address,
    av_rdsdram_read,
    av_rdsdram_readdata,
    av_rdsdram_readdatavalid,
    av_rdsdram_burstcount,
    av_rdsdram_waitrequest,
    av_wrsdram_address,
    av_wrsdram_write,
    av_wrsdram_writeburst,
    av_wrsdram_writedata,
    av_wrsdram_burstcount,
    av_wrsdram_byteenable,
    av_wrsdram_waitrequest,
    av_i2c_address,
    av_i2c_read,
    av_i2c_readdata,
    av_i2c_readdatavalid,
    av_i2c_write,
    av_i2c_writedata,
    av_i2c_waitrequest,
    av_i2c_data_16_en,
    i2c_ack_error,
//    av_sensor_address,
//    av_sensor_read,
//    av_sensor_readdata,
//    av_sensor_readdatavalid,
//    av_sensor_write,
//    av_sensor_writedata,
//    av_sensor_waitrequest,    
//    av_sensor_write1,
//    av_sensor_writedata1, 
//    av_sensor_address1,   
////    av_sensor_i2c_address,
////    av_sensor_i2c_read,
////    av_sensor_i2c_readdata,
////    av_sensor_i2c_readdatavalid,
////    av_sensor_i2c_write,
////    av_sensor_i2c_writedata,
////    av_sensor_i2c_waitrequest,
    snap_trigger,
    snap_channel,
    snap_mode,
    snap_image_numbers,
    snap_done,
    single_snapshot_en,
//    continuous_snapshot_en,
    burst_snapshot_en,
    burst_capture_size,
    snapshot_counter,
    snapshot_save_done,
    gallery_img_number,
    osd_snapshot_delete_en,
    snapshot_delete_done,
    gallery_img_valid_save_done,
    gallery_img_valid,
    gallery_img_valid_en,
//    av_spi_address,
//    av_spi_read,
//    av_spi_readdata,
//    av_spi_readdatavalid,
//    av_spi_write,
//    av_spi_writedata,
//    av_spi_waitrequest,
    sd_bus_busy_o,
    sd_bus_addr_i,
    sd_bus_rd_i,
    sd_bus_data_o,
    sd_bus_hndShk_o,
    sd_bus_wr_i,
    sd_bus_data_i,
    sd_bus_hndShk_i,
    sd_bus_error_o,
    FPGA_SPI_DQ0,
    FPGA_SPI_DQ1,
    FPGA_SPI_DQ2,
    FPGA_SPI_DQ3,
    FPGA_SPI_CS,
    gallery_img_rd_qspi_wr_sdram_en,
    ch_img_rd_qspi_wr_sdram_en,
    ch_img_sdram_addr,
    ch_img_qspi_addr,
    ch_img_len,
    ch_img_sum,

//    device_id,

    PRDCT_NAME_WRITE_DATA,
    PRDCT_NAME_WRITE_DATA_VALID,            
    temperature_write_data,
    temperature_write_data_valid,
    temperature_rd_data,
    temperature_rd_data_valid,
    temperature_rd_rq,
    temperature_wr_addr,
    temperature_wr_rq,
    control_sdram_write_start_stop,    
    shutter_en,
    toggle_gpio,
    nuc1pt_start_in,
    nuc1pt_done,
    nuc1pt_start
    

);

`include "qspi_defs.vh"
`include "TOII_TUVE_HEADER.vh"

input bat_adc_en;

input sel_oled_analog_video_out;
input coarse_offset_calib_start;
input                   product_sel;
input [PIX_BITS : 0]    RETICLE_POS_X;
input [LIN_BITS -1 : 0] RETICLE_POS_Y;
input [PIX_BITS : 0]    RETICLE_OFFSET_X;
input [LIN_BITS -1 : 0] RETICLE_OFFSET_Y;

input          qspi_reticle_transfer_rq;
input [6:0]    reticle_sel;
//input [2:0]    mux_zoom_mode;
output reg     qspi_reticle_transfer_done;
output reg     qspi_reticle_transfer_rq_ack;

input OSD_MARK_BP              ;
input OSD_MARK_BP_VALID        ;
input OSD_UNMARK_BP            ;
input OSD_UNMARK_BP_VALID      ;
input OSD_SAVE_BP              ;
input OSD_LOAD_USER_SETTINGS   ;
input OSD_LOAD_FACTORY_SETTINGS;
input OSD_SAVE_USER_SETTINGS   ;

input          user_settings_mem_wr_req;
input          user_settings_mem_rd_req;
input  [7:0]   user_settings_mem_wr_addr;
input  [7:0]   user_settings_mem_rd_addr;
input  [31:0]  user_settings_mem_wr_data;
output [31:0]  user_settings_mem_rd_data;
output reg     user_settings_init_start;
input          user_settings_init_done;

input  gallery_img_rd_qspi_wr_sdram_en;
input  ch_img_rd_qspi_wr_sdram_en;
input  [31:0] ch_img_sdram_addr;
input  [31:0] ch_img_qspi_addr;
input  [31:0] ch_img_len;
output reg [63:0]ch_img_sum;
reg [63:0]ch_img_sum_temp;

input   DMA_WRITE_FREE;
output  reg SNSR_FPGA_NRST_SPI_CS;
inout  SNSR_FPGA_I2C2_SCL_SPI_SCK; 
inout  SNSR_FPGA_I2C2_SDA_SPI_SDO;

//output reg [31:0] device_id;

output reg [7:0] PRDCT_NAME_WRITE_DATA;
output reg       PRDCT_NAME_WRITE_DATA_VALID;

output reg [7:0] temperature_write_data;
output reg temperature_write_data_valid;

input      [15:0] temperature_rd_data;
input            temperature_rd_data_valid;
output reg       temperature_rd_rq;
output reg       temperature_wr_rq;
output reg [7:0] temperature_wr_addr;

reg sensor_init_write_data_valid;
reg [7:0] sensor_init_write_data;

inout  FPGA_SPI_DQ0;
inout  FPGA_SPI_DQ1;
inout  FPGA_SPI_DQ2;
inout  FPGA_SPI_DQ3;
output FPGA_SPI_CS;
input clk;
input rst;
input clk_27mhz;
input rst_27mhz;
input trigger;
output reg sensor_trigger;

output adv_reset_n;
reg adv_reset_n;
input tick_1ms;
input tick_1us;
input tick_1s;

input PAL_nNTSC_SEL_DONE;
(* mark_debug = "true" *)input PAL_nNTSC;
(* mark_debug = "true" *)input pal_ntsc_sel;
//(* mark_debug = "true" *)input adv_sleep_mode_en;
//(* mark_debug = "true" *)input oled_reinit_en;
(* mark_debug = "true" *)input standby_en_valid;
(* mark_debug = "true" *)input standby_en;

(* mark_debug = "true" *)output reg oled_reset;
(* mark_debug = "true" *)output reg oled_power_off;
    
(* mark_debug = "true" *)input [31:0] OLED_VGN_TEST;
input [7:0] OLED_GAMMA_TABLE_SEL;
input [7:0] OLED_POS_V;     
input [8:0] OLED_POS_H;     
input [7:0] OLED_BRIGHTNESS;
input [7:0] OLED_CONTRAST;  
input [7:0] OLED_IDRF;      
input [7:0] OLED_DIMCTL;
input [7:0] OLED_IMG_FLIP;
input [7:0] OLED_CATHODE_VOLTAGE;
input [7:0] OLED_ROW_START_MSB; 
input [7:0] OLED_ROW_START_LSB;
input [7:0] OLED_ROW_END_MSB; 
input [7:0] OLED_ROW_END_LSB;

input OLED_POS_V_VALID;     
input OLED_POS_H_VALID;     
input OLED_BRIGHTNESS_VALID;
input OLED_CONTRAST_VALID;  
input OLED_IDRF_VALID;      
input OLED_DIMCTL_VALID;  
input OLED_IMG_FLIP_VALID;
input OLED_CATHODE_VOLTAGE_VALID;
input OLED_ROW_START_MSB_VALID;
input OLED_ROW_START_LSB_VALID;  
input OLED_ROW_END_MSB_VALID;  
input OLED_ROW_END_LSB_VALID;
//input [7:0] OLED_REG_DATA_IN;     



output reg [7:0]  ADV_DEV_ADDR;
output reg [7:0]  OLED_DEV_ADDR;
output reg [7:0]  BAT_GAUGE_DEV_ADDR;
output reg [7:0]  BAT_ADC_DEV_ADDR;
output reg [7:0]  OLED_VGN_ADC_DEV_ADDR;
input      [7:0]  MAX_VGN_SETTLE_TIME;
input      [15:0] MAX_OLED_VGN_RD_PERIOD;
input      [15:0] MAX_BAT_PARAM_RD_PERIOD;
output reg [7:0]  bat_control_reg_data;
output reg [7:0]  bat_status_reg_data;
(* mark_debug = "true" *)output reg [15:0]  bat_voltage_reg_data;
output reg [15:0]  bat_acc_charge_reg_data;
output reg [15:0]  bat_temp_reg_data;

output reg [15:0]  magneto_x_data;
output reg [15:0]  magneto_y_data;
output reg [15:0]  magneto_z_data;

output reg [15:0]  accel_x_data;
output reg [15:0]  accel_y_data;
output reg [15:0]  accel_z_data;

output reg qspi_init_cmd_done;
output reg BT656_START;
output reg video_start;
output reg battery_disp_start;

output reg [31:0] RETICLE_WR_DATA;
output reg        RETICLE_WR_EN;

output reg [31:0] RETICLE_OFFSET_WR_DATA;
output reg        RETICLE_OFFSET_WR_EN;

output reg [31:0] LOGO_WR_DATA;
output reg        LOGO_WR_EN;


input snap_done;
output snap_trigger;
output [2:0] snap_mode;
output [2:0] snap_channel;
output  [7:0] snap_image_numbers;

input single_snapshot_en;
//input continuous_snapshot_en;
input burst_snapshot_en;
input [7:0]burst_capture_size;
input [7:0]snapshot_counter;
input [7:0]gallery_img_number;
input      osd_snapshot_delete_en;
output reg snapshot_delete_done;
output reg gallery_img_valid_save_done;
output reg [71:0]gallery_img_valid;
output reg       gallery_img_valid_en;
reg gallery_img_valid_save_en;

output [7:0] av_uart_address;
reg [7:0] av_uart_address;
output av_uart_read;
reg av_uart_read;
input [31:0] av_uart_readdata;
input av_uart_readdatavalid;
output av_uart_write;
reg av_uart_write;
output [31:0] av_uart_writedata;
reg [31:0] av_uart_writedata;
input av_uart_waitrequest;

output [31:0] av_fpga_address;
// reg [31:0] av_fpga_address;
output av_fpga_read;
// reg av_fpga_read;
input [31:0] av_fpga_readdata;
input av_fpga_readdatavalid;
output av_fpga_write;
// reg av_fpga_write;
output [31:0] av_fpga_writedata;
// reg [31:0] av_fpga_writedata;
input av_fpga_waitrequest;

output [31:0] av_rdsdram_address;
reg [31:0] av_rdsdram_address;
output av_rdsdram_read;
reg av_rdsdram_read;
input [31:0] av_rdsdram_readdata;
input av_rdsdram_readdatavalid;
output [DMA_SIZE_BITS-1:0] av_rdsdram_burstcount;
reg [DMA_SIZE_BITS-1:0] av_rdsdram_burstcount;
input av_rdsdram_waitrequest;

output [31:0] av_wrsdram_address;
reg [31:0] av_wrsdram_address;
output av_wrsdram_write;
reg av_wrsdram_write;
output av_wrsdram_writeburst;
reg av_wrsdram_writeburst;
output [31:0] av_wrsdram_writedata;
reg [31:0] av_wrsdram_writedata;
output [DMA_SIZE_BITS-1:0] av_wrsdram_burstcount;
reg [DMA_SIZE_BITS-1:0] av_wrsdram_burstcount;
input [3:0] av_wrsdram_byteenable;
input av_wrsdram_waitrequest;

(* mark_debug = "true" *)output [15:0] av_i2c_address;
reg [15:0] av_i2c_address;
(* mark_debug = "true" *)output av_i2c_read;
(* mark_debug = "true" *)reg av_i2c_read;
input [15:0] av_i2c_readdata;
(* mark_debug = "true" *)input av_i2c_readdatavalid;
(* mark_debug = "true" *)output av_i2c_write;
reg av_i2c_write;
(* mark_debug = "true" *)output [15:0] av_i2c_writedata;
reg [15:0] av_i2c_writedata;
(* mark_debug = "true" *)input av_i2c_waitrequest;

(* mark_debug = "true" *)output av_i2c_data_16_en;
(* mark_debug = "true" *)reg av_i2c_data_16_en;

(* mark_debug = "true" *)input i2c_ack_error;

reg [15:0] DELAY_CNT;

//(* mark_debug = "true" *)output [31:0] av_sensor_address;
//// (* mark_debug = "true" *)reg [31:0] av_sensor_address;
//(* mark_debug = "true" *)output av_sensor_read;
//// (* mark_debug = "true" *)reg av_sensor_read;
//(* mark_debug = "true" *)input [31:0] av_sensor_readdata;
//(* mark_debug = "true" *)input av_sensor_readdatavalid;
//(* mark_debug = "true" *)output av_sensor_write;
//// (* mark_debug = "true" *)reg av_sensor_write;
//(* mark_debug = "true" *)output [31:0] av_sensor_writedata;
//// (* mark_debug = "true" *)reg [31:0] av_sensor_writedata;
//(* mark_debug = "true" *)input av_sensor_waitrequest;
//(* mark_debug = "true" *)output av_sensor_write1;
//(* mark_debug = "true" *)reg av_sensor_write1;
//(* mark_debug = "true" *)output [31:0] av_sensor_writedata1;
//(* mark_debug = "true" *)reg [31:0] av_sensor_writedata1;
//(* mark_debug = "true" *)output [31:0] av_sensor_address1;
//(* mark_debug = "true" *)reg [31:0] av_sensor_address1;

//(* mark_debug = "true" *)output [31:0] av_sensor_i2c_address;
//(* mark_debug = "true" *)reg [31:0] av_sensor_i2c_address;
//(* mark_debug = "true" *)output av_sensor_i2c_read;
//(* mark_debug = "true" *)reg av_sensor_i2c_read;
//(* mark_debug = "true" *)input [7:0] av_sensor_i2c_readdata;
//(* mark_debug = "true" *)input av_sensor_i2c_readdatavalid;
//(* mark_debug = "true" *)output av_sensor_i2c_write;
//(* mark_debug = "true" *)reg av_sensor_i2c_write;
//(* mark_debug = "true" *)output [7:0] av_sensor_i2c_writedata;
//(* mark_debug = "true" *)reg [7:0] av_sensor_i2c_writedata;
//(* mark_debug = "true" *)input av_sensor_i2c_waitrequest;

//output [7:0] av_spi_address;
//reg [7:0] av_spi_address;
//wire av_spi_read;
//wire [31:0] av_spi_readdata;
//wire av_spi_readdatavalid;
//output av_spi_write;
//reg av_spi_write;
//output [31:0] av_spi_writedata;
//reg [31:0] av_spi_writedata;

reg [31:0] sensor_init_gfid_store;
reg [31:0] sensor_init_gsk_store;
reg [31:0] sensor_init_gsk_store1;
reg [31:0] sensor_init_int_time_store;
reg [31:0] sensor_init_int_time_store1;
reg [31:0] sensor_init_gain_store;
reg sensor_init_gfid_store_en     ;
reg sensor_init_gsk_store_en      ;
reg sensor_init_gsk_store1_en      ;
reg sensor_init_int_time_store_en ;
reg sensor_init_int_time_store1_en ;
reg sensor_init_gain_store_en     ; 

(* mark_debug = "true" *)reg [31:0] av_sensor_i2c_address;

(* mark_debug = "true" *)reg av_sensor_i2c_read;
(* mark_debug = "true" *)wire [7:0] av_sensor_i2c_readdata;
(* mark_debug = "true" *)wire av_sensor_i2c_readdatavalid;
(* mark_debug = "true" *)reg av_sensor_i2c_write;
(* mark_debug = "true" *)reg [7:0] av_sensor_i2c_writedata;
(* mark_debug = "true" *)wire  av_sensor_i2c_waitrequest;

//wire av_spi_waitrequest;


//reg [7:0] sensor_spi_address;
//wire sensor_spi_read;
//wire [31:0] sensor_spi_readdata;
//wire sensor_spi_readdatavalid;
//output av_spi_write;
//reg sensor_spi_write;
//output [31:0] av_spi_writedata;
//(* mark_debug = "true" *)reg [31:0] sensor_spi_writedata;
//wire sensor_spi_waitrequest;



output reg control_sdram_write_start_stop;
input shutter_en;
(* mark_debug = "true" *)input   toggle_gpio;
(* mark_debug = "true" *)input   nuc1pt_done;
(* mark_debug = "true" *)input   nuc1pt_start_in;
(* mark_debug = "true" *)output  reg nuc1pt_start;

input sd_bus_busy_o;
output [31:0] sd_bus_addr_i;
reg [31:0] sd_bus_addr_i;
output sd_bus_rd_i;
reg sd_bus_rd_i;
input [7:0] sd_bus_data_o;
input sd_bus_hndShk_o;
output sd_bus_wr_i;
reg sd_bus_wr_i;
output [7:0] sd_bus_data_i;
reg [7:0] sd_bus_data_i;
output sd_bus_hndShk_i;
reg sd_bus_hndShk_i;
input [15:0] sd_bus_error_o;


reg we_rdb;
reg we_db;
reg [9:0] wait_cnt;
reg trigger_reg;
wire trigger_edge;
reg [31:0] timeout_count;
reg [7:0]  uart_data_timeout_count;
/*(* mark_debug = "true" *)*/reg [6:0] st_temp;
(* mark_debug = "true" *)reg [6:0] st;
reg [9:0] send_cnt;
reg [31:0] sdram_addr;
reg sd_card_error;
reg cmd_type_error;
reg [31:0] sd_addr;
reg [15:0] resp_data_length;
reg [15:0] resp_cmd;
reg [9:0] recv_cnt;
reg [9:0] read_len;
reg read_done;
reg [9:0] ram_wraddr;
reg [9:0] ram_rdaddr;
reg [7:0] max_burst_c;
reg [4:0] low_burst_c;
reg [7:0] header;
reg [7:0] packt_seq1;
reg [7:0] packt_seq2;

wire [7:0] doB_rdb;
wire [31:0] doB_db;
reg [31:0] diA_rdb;
reg [7:0] diA_db;
reg uart_data_timeout_error;
reg devno_error;
reg devid_error;
reg footer_error;
reg [7:0] dev_no;
reg [7:0] dev_id;
reg datavalid;
reg data_length_error;
reg cmd_error;
reg [15:0] data_length;
reg [7:0] data;
reg crc_error;
reg data_error;
reg [7:0] crc_calculated;
wire [7:0] crc_b;
reg [7:0] crc_a;
reg [7:0] crc;
reg [15:0] cmd;
reg [7:0] cmd_type;
reg [7:0] cmd_status;
reg [7:0] burst_count;
reg [7:0] addr_count;
reg [8:0] addrB_rdb;
reg [6:0] addrB_db;
reg [6:0] addrA_rdb;
reg [8:0] addrA_db;
wire [31:0] SPI_INIT_VALUES_5;
wire [31:0] SPI_INIT_VALUES_4;
wire [31:0] SPI_INIT_VALUES_3;
wire [31:0] SPI_INIT_VALUES_2;
wire [31:0] SPI_INIT_VALUES_1;
wire [7:0] ADV_REG_VALUES_9;
wire [7:0] ADV_REG_VALUES_8;
wire [7:0] ADV_REG_VALUES_7;
wire [7:0] ADV_REG_VALUES_6;
wire [7:0] ADV_REG_VALUES_5;
wire [7:0] ADV_REG_VALUES_4;
wire [7:0] ADV_REG_VALUES_3;
wire [7:0] ADV_REG_VALUES_2;
wire [7:0] ADV_REG_VALUES_1;
wire [7:0] ADV_REG_ADDRESS_9;
wire [7:0] ADV_REG_ADDRESS_8;
wire [7:0] ADV_REG_ADDRESS_7;
wire [7:0] ADV_REG_ADDRESS_6;
wire [7:0] ADV_REG_ADDRESS_5;
wire [7:0] ADV_REG_ADDRESS_4;
wire [7:0] ADV_REG_ADDRESS_3;
wire [7:0] ADV_REG_ADDRESS_2;
wire [7:0] ADV_REG_ADDRESS_1;
//reg [7:0] ADV_DEV_ADDRESS;
//reg [15:0] ADV_REG_CNT;
//reg [15:0] ADV_REG_WR_CNT;


////////////////// ICM ////////////////////////////////////////////

localparam [7:0] ICM_DEV_ADDRESS     = 8'h68;
localparam [7:0] MAGNETO_DEV_ADDRESS = 8'h0C;
localparam [7:0] ACCEL_DEV_ADDRESS   = 8'h68;
reg [15:0] icm_param_rd_time_cnt ;
reg        icm_gauge_init_done;
(* mark_debug = "true" *)reg        icm_init_done;
(* mark_debug = "true" *)reg        icm_param_initial_rd_done;
(* mark_debug = "true" *)reg        icm_param_rd_en;
(* mark_debug = "true" *)reg        icm_param_rd_en_latch;
(* mark_debug = "true" *)reg        icm_param_rd_done;
(* mark_debug = "true" *)reg [7:0]  icm_reg_addr;
(* mark_debug = "true" *)reg [7:0]  icm_i2c_dev_addr;
(* mark_debug = "true" *)reg [7:0]  icm_reg_data;

/////////////////////////////////////////////////////////////////////



reg [31:0] dpram_asym_1_readB;
reg [7:0] dpram_asym_2_readB;
reg [7:0] dpram_asym_1_mem [0:512-1];
reg [7:0] dpram_asym_2_mem [0:512-1];


reg [31:0] qspi_addr;
(* mark_debug = "true" *)reg [31:0] qspi_trans_len;
reg  qspi_erase_enable;
reg  qspi_erase_64KB_enable;
reg  qspi_erase_32KB_enable;
(* mark_debug = "true" *)reg  qspi_erase_4KB_enable;


                  
//localparam [31:0] QSPI_ADDR_IMG_COLD  = 32'h03700000, 
//                  QSPI_ADDR_IMG_HOT   = 32'h03796000;                 
                  
localparam [6:0] r_idle                   = 7'd0,
                 r_get_data               = 7'd1,
                 r_get_data2              = 7'd2,
                 r_take_action            = 7'd3,
                 r_take_action2           = 7'd4,
                 r_take_action3           = 7'd5,
                 r_response_packet        = 7'd6,
                 r_send_packet            = 7'd7,
                 r_send_packet2           = 7'd8,
                 r_send_packet3           = 7'd9,
                 r_send_packet4           = 7'd10,
                 r_send_failure           = 7'd11,
                 r_send_success           = 7'd12,
                 r_i2c_set_cmd1           = 7'd13,
                 r_i2c_set_cmd2           = 7'd14,
                 r_i2c_set_cmd3           = 7'd15,
                 r_i2c_get_cmd1           = 7'd16,
                 r_i2c_get_cmd2           = 7'd17,
                 r_sd_write1              = 7'd18,
                 r_sd_write2              = 7'd19,
                 r_sd_read1               = 7'd20,
                 r_sd_read2               = 7'd21,
                 r_wait                   = 7'd22,
                 r_ping1                  = 7'd23,
                 r_ping2                  = 7'd24,
                 r_init                   = 7'd25,
//                 r_adv_init               = 7'd26,
//                 r_adv_init2              = 7'd27,
//                 r_sensor_init            = 7'd28,
//                 r_sensor_init2           = 7'd29,
                 r_adv_reset              = 7'd26,
                 r_sensor_i2c_set_cmd1    = 7'd27,
                 r_sensor_i2c_set_cmd2    = 7'd28,
                 r_sensor_i2c_set_cmd3    = 7'd29,
                 r_sensor_i2c_get_cmd1    = 7'd30,
                 r_sensor_i2c_get_cmd2    = 7'd31,
                 r_sdram_write1           = 7'd32,
                 r_sdram_write2           = 7'd33,
                 r_sdram_write3           = 7'd34,
                 r_qspi_rd                = 7'd35, 
                 r_qspi_rd1               = 7'd36,
                 r_qspi_rd_init           = 7'd37,
                 r_qspi_rd_init1          = 7'd38,
                 r_qspi_rd_init2          = 7'd39,
                 r_qspi_cmd_decode        = 7'd40,
                 r_qspi_erase             = 7'd41,
                 r_qspi_erase1            = 7'd42,
                 r_qspi_trans1            = 7'd43,
                 r_qspi_trans2            = 7'd44,
                 r_qspi_trans3            = 7'd45,
                 r_qspi_trans4            = 7'd46,
                 r_qspi_trans5            = 7'd47,
                 r_qspi_trans6            = 7'd48,
                 r_qspi_rd_temperature    = 7'd49,
                 r_qspi_rd1_temperature   = 7'd50,
                 r_qspi_rd_mux            = 7'd51,
                 r_qspi_rd1_mux           = 7'd52,
                 r_reticle_logo_write     = 7'd53,
                 r_adv_oled_init          = 7'd54,
                 r_adv_oled_init2         = 7'd55,
                 r_oled_gamma_write       = 7'd56,
                 r_oled_gamma_write1      = 7'd57,
                 r_qspi_rd_sensor_init    = 7'd58,
                 r_qspi_rd1_sensor_init   = 7'd59,
                 r_qspi_rd_user_settings  = 7'd60,
                 r_qspi_rd1_user_settings = 7'd61,
                 r_qspi_rd_prdct_name     = 7'd62,
                 r_qspi_rd1_prdct_name    = 7'd63,
                 r_oled_cf_write          = 7'd64,
                 r_oled_cf_write1         = 7'd65,
                 r_oled_vgn_gamma_write   = 7'd66,
                 r_adv_init               = 7'd67,
                 r_adv_init2              = 7'd68,
                 r_take_snapshot1         = 7'd69,
                 r_take_snapshot2         = 7'd70,
                 r_icm_init               = 7'd71,
                 r_icm_init2              = 7'd72;
                 
                 
localparam [5:0]  r_sdram_to_qspi_data_transfer  = 6'd0,
                  r_qspi_erase_start             = 6'd1,
                  r_qspi_64KB_erase_start        = 6'd2, 
                  r_qspi_64KB_erase_done         = 6'd3,
                  r_qspi_32KB_erase_start        = 6'd4, 
                  r_qspi_32KB_erase_done         = 6'd5,  
                  r_qspi_4KB_erase_start         = 6'd6, 
                  r_qspi_4KB_erase_done          = 6'd7,                                
                  r_qspi_sector_erase_done       = 6'd8,
                  r_qspi_page_wr_start           = 6'd9,
                  r_qspi_page_wr_done            = 6'd10,
                  r_qspi_sdram_trans_idle        = 6'd11,
                  r_sdram_read1                  = 6'd12,
                  r_sdram_read2                  = 6'd13,
                  r_sdram_rd_rq                  = 6'd14,
                  r_qspi_wr                      = 6'd15,
                  r_qspi_to_sdram_data_transfer  = 6'd16,
                  r_qspi_rd_data_transfer        = 6'd17,
                  r_qspi_rd1_data_transfer       = 6'd18,
                  r_sdram_write1_data_transfer   = 6'd19,
                  r_sdram_write2_data_transfer   = 6'd20,
                  r_sdram_write3_data_transfer   = 6'd21,
                  r_qspi_erase_block_cal1        = 6'd22,
                  r_qspi_erase_block_cal2        = 6'd23,
                  r_qspi_check_64k_boundary      = 6'd24,
                  r_qspi_check_32k_boundary      = 6'd25,
                  r_qspi_check_4k_boundary       = 6'd26,
                  r_qspi_calc_64k_block_start    = 6'd27,
                  r_qspi_calc_32k_block_end      = 6'd28,
                  r_qspi_calc_4k_block_end       = 6'd29,
                  r_qspi_calc_32k_block_start    = 6'd30,
                  r_qspi_calc_64k_block_end      = 6'd31,
                  r_qspi_calc_4k_block_start     = 6'd32,
                  r_qspi_erase_wait              = 6'd33,
                  r_qspi_rd_user_settings_wr     = 6'd34,
                  r_qspi_rd1_user_settings_wr    = 6'd35,
                  r_user_settings_rd_rq          = 6'd36,
                  r_user_settings_rd_wait        = 6'd37,
                  r_user_settings_rd_data        = 6'd38,
                  r_qspi_to_bram_rd1_reticle     = 6'd39,
                  r_qspi_to_bram_rd_reticle      = 6'd40,
                  r_qspi_to_bram_reticle_write   = 6'd41;                  

localparam [4:0]  r_qspi_temperature_page_wr_idle = 5'd0,
                  r_qspi_temperature_page_wr_start= 5'd1,
                  r_qspi_temperature_page_wr_done = 5'd2,
                  r_temperature_rd1               = 5'd3,
                  r_temperature_rd2               = 5'd4,
                  r_qspi_temperature_wr           = 5'd5,
                  r_qspi_temperature_page_erase_wait = 5'd6;

reg [4:0]  qspi_temperature_wr_st; 
reg        qspi_temperature_wr_enable;
reg        qspi_temperature_wr_enable_d;

reg [8:0]  temperature_rd_byte_cnt;
reg [15:0] temperature_rd_data_temp;


localparam [4:0]  r_qspi_sensor_init_page_wr_idle = 5'd0,
                  r_qspi_sensor_init_page_wr_start= 5'd1,
                  r_qspi_sensor_init_page_wr_done = 5'd2,
                  r_sensor_init_gfid_update       = 5'd3,
                  r_sensor_init_gsk_update        = 5'd4,
                  r_sensor_init_gsk_update1       = 5'd5,
                  r_sensor_init_int_time_update   = 5'd6,
                  r_sensor_init_int_time_update1  = 5'd7,
                  r_sensor_init_gain_update       = 5'd8,
                  r_sensor_init_rd1               = 5'd9,
                  r_sensor_init_rd2               = 5'd10,
                  r_sensor_init_rd3               = 5'd11,
                  r_qspi_sensor_init_wr           = 5'd12,
                  r_qspi_sensor_init_page_erase_wait =5'd13;

reg [4:0]  qspi_sensor_init_wr_st; 
reg        qspi_sensor_init_wr_enable;

reg [8:0]  sensor_init_rd_byte_cnt;
reg [31:0] sensor_init_rd_data_temp;
//(* mark_debug = "true" *)reg        low_high_sel;
reg [2:0]  sel_temp_range;

reg       [15:0] sector_erase_cnt;
reg       [31:0] page_wr_cnt;
reg       [5:0]  qspi_sdram_trans_st;
reg       [5:0]  qspi_sdram_trans_st_next;
reg              qspi_sdram_trans_enable;
reg              rd_qspi_wr_sdram_enable;
reg       [31:0] qspi_erase_start_addr;
reg       [31:0] qspi_erase_end_addr;
reg       [15:0] number_of_erase_block;

//(* mark_debug = "true" *)reg [7:0] erase_cnt  = 8'd0;


//assign SPI_INIT_VALUES_4 = 32'h3305;
//assign SPI_INIT_VALUES_3 = 32'h28ff;
//assign SPI_INIT_VALUES_2 = 32'h1132;
//assign SPI_INIT_VALUES_1 = 32'h4191;
//assign SPI_INIT_VALUES_5 = 32'h5003;
//assign ADV_REG_VALUES_9  = 8'h00;
//assign ADV_REG_VALUES_8  = 8'h2A;
//assign ADV_REG_VALUES_7  = 8'h09;
//assign ADV_REG_VALUES_6  = 8'h8A;
//assign ADV_REG_VALUES_5  = 8'hCB;
//assign ADV_REG_VALUES_4  = 8'hC3;
//assign ADV_REG_VALUES_3  = 8'h11;
//assign ADV_REG_VALUES_2  = 8'h00;
//assign ADV_REG_VALUES_1  = 8'h1E;
//assign ADV_REG_ADDRESS_9 = 8'h88;
//assign ADV_REG_ADDRESS_8 = 8'h8F;
//assign ADV_REG_ADDRESS_7 = 8'h8E;
//assign ADV_REG_ADDRESS_6 = 8'h8D;
//assign ADV_REG_ADDRESS_5 = 8'h8C;
//assign ADV_REG_ADDRESS_4 = 8'h82;
//assign ADV_REG_ADDRESS_3 = 8'h80;
//assign ADV_REG_ADDRESS_2 = 8'h01;
//assign ADV_REG_ADDRESS_1 = 8'h00;
//assign ADV_DEV_ADDRESS   = 8'h2A;//8'd42;




reg [31:0] sdram_send_adddr;
reg [31:0] dest_address;
(* mark_debug = "true" *)reg [31:0] dest_address_d;
reg [31:0] src_address;
(* mark_debug = "true" *)reg [31:0] src_address_d;
reg [31:0] data_trans_len;
(* mark_debug = "true" *)reg [31:0] data_trans_len_d;
reg [15:0] c_cmd;
//(* mark_debug = "true" *)reg qspi_init_cmd_done;
reg gain_wr_done;
///////////// QSPI /////////////////////////////////


reg       [31:0] qspi_init_st_addr_reg;


          
          
localparam [4:0] qspi_idle_st          = 5'd0,
                qspi_wait_st          = 5'd1, 
                qspi_wren_st          = 5'd2,
                qspi_rdsr_cmd_st      = 5'd3,
                qspi_rdsr_data_st     = 5'd4,
                qspi_sector_erase_st  = 5'd5,
                qspi_reg_wr_cmd_st    = 5'd6,
                qspi_page_wr_cmd_st   = 5'd7,
                qspi_page_wr_data_st  = 5'd8,
                qspi_mem_rd_cmd_st    = 5'd9,
                qspi_mem_rd_data_st   = 5'd10,
//                qspi_rd_wr_done_st    = 5'd11,
                qspi_error_st         = 5'd12;



reg [QSPI_ADDR_WIDTH-1:0] qspi_send_addr;
reg [QSPI_CMD_WIDTH-1:0]  qspi_send_sector_erase_cmd;

reg [QSPI_CMD_WIDTH-1:0]  qspi_send_cmd;
reg [QSPI_DATA_WIDTH-1:0] qspi_send_data;       
reg [8:0]                 qspi_send_rd_size;
reg                       qspi_send_busy; 
reg                       qspi_page_wr_rq;
reg                       qspi_mem_rd_rq;
reg                       qspi_sector_erase_rq;
reg                       qspi_reg_wr_rq;

reg        STARTUPE2_clk_stop;                          
/*(* mark_debug = "true" *)*/reg [4:0]  qspi_state_temp;
/*(* mark_debug = "true" *)*/reg [4:0]  qspi_state;

reg [7:0]  qspi_wr_data;
reg        qspi_wr_data_valid;
reg [8:0]  sdram_write_byte_cnt;
reg [31:0] sdram_write_addr;
reg [31:0] sdram_write_data; 
reg [31:0] sdram_read_addr;
reg [31:0] sdram_read_data; 
reg [8:0]  sdram_read_byte_cnt;
reg [3:0]  qspi_wr_cnt;
reg [3:0]  qspi_rd_cnt;
reg [31:0] temp_qspi_write_cnt;
reg [31:0] temp_qspi_read_cnt;


reg  [QSPI_DATA_WIDTH-1:0] write_data;
reg  [QSPI_DATA_WIDTH-1:0] qspi_read_data;
wire [QSPI_DATA_WIDTH-1:0] qspi_rx_rd_fifo_data;
reg  [QSPI_ADDR_WIDTH-1:0] qspi_read_addr;
reg  [QSPI_ADDR_WIDTH-1:0] qspi_write_addr; 
reg  [QSPI_ADDR_WIDTH-1:0] qspi_sector_erase_addr;                
reg  [QSPI_CMD_WIDTH-1:0]  qspi_cmd;
reg  [QSPI_ADDR_WIDTH-1:0] qspi_address;
reg  [QSPI_DATA_WIDTH-1:0] qspi_data_in;
reg  [QSPI_DATA_WIDTH-1:0] qspi_rx_wr_data_word;
wire [QSPI_DATA_WIDTH-1:0] data_out;
wire [QSPI_DATA_WIDTH-1:0] qspi_read_data_out;
reg  [QSPI_CMD_WIDTH-1:0]  qspi_reg_wr_cmd;
reg  [QSPI_DATA_WIDTH-1:0] qspi_reg_wr_data;
reg  [QSPI_CMD_WIDTH-1:0]  qspi_mem_rd_cmd;
reg  [QSPI_CMD_WIDTH-1:0]  qspi_sector_erase_cmd;


reg         write_data_valid;
reg         read_sdram_data_rq;
reg         write_sdram_data_rq;
reg         qspi_read_data_valid;
reg         qspi_rx_rd_fifo_rq;
reg         qspi_wr_en_error;
reg         qspi_trigger;   
reg         qspi_input_valid;
reg         qspi_input_data_valid;
reg  [8:0]  qspi_rd_size;
reg  [8:0]  qspi_wr_data_cnt;
reg         qspi_rx_rd_fifo_clr;
reg         qspi_rx_wr_wrreq_sig;
wire        qspi_busy;
wire        qspi_error;
wire [8:0]  read_data_count;
wire        qspi_read_data_out_valid;
wire        qspi_init_done;
wire        qspi_wr_enable_error;
wire        qspi_wr_vecr_error;
wire        qspi_wr_disable_error;
wire        qspi_rx_rd_fifo_empty;
wire        qspi_rx_rd_fifo_full;
wire [7:0]  qspi_rx_rfbufffilled;
wire        qspi_rx_rd_fifo_almostfull;

/////////// SENSOR SPI INIT ///////////////////

localparam [4:0] SENSOR_idle           = 5'b00000,
                 SENSOR_st_wait        = 5'b00001,
                 SENSOR_st_update      = 5'b00010,
                 SENSOR_st_update1     = 5'b00011,
                 SENSOR_st_update2     = 5'b00100,
                 SENSOR_st_update3     = 5'b00101,
                 SENSOR_st_update4     = 5'b00110,
                 SENSOR_st_update5     = 5'b00111,
                 SENSOR_st_mem_rd_wait = 5'b01000,
                 SENSOR_st_wr          = 5'b01001,
                 SENSOR_st_wr1         = 5'b01010,
                 SENSOR_st_end         = 5'b01011;

reg  [6:0]  SENSOR_I2C_SLAVE_ADDRESS;     
(* mark_debug = "true" *)reg  [15:0] SENSOR_I2C_REG_ADDRESS;     
reg         SENSOR_I2C_ReadEN;       
reg         SENSOR_I2C_WriteEN;    
(* mark_debug = "true" *)reg  [7:0]  SENSOR_I2C_WriteData;        
wire        SENSOR_I2C_Busy;      
wire [7:0]  SENSOR_I2C_ReadData;     
wire        SENSOR_I2C_ReadDAV;    
wire [3:0]  SENSOR_state_o;

//wire        SPI_WriteEN;    
//wire [31:0] SPI_WriteData;  
//wire [7:0]  SPI_ADDRESS;       
//wire        SPI_ReadEN;
//wire [31:0] SPI_ReadData;   
//wire        SPI_WaitReq;   
//wire        SPI_ReadDAV;   

wire  [6:0] SENSOR_I2C_SLAVE_ADDRESS_m;     
wire  [15:0]SENSOR_I2C_REG_ADDRESS_m;     
wire        SENSOR_I2C_ReadEN_m;       
wire        SENSOR_I2C_WriteEN_m;    
wire  [7:0] SENSOR_I2C_WriteData_m;        
wire        SENSOR_I2C_Busy_m;      
wire [7:0]  SENSOR_I2C_ReadData_m;     
wire        SENSOR_I2C_ReadDAV_m;  

(* mark_debug = "true" *)reg  [4:0]  SENSOR_st_temp;
(* mark_debug = "true" *)reg  [4:0]  SENSOR_st;

localparam [6:0] SENSOR_I2C_PHYS_ADDR =7'b0010010; 

reg init_done;
(* mark_debug = "true" *)input            update_sensor_param;
(* mark_debug = "true" *)reg              update_sensor_param_latch;
output reg sensor_power_on_init_done;
input      [5:0] new_sensor_param_start_addr;
(* mark_debug = "true" *)output reg [5:0] sensor_init_data_len;
//reg update_gfid_gsk;
//reg [5:0] new_gfid_gsk_start_addr;

reg update_sensor_init;

reg  sensor_init_rd_done;
wire sensor_init_mem_wr_req_mux;             
wire sensor_init_mem_rd_req_mux;              
wire [5:0]   sensor_init_mem_wr_addr_mux;     
wire [5:0]   sensor_init_mem_rd_addr_mux;     
wire [31:0]  sensor_init_mem_wr_data_mux;
wire [31:0]  sensor_init_mem_rd_data_mux;


reg sensor_init_mem_wr_req1;              
reg sensor_init_mem_rd_req1;              
reg [5:0]   sensor_init_mem_wr_addr1;     
reg [5:0]   sensor_init_mem_rd_addr1;     
reg [31:0]  sensor_init_mem_wr_data1;
wire [31:0] sensor_init_mem_rd_data1;
reg [5:0]   sensor_init_mem_rd_addr_temp1;


reg sensor_init_mem_wr_req;
(* mark_debug = "true" *)reg sensor_init_mem_rd_req;
reg [5:0]   sensor_init_mem_wr_addr;
reg [5:0]   sensor_init_mem_wr_addr_temp;
(* mark_debug = "true" *)reg [5:0]   sensor_init_mem_rd_addr;
(* mark_debug = "true" *)reg [5:0]   sensor_init_mem_rd_addr_temp;
reg [31:0]  sensor_init_write_data_temp;
reg [31:0]  sensor_init_mem_wr_data;
(* mark_debug = "true" *)wire [31:0]  sensor_init_mem_rd_data;
//(* mark_debug = "true" *)reg [31:0]  sensor_init_mem_rd_data_d;

reg sensor_init_mem_write_en;
reg [3:0]sensor_init_mem_write_cnt;



//////////////////////////////////////////////////////////

///////////// MARK-UNMARK BAD PIX ///////////////////////
reg mark_bp_en;
reg unmark_bp_en;
reg [3:0] mark_bp_st;
reg [2:0] gain_tb_sel_cnt;
reg [PIX_BITS -1 : 0] latch_reticle_pos_x;
reg [LIN_BITS -1 : 0] latch_reticle_pos_y;
reg [31:0] gain_addr_offset;
reg [31:0] gain_tb_addr;
reg mark_bp_error;
reg unmark_bp_error;

reg time_cnt_Start;
reg [31:0] time_cnt;

localparam [3:0] r_mark_bp_idle             =4'd0,
                 r_mark_bp_addr_offset_calc =4'd1,
                 r_mark_bp_addr_calc        =4'd2,
                 r_mark_bp_addr_latch       =4'd3,
                 r_mark_bp_sdram_read       =4'd4,
                 r_mark_bp_sdram_read1      =4'd5,
                 r_mark_bp_sdram_write1     =4'd6,
                 r_mark_bp_sdram_write2     =4'd7,
                 r_mark_bp_data             =4'd8;


////////////////////////////////////////////////////////

///// SVAE USER SETTINGS //////////////////////////////
reg save_user_settings_en;
reg switch_to_factory_settings_en;
reg switch_to_factory_settings_en_d;             
                                         
wire user_settings_mem_wr_req_mux;         
wire user_settings_mem_rd_req_mux;         
wire [7:0]   user_settings_mem_wr_addr_mux;
wire [7:0]   user_settings_mem_rd_addr_mux;
wire [31:0]  user_settings_mem_wr_data_mux;
wire [31:0]  user_settings_mem_rd_data_mux;

reg user_settings_mem_wr_req1;
reg user_settings_mem_rd_req1;
reg [7:0]   user_settings_mem_wr_addr1;
reg [7:0]   user_settings_mem_wr_addr_temp1;
reg [31:0]  user_settings_mem_wr_data1;
wire[31:0]  user_settings_mem_rd_data1;
reg [31:0]  user_settings_mem_rd_data1_temp;
reg [7:0]   user_settings_mem_rd_addr1;
reg [7:0]   user_settings_mem_rd_addr_temp1;

reg qspi_user_settings_trans_en;
reg user_settings_mux_sel;
reg load_user_settings_en;
reg load_factory_settings_en;

///////////////////////////////////////////////////////

/////// INITIAL LOGO  ////////////////////////////////

reg [4:0]logo_frame_wr_cnt ;

//////////////////////////////////////////////////////

////////////////// ADV OLED LOGO RETICLE QSPI RD //////////////////////////
reg [31:0] MUX_WR_DATA ;
//////////////////////////////////////////////////////

///////////////// ADV,OLED, VGN ADC, BATTERY GAUGE INIT //////////////////////////
reg [7:0]  OLED_CATHODE_VOLTAGE_DEV_ADDR;
reg [7:0]  ADV_OLED_DEV_ADDR;
reg [15:0] ADV_OLED_REG_CNT;
reg [15:0] ADV_OLED_REG_WR_CNT;
(* mark_debug = "true" *)reg [15:0] OLED_REG_CNT;
(* mark_debug = "true" *)reg [15:0] OLED_REG_WR_CNT;

///////////////////////////////////////////////////////

////////////// ADV INIT MEMORY ///////////////////////
(* mark_debug = "true" *)reg         adv_pal_init_mem_wr_req;
(* mark_debug = "true" *)reg         adv_pal_init_mem_rd_req;
(* mark_debug = "true" *)reg  [5:0]  adv_pal_init_mem_wr_addr;
(* mark_debug = "true" *)reg  [31:0] adv_pal_init_mem_wr_data;
(* mark_debug = "true" *)wire [31:0] adv_pal_init_mem_rd_data;
(* mark_debug = "true" *)reg  [5:0]  adv_pal_init_mem_rd_addr;
(* mark_debug = "true" *)reg         adv_ntsc_init_mem_wr_req; 
(* mark_debug = "true" *)reg         adv_ntsc_init_mem_rd_req; 
(* mark_debug = "true" *)reg  [5:0]  adv_ntsc_init_mem_wr_addr;
(* mark_debug = "true" *)reg  [31:0] adv_ntsc_init_mem_wr_data;
(* mark_debug = "true" *)wire [31:0] adv_ntsc_init_mem_rd_data;
(* mark_debug = "true" *)reg  [5:0]  adv_ntsc_init_mem_rd_addr;
(* mark_debug = "true" *)reg  [5:0]  adv_init_mem_rd_addr_temp;
(* mark_debug = "true" *)reg  [5:0]  adv_init_mem_wr_addr_temp;
(* mark_debug = "true" *)reg  [2:0]  st_adv_init;
(* mark_debug = "true" *)reg  [15:0] ADV_REG_CNT;
(* mark_debug = "true" *)reg  [15:0] ADV_REG_WR_CNT;
(* mark_debug = "true" *)reg         pal_ntsc_sel_d;
(* mark_debug = "true" *)wire        pal_ntsc_sel_pos_edge;
(* mark_debug = "true" *)wire        pal_ntsc_sel_neg_edge;
(* mark_debug = "true" *)reg         adv_init_done;

localparam [2:0]  r_adv_init_idle         = 3'd0,
                  r_adv_init_wait         = 3'd1,
                  r_adv_init_rd           = 3'd2,
                  r_adv_init_rd_wait      = 3'd3,
                  r_adv_init_wr_i2c       = 3'd4,
                  r_adv_init_wr_i2c_wait  = 3'd5;
                  

//////////////////////////////////////////////////////

//// OLED REG REINIT //////////////////////////////////////
  
localparam [3:0]  r_oled_reinit_idle                  = 4'd0,
                  r_oled_reset                        = 4'd1,
                  r_oled_power_off                    = 4'd2, 
                  r_oled_reinit_wait                  = 4'd3,
                  r_oled_reinit_rd_rq                 = 4'd4,
                  r_oled_reinit_rd_wait               = 4'd5,
                  r_oled_reinit_i2c_write             = 4'd6,
                  r_oled_reinit_i2c_write_wait        = 4'd7,
                  r_adv_sleep_mode_en_i2c_write       = 4'd8,
                  r_adv_sleep_mode_en_i2c_write_wait  = 4'd9,
                  r_adv_sleep_mode_dis_i2c_write      = 4'd10,
                  r_adv_sleep_mode_dis_i2c_write_wait = 4'd11;

///////////////////////////////////////////////////////////

///////////// OLED REG MEMORY READ WRITE  AND BATTERY PARAM READ ////////////////

localparam [4:0]  r_qspi_oled_init_wr_idle         = 5'd0,
                  r_qspi_oled_init_wr_idle1        = 5'd1,
                  r_qspi_oled_init_page_wr_start   = 5'd2,
                  r_qspi_oled_init_page_wr_done    = 5'd3,
                  r_oled_init_rd1                  = 5'd4,
                  r_oled_init_rd2                  = 5'd5,
                  r_oled_init_rd3                  = 5'd6,
                  r_qspi_oled_init_wr              = 5'd7,
                  r_qspi_oled_init_page_erase_wait = 5'd8;


localparam [6:0]  oled_gamma_tb_calc_idle       = 7'd0,
                  gl_read                       = 7'd1,
                  gl_read_wait                  = 7'd2,
                  gl_write                      = 7'd3,
                  gc_read                       = 7'd4,
                  gc_read_wait                  = 7'd5,
                  gc_write                      = 7'd6,
                  gamma_tb_calc_start           = 7'd7,   
                  gamma_tb_calc_index_sel       = 7'd8,
                  gamma_tb_calc_mul             = 7'd9,
                  gamma_tb_calc_div_start       = 7'd10,
                  gamma_tb_calc_div_done        = 7'd11,
                  gamma_tb_mem_write            = 7'd12,
                  oled_gamma_tb_calc_wait       = 7'd13,
                  oled_gamma_tb_read            = 7'd14,
                  oled_gamma_tb_r_lut_addr_write  = 7'd15,
                  oled_gamma_tb_r_lut_datah_write = 7'd16,
                  oled_gamma_tb_r_lut_datal_write = 7'd17,
                  oled_gamma_tb_g_lut_addr_write  = 7'd18,
                  oled_gamma_tb_g_lut_datah_write = 7'd19,
                  oled_gamma_tb_g_lut_datal_write = 7'd20,
                  oled_gamma_tb_b_lut_addr_write  = 7'd21,
                  oled_gamma_tb_b_lut_datah_write = 7'd22,
                  oled_gamma_tb_b_lut_datal_write = 7'd23,                  
                  oled_gamma_tb_i2c_write       = 7'd24,
                  oled_gamma_tb_i2c_write_wait  = 7'd25,                            
                  oled_lut_update1              = 7'd26,
                  oled_lut_update2              = 7'd27,
                  oled_lut_update3              = 7'd28,
                  oled_reg_update_done          = 7'd29,
                  oled_vgn_gc_coeff_calc        = 7'd30, 
//                  oled_gammaset_write           = 6'd31,
//                  oled_gammaset_wait            = 6'd32,
//                  oled_vgn_adc_rd               = 6'd33,
//                  oled_vgn_adc_rd_wait          = 6'd34,
//                  oled_vgn_cf_gamma_rd          = 6'd35, 
//                  oled_vgn_cf_gamma_rd_wait     = 6'd36,
//                  oled_vgn_cf_gamma_rd_done     = 6'd37,  
//                  oled_vgn_gamma_div            = 6'd38, 
//                  oled_vgn_gamma_div_done       = 6'd39, 
//                  oled_vgn_gc_calc              = 6'd40, 
//                  oled_vgn_gc_calc_done         = 6'd41,
                  bat_param_rd                  = 7'd31,
                  bat_control_rd                = 7'd32,
                  bat_status_rd                 = 7'd33,
                  bat_voltagem_rd               = 7'd34,
                  bat_voltagel_rd               = 7'd35,
                  bat_acc_chargem_rd            = 7'd36,
                  bat_acc_chargel_rd            = 7'd37,
                  bat_tempm_rd                  = 7'd38,
                  bat_templ_rd                  = 7'd39,
                  bat_i2c_rd                    = 7'd40,
                  bat_i2c_rd_wait               = 7'd41,
                  shutter_operation_wait        = 7'd42,
                  shutter_close                 = 7'd43,
                  shutter_open                  = 7'd44,
                  shutter_i2c_write             = 7'd45,
                  shutter_i2c_write_wait        = 7'd46, 
                  shutter_i2c_write_again       = 7'd47,
                  nuc1pt_start_st               = 7'd48,
                  nuc1pt_wait_st                = 7'd49,  
                  nuc1pt_done_st                = 7'd50,
                  icm_param_rd                  = 7'd51,
                  icm_magneto_status_start_rd   = 7'd52,
                  icm_magneto_x_msb_rd          = 7'd53,
                  icm_magneto_x_lsb_rd          = 7'd54,
                  icm_magneto_y_msb_rd          = 7'd55,
                  icm_magneto_y_lsb_rd          = 7'd56,
                  icm_magneto_z_msb_rd          = 7'd57,
                  icm_magneto_z_lsb_rd          = 7'd58,
                  icm_magneto_status_stop_rd    = 7'd59,
                  icm_accel_x_msb_rd            = 7'd60,
                  icm_accel_x_lsb_rd            = 7'd61,
                  icm_accel_y_msb_rd            = 7'd62,
                  icm_accel_y_lsb_rd            = 7'd63,
                  icm_accel_z_msb_rd            = 7'd64,
                  icm_accel_z_lsb_rd            = 7'd65,                  
                  icm_i2c_rd                    = 7'd66,
                  icm_i2c_rd_wait               = 7'd67,
                  icm_magneto_rd_wait           = 7'd68,
                  oled_video_on                 = 7'd69;

(* mark_debug = "true" *)reg shutter_enable_latch = 1'b0;
(* mark_debug = "true" *)reg [15:0] shutter_i2c_write_again_wait_counter;
reg [7:0] nuc1pt_start_time_cnt;

localparam [2:0]  oled_reg_update_idle    = 3'd0, 
                  oled_reg_update_wait    = 3'd1,
                  oled_reg_i2c_write      = 3'd2,
                  oled_reg_i2c_write_wait = 3'd3,
                  oled_reg_i2c_write_done = 3'd4;

(* mark_debug = "true" *)reg [3:0] st_oled_reinit;
reg [2:0] st_oled_reg_update;
reg [7:0] oled_reg_data1;
reg [7:0] oled_reg_addr1;
(* mark_debug = "true" *)reg       oled_reinit_start;
(* mark_debug = "true" *)reg       oled_standby_process_busy;


reg OLED_POS_V_VALID_LATCH;     
reg OLED_POS_H_VALID_LATCH;     
reg OLED_BRIGHTNESS_VALID_LATCH;
reg OLED_CONTRAST_VALID_LATCH;  
reg OLED_IDRF_VALID_LATCH;      
reg OLED_DIMCTL_VALID_LATCH; 
reg OLED_IMG_FLIP_VALID_LATCH;
reg OLED_CATHODE_VOLTAGE_VALID_LATCH;
reg OLED_ROW_START_MSB_VALID_LATCH;
reg OLED_ROW_START_LSB_VALID_LATCH;
reg OLED_ROW_END_MSB_VALID_LATCH  ;
reg OLED_ROW_END_LSB_VALID_LATCH  ;


  
reg OLED_POS_V_VALID_LATCH_DONE;     
reg OLED_POS_H_VALID_LATCH_DONE;    // RGTPOS_MSB  
reg OLED_BRIGHTNESS_VALID_LATCH_DONE;
reg OLED_CONTRAST_VALID_LATCH_DONE;  
reg OLED_IDRF_VALID_LATCH_DONE;      
reg OLED_DIMCTL_VALID_LATCH_DONE;   
reg OLED_IMG_FLIP_VALID_LATCH_DONE;
reg OLED_CATHODE_VOLTAGE_VALID_LATCH_DONE;
reg OLED_ROW_START_MSB_VALID_LATCH_DONE;
reg OLED_ROW_START_LSB_VALID_LATCH_DONE;
reg OLED_ROW_END_MSB_VALID_LATCH_DONE  ;
reg OLED_ROW_END_LSB_VALID_LATCH_DONE  ;
reg OLED_POS_BOTPOS_WR_EN_LATCH_DONE;
reg OLED_POS_LFTPOS_WR_EN_LATCH_DONE;  
reg OLED_POS_LFTPOS_MSB_WR_EN_LATCH_DONE;
reg OLED_POS_RGTPOS_WR_EN_LATCH_DONE;


reg oled_cathode_voltage_dev_sel;
reg oled_vgn_bat_i2c_busy;  
reg oled_vgn_bat_shutter_process_busy;
                   
(* mark_debug = "true" *)reg         oled_init_mem_wr_req;
(* mark_debug = "true" *)reg         oled_init_mem_rd_req;
(* mark_debug = "true" *)reg  [7:0]  oled_init_mem_wr_addr;
(* mark_debug = "true" *)reg  [7:0]  oled_init_mem_wr_addr_temp;
(* mark_debug = "true" *)reg  [31:0] oled_init_mem_wr_data;
(* mark_debug = "true" *)wire [31:0] oled_init_mem_rd_data;
(* mark_debug = "true" *)reg  [7:0]  oled_init_mem_rd_addr;
(* mark_debug = "true" *)reg  [7:0]  oled_init_mem_rd_addr_temp;
reg         oled_init_done;
(* mark_debug = "true" *)reg  [15:0] oled_reint_wait_cnt;

(* mark_debug = "true" *)reg  [4:0]  qspi_oled_init_wr_st; 
(* mark_debug = "true" *)reg         qspi_oled_init_wr_enable;
(* mark_debug = "true" *)reg         qspi_oled_init_wr_enable_latch;
reg  [8:0]  oled_init_rd_byte_cnt;
reg  [31:0] oled_init_rd_data_temp;
reg         oled_gamma_coeff_mem_wr_req;
reg         oled_gamma_coeff_mem_rd_req;
reg  [7:0]  oled_gamma_coeff_mem_wr_addr;
reg  [7:0]  oled_gamma_coeff_mem_wr_addr_temp;
reg  [15:0] oled_gamma_coeff_mem_wr_data;
wire [15:0] oled_gamma_coeff_mem_rd_data;
reg  [7:0]  oled_gamma_coeff_mem_rd_addr;
reg  [7:0]  oled_gamma_coeff_mem_rd_addr_temp;
(* mark_debug = "true" *)reg  [6:0]  st_oled_gamma_tb_calc;
(* mark_debug = "true" *)reg  [6:0]  st_next_oled_gamma_tb_calc;
                               
reg  [9:0]  gl [0:8];
reg  [9:0]  gc [0:8];

reg  [3:0]  gl_gc_cnt;
reg         oled_gamma_table_mem_wr_req;                
reg         oled_gamma_table_mem_rd_req;                
reg  [7:0]  oled_gamma_table_mem_wr_addr;        
reg  [9:0]  oled_gamma_table_mem_wr_data;       
wire [9:0]  oled_gamma_table_mem_rd_data;       
reg  [7:0]  oled_gamma_table_mem_rd_addr;       
reg  [8:0]  oled_gamma_table_mem_rd_addr_temp;  


/////////////////// OLED VGN GAMMA  MEMORY ///////////////////////////
reg   [1:0] vgn_gamma_mem_wr_sel;
(* mark_debug = "true" *)reg   [1:0] vgn_gamma_mem_rd_sel;
reg   [9:0] oled_vgn_gamma_mem_wr_addr_temp; 

reg         oled_vgn_gamma_mem1_wr_req;                
(* mark_debug = "true" *)reg         oled_vgn_gamma_mem1_rd_req;                
reg  [ 9:0] oled_vgn_gamma_mem1_wr_addr;       
reg  [19:0] oled_vgn_gamma_mem1_wr_data;       
(* mark_debug = "true" *)wire [19:0] oled_vgn_gamma_mem1_rd_data;       
(* mark_debug = "true" *)reg  [ 9:0] oled_vgn_gamma_mem1_rd_addr;        

reg         oled_vgn_gamma_mem2_wr_req;                
(* mark_debug = "true" *)reg         oled_vgn_gamma_mem2_rd_req;                
reg  [ 9:0] oled_vgn_gamma_mem2_wr_addr;        
reg  [19:0] oled_vgn_gamma_mem2_wr_data;       
(* mark_debug = "true" *)wire [19:0] oled_vgn_gamma_mem2_rd_data;       
(* mark_debug = "true" *)reg  [ 9:0] oled_vgn_gamma_mem2_rd_addr;       

reg         oled_vgn_gamma_mem3_wr_req;                
(* mark_debug = "true" *)reg         oled_vgn_gamma_mem3_rd_req;                
reg  [ 9:0] oled_vgn_gamma_mem3_wr_addr;      
reg  [19:0] oled_vgn_gamma_mem3_wr_data;       
(* mark_debug = "true" *)wire [19:0] oled_vgn_gamma_mem3_rd_data;       
(* mark_debug = "true" *)reg  [ 9:0] oled_vgn_gamma_mem3_rd_addr;       
///////////////////////////////////////////////////////////////////////

/////////// OLED CORRECTION FACTOR (CF) MEMORY  ///
reg         oled_cf_mem_wr_req;                
(* mark_debug = "true" *)reg         oled_cf_mem_rd_req;                
reg  [7:0]  oled_cf_mem_wr_addr;  
reg  [8:0]  oled_cf_mem_wr_addr_temp;      
reg  [15:0]  oled_cf_mem_wr_data;       
(* mark_debug = "true" *)wire [15:0]  oled_cf_mem_rd_data;       
(* mark_debug = "true" *)reg  [7:0]  oled_cf_mem_rd_addr;       
//////////////////////////////////////////////////

/////////////// OLED VGN DIV////////////////////////
(* mark_debug = "true" *) reg         vgn_start_div;
reg  [31:0] vgn_dvnd;
reg  [31:0] vgn_dvsr;
(* mark_debug = "true" *) wire        vgn_done_tick;
wire [31:0] vgn_quo;

////////////////////////////////////////////////////

//////////////// OLED VGN ADC /////////////////////
reg [9:0]  vgn_adc_rd_data;
reg [7:0]  gammaset;
reg [7:0]  vgn_settle_time_cnt;
reg [15:0] vgn_rd_time_cnt ;
(* mark_debug = "true" *)reg        vgn_rd_en;
(* mark_debug = "true" *)reg        vgn_rd_en_latch;
reg        vgn_rd_done;
(* mark_debug = "true" *)reg        oled_reinit_vgn_rd_en;
/////////////////////////////////////////////////////

/////////////// VGN GC CALCULATION /////////////////

//localparam [3:0]  oled_vgn_gc_coeff_calc_idle=4'd0,
//                  oled_cf_read               =4'd1,
//                  oled_cf_read_wait          =4'd2,
//                  oled_max_vgn_gamma_rd      =4'd3,
//                  oled_max_vgn_gamma_rd_wait =4'd4,
//                  oled_vgn_gamma_rd          =4'd5,
//                  oled_vgn_gamma_rd_wait     =4'd6,
//                  oled_vgn_gamma_div         =4'd7,
//                  oled_vgn_gamma_div_done    =4'd8,
//                  oled_vgn_gc_calc           =4'd9,
//                  oled_vgn_gc_calc_done      =4'd10;

//(* mark_debug = "true" *) reg  [3:0]  st_oled_vgn_gc_coeff_calc;                  
(* mark_debug = "true" *) reg  [12:0] vgn_gamma_div;   
(* mark_debug = "true" *) reg  [19:0] max_vgn_data;
(* mark_debug = "true" *) reg  [19:0] vgn_data;
(* mark_debug = "true" *) reg  [9:0]  cf_data;  
(* mark_debug = "true" *) reg  [22:0] vgn_gc_value_temp;   
(* mark_debug = "true" *) reg  [9:0]  vgn_gc_value;           
/////////////////////////////////////////////////////

//reg vgn_gc_sel;

reg  [8:0]  val_8_bit;
reg  [3:0]  index;

reg  [17:0] gl_gc_mul;
reg  [17:0] gl_diff;

reg         start_div;
reg  [17:0] dvnd;
reg  [17:0] dvsr;
reg  [17:0] tmpval;
wire        done_tick;
wire [17:0] quo;
reg         oled_gamma_coeff_mem_wr_done;
reg  [7:0]  oled_reg_data;
reg  [7:0]  oled_reg_addr;
reg  [7:0]  OLED_GAMMA_TABLE_SEL_D;
reg  [7:0]  OLED_POS_BOTPOS_WR_DATA;
reg         OLED_POS_BOTPOS_WR_EN;
reg  [8:0]  OLED_POS_LFTPOS_WR_DATA;
reg         OLED_POS_LFTPOS_WR_EN;
reg         OLED_POS_LFTPOS_MSB_WR_EN;
reg         OLED_POS_RGTPOS_WR_EN;
reg  [7:0]  oled_init_mem_botpos_wr_data;
reg         oled_init_mem_botpos_wr_en;
reg         oled_init_mem_rgtpos_wr_en;
reg  [8:0]  oled_init_mem_lftpos_wr_data;
reg         oled_init_mem_lftpos_wr_en;
reg         oled_init_mem_lftpos_msb_wr_en;

/////////////////////////////////////////////////////////

///////////////// BATTERY GAUGE //////////////////
reg [15:0] bat_param_rd_time_cnt ;
reg        bat_gauge_init_done;
(* mark_debug = "true" *)reg        bat_param_initial_rd_done;
(* mark_debug = "true" *)reg        bat_param_rd_en;
(* mark_debug = "true" *)reg        bat_param_rd_en_latch;
(* mark_debug = "true" *)reg        bat_param_rd_done;
(* mark_debug = "true" *)reg [7:0]  bat_gauge_reg_addr;
(* mark_debug = "true" *)reg [7:0]  bat_gauge_reg_data;

//////////////////////////////////////////////////

(* mark_debug = "true" *) wire wait_done;
(* mark_debug = "true" *) wire restart_en;
(* mark_debug = "true" *) wire reset_en;
assign wait_done  = OLED_VGN_TEST[0];
//assign reset_en   = OLED_VGN_TEST[1];
//assign restart_en = OLED_VGN_TEST[31];

assign  pal_ntsc_sel_pos_edge = (!pal_ntsc_sel_d) & pal_ntsc_sel;
assign  pal_ntsc_sel_neg_edge = pal_ntsc_sel_d & (!pal_ntsc_sel);


reg snapshot_trigger;
reg [3:0] snapshot_mode;
reg [2:0] snapshot_channel;
reg [7:0] snapshot_image_numbers;
wire snapshot_done;
reg snapshot_save_en;
output reg snapshot_save_done;
reg snapshot_delete_en;

(* mark_debug = "true" *)reg [2:0] fifo_wr_en;
(* mark_debug = "true" *)wire [31:0] sdram_fifo_dout;
(* mark_debug = "true" *)wire sdram_fifo_full;
(* mark_debug = "true" *)wire sdram_fifo_empty;
(* mark_debug = "true" *)wire sdram_fifo_prog_full;
(* mark_debug = "true" *)wire sdram_fifo_prog_empty;
wire [5:0] sdram_fifo_rd_data_count;
wire [5:0] sdram_fifo_wr_data_count;
wire sdram_fifo_rd_rst_busy;
wire sdram_fifo_wr_rst_busy;

(* mark_debug = "true" *)reg sdram_fifo_rd_en;

(* mark_debug = "true" *)wire sdram_fifo_rst_busy = sdram_fifo_wr_rst_busy || sdram_fifo_rd_rst_busy;


wire trigger_co;
wire busy_co;
wire done_co;

wire snap_done_gpio;
wire snap_trigger_gpio;
wire [2:0] snap_mode_gpio;
wire [2:0] snap_channel_gpio;
wire  [7:0] snap_image_numbers_gpio;

wire [31:0] av_fpga_address_gpio;
wire av_fpga_read_gpio;
wire [31:0] av_fpga_readdata_gpio;
wire av_fpga_readdatavalid_gpio;
wire av_fpga_write_gpio;
wire [31:0] av_fpga_writedata_gpio;
wire av_fpga_waitrequest_gpio;


wire av_sensor_write_gpio;
wire [31:0] av_sensor_writedata_gpio;
wire [31:0] av_sensor_address_gpio;


reg av_sensor_write_r;
reg av_sensor_read_r;
reg [31:0] av_sensor_writedata_r;
reg [31:0] av_sensor_address_r;
wire av_sensor_readdatavalid_r;
wire [31:0] av_sensor_readdata_r;
wire av_sensor_waitrequest_r;

reg [31:0] av_fpga_address_r;
reg av_fpga_read_r;
wire av_fpga_readdatavalid_r;
wire [31:0] av_fpga_readdata_r;
reg av_fpga_write_r;
reg [31:0] av_fpga_writedata_r;
wire av_fpga_waitrequest_r;

reg toggle_gpio_d;

///////////////////////////////////////////////////////////////////////////////////
//////// Following are bus muxes for performing coarse offset update using
//////// gpio or the osd menu
///////////////////////////////////////////////////////////////////////////////////
assign av_fpga_write                = busy_co? av_fpga_write_gpio:av_fpga_write_r;
assign av_fpga_writedata            = busy_co? av_fpga_writedata_gpio:av_fpga_writedata_r;
assign av_fpga_address              = busy_co? av_fpga_address_gpio:av_fpga_address_r;
assign av_fpga_read                 = busy_co? av_fpga_read_gpio:av_fpga_read_r;

assign av_fpga_readdatavalid_r      = (!busy_co)?av_fpga_readdatavalid:1'b0;
assign av_fpga_readdata_r           = av_fpga_readdata;
assign av_fpga_waitrequest_r        = (!busy_co)?av_fpga_waitrequest:1'b1;

assign av_fpga_readdatavalid_gpio   = busy_co?av_fpga_readdatavalid:1'b0;
assign av_fpga_readdata_gpio        = av_fpga_readdata;
assign av_fpga_waitrequest_gpio     = busy_co?av_fpga_waitrequest:1'b1;


assign snap_trigger         = (busy_co)?snap_trigger_gpio:snapshot_trigger;
assign snap_channel         = (busy_co)?snap_channel_gpio:snapshot_channel;
assign snap_mode            = (busy_co)?snap_mode_gpio:snapshot_mode[2:0];
assign snap_image_numbers   = (busy_co)?snap_image_numbers_gpio:snapshot_image_numbers;
assign snapshot_done        = snap_done;
assign snap_done_gpio       = snap_done;

assign av_sensor_address    = (busy_co)?av_sensor_address_gpio:av_sensor_address_r;
assign av_sensor_write      = (busy_co)?av_sensor_write_gpio:av_sensor_write_r;
assign av_sensor_writedata  = (busy_co)?av_sensor_writedata_gpio:av_sensor_writedata_r;

assign av_sensor_read       = av_sensor_read_r;

//assign av_sensor_readdata_r         = av_sensor_readdata;
//assign av_sensor_readdatavalid_r    = av_sensor_readdatavalid;
//assign av_sensor_waitrequest_r      = av_sensor_waitrequest;

assign trigger_co  = coarse_offset_calib_start;

(* mark_debug = "true" *) wire toggle_gpio_pos_edge;
(* mark_debug = "true" *) wire toggle_gpio_neg_edge;

assign  toggle_gpio_pos_edge = (!toggle_gpio_d) & toggle_gpio;
assign  toggle_gpio_neg_edge = toggle_gpio_d & (!toggle_gpio);


always @(posedge clk, posedge rst) begin: REGS_MASTER_PARSE_PACKET
    reg [16-1:0] read_len_s;
    if (rst == 1) begin
        uart_data_timeout_count <= 0;
        uart_data_timeout_error <= 0;
        av_rdsdram_burstcount <= 0;
        resp_data_length <= 0;
        av_fpga_read_r <= 0;
        devid_error <= 0;
        read_len <= 0;
        sd_bus_addr_i <= 0;
        sd_bus_data_i <= 0;
        max_burst_c <= 0;
        sd_bus_hndShk_i <= 0;
        cmd <= 0;
        cmd_type <= 8'h72;
        cmd_status <= 0;
        wait_cnt <= 0;
        sd_addr <= 0;
        burst_count <= 0;
        st_temp <= r_idle;
        resp_cmd <= 0;
        av_i2c_address <= 0;
        av_fpga_address_r <= 0;
        av_uart_address <= 0;
        diA_db <= 0;
        addrA_db <= 0;
        we_rdb <= 0;
        crc_error <= 0;
        devno_error <= 0;
        footer_error <= 0;
        data_error <=0;
        cmd_error <= 0;
        av_uart_read <= 0;
        diA_rdb <= 0;
//        av_spi_writedata <= 0;
        addrB_db <= 0;
//        av_spi_address <= 0;
        av_wrsdram_write <= 0;
        av_wrsdram_writeburst <= 0;
        av_fpga_writedata_r <= 0;
        av_rdsdram_address <= 0;
        sd_card_error <= 0;
        av_sensor_address_r <= 0;
        av_sensor_write_r <= 0;
        av_sensor_read_r <= 0;
        av_sensor_writedata_r <= 0;        
        av_i2c_writedata <= 0;
        av_i2c_data_16_en <= 0;
//        av_sensor_i2c_writedata <= 0;
        datavalid <= 0;
        sd_bus_wr_i <= 0;
        dev_id <= 0;
        addr_count <= 0;
        header <= 0;
        addrB_rdb <= 0;
        st <= r_idle;//r_init;
        dev_no <= 0;
        data_length <= 0;
        av_fpga_write_r <= 0;
//        av_spi_write <= 0;
        av_wrsdram_address <= 0;
        addrA_rdb <= 0;
        trigger_reg <= 0;
        recv_cnt <= 0;
        read_done <= 0;
        data <= 0;
        packt_seq1 <= 0;
        packt_seq2 <= 0;
        data_length_error <= 0;
        sd_bus_rd_i <= 0;
        av_wrsdram_burstcount <= 0;
        av_uart_writedata <= 0;
        crc_calculated <= 0;
        crc <= 0;
        av_i2c_write <= 0;
        av_i2c_read <= 0;
        av_sensor_i2c_write <= 0;
        av_sensor_i2c_read <= 0;
        timeout_count <= 0;
        av_uart_write <= 0;
        low_burst_c <= 0;
        ram_rdaddr <= 0;
        we_db <= 0;
        send_cnt <= 0;
        ram_wraddr <= 0;
        av_rdsdram_read <= 0;
        sdram_addr <= 0;
        adv_reset_n <= 1'b1;
        sdram_write_byte_cnt <= 0;
        sdram_read_byte_cnt  <= 0;
        qspi_wr_cnt          <= 0;
        sdram_read_addr      <= 0;
        qspi_wr_data_valid <= 1'b0; 
        qspi_wr_data <= 0;  
        temp_qspi_write_cnt <= 0;
        qspi_rx_rd_fifo_rq  <= 0;
        //qspi_page_wr_rq      <= 1'b0;
        qspi_mem_rd_rq       <= 1'b0;
        //qspi_sector_erase_rq <= 1'b0;
        qspi_reg_wr_rq       <= 1'b0;
        dest_address         <= 0;
        src_address          <= 0;
        data_trans_len       <= 0;
        data_trans_len_d     <= 0;
        dest_address_d       <= 0;
        src_address_d        <= 0;
        c_cmd                <= 0;
        write_sdram_data_rq  <= 1'b0;
        sdram_send_adddr     <= 0;
        qspi_send_addr       <= 32'h00000000;
        qspi_send_rd_size    <= 0;
        qspi_send_cmd        <= 8'd0;
        qspi_init_st_addr_reg <= qspi_init_st_addr;
        qspi_init_cmd_done    <= 1'b0;
        BT656_START           <= 1'b0;
        logo_frame_wr_cnt     <= 5'd0;
        gain_wr_done <= 0;
        page_wr_cnt  <= 0;
        sector_erase_cnt <= 0;
        qspi_send_sector_erase_cmd <= 0;
        qspi_sdram_trans_enable <= 0;
        rd_qspi_wr_sdram_enable <= 0;
        qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
        qspi_sdram_trans_st_next <= r_qspi_sdram_trans_idle;
        qspi_addr <= 0;
        qspi_trans_len <= 0;
        qspi_erase_enable <= 0;
        qspi_erase_64KB_enable <= 0;
        qspi_erase_32KB_enable <= 0;
        qspi_erase_4KB_enable <= 0;
        PRDCT_NAME_WRITE_DATA <= 0;
        PRDCT_NAME_WRITE_DATA_VALID <= 1'b0;
        temperature_write_data <= 0;
        temperature_write_data_valid <= 0;
        sensor_init_write_data_valid <= 0;
        sensor_init_write_data <= 0;
        qspi_temperature_wr_st <= r_qspi_temperature_page_wr_idle;
        temperature_rd_byte_cnt <= 0;
        temperature_rd_rq       <= 0;
        qspi_temperature_wr_enable <= 0;
        temperature_wr_addr <= 0;
        temperature_wr_rq   <= 0;
        ch_img_sum_temp <= 64'd0;
        ch_img_sum <= 64'd0; 
        number_of_erase_block <=0;
        qspi_erase_end_addr   <=0;
        qspi_erase_start_addr <=0;
        sensor_init_data_len <= 0;
        update_sensor_init   <= 1'b0;
        sensor_init_mem_rd_addr_temp1 <= 0;
        sensor_init_rd_byte_cnt  <= 0;
        sensor_init_mem_rd_addr1 <= 0;
        sensor_init_mem_rd_req1  <= 1'b0;
        sensor_init_mem_wr_addr1 <= 0;
        sensor_init_mem_wr_req1  <= 1'b0;
        sensor_init_mem_wr_data1 <= 0;
//        sensor_init_dbias_store            <= 0;
//        sensor_init_coarse_offset_store    <= 0;
//        sensor_init_heat_comp_store        <= 0;
//        sensor_init_temp_offset_store      <= 0;
//        sensor_init_dbias_store_en         <= 1'b0;
//        sensor_init_coarse_offset_store_en <= 1'b0;
//        sensor_init_heat_comp_store_en     <= 1'b0;
//        sensor_init_temp_offset_store_en   <= 1'b0;
        mark_bp_en      <= 1'b0;  
        unmark_bp_en   <= 1'b0; 
        gain_tb_sel_cnt <= 3'b0;
        mark_bp_st      <= r_mark_bp_idle; 
        latch_reticle_pos_x <= 0;
        latch_reticle_pos_y <= 0;
        gain_tb_addr        <= 0;
        gain_addr_offset    <= 0;
        mark_bp_error       <= 1'b0;
        unmark_bp_error     <= 1'b0;

        save_user_settings_en <= 1'b0;
        switch_to_factory_settings_en <= 1'b0;
        user_settings_mem_wr_req1 <= 0;
        user_settings_mem_wr_addr_temp1 <=0;
        user_settings_mem_wr_data1 <= 0;
        user_settings_init_start <= 1'b0; 
        qspi_user_settings_trans_en <= 1'b0;
        user_settings_mux_sel <= 1'b0;
        load_user_settings_en    <= 1'b0;
        load_factory_settings_en <= 1'b0; 
        
        sel_temp_range      <= 3'b00;
//        device_id           <= 32'd0;
        qspi_sensor_init_wr_enable <= 1'b0;
        av_wrsdram_writedata <= 0;
        sensor_trigger       <= 1'b0;
        sdram_write_data     <= 0;
        sdram_write_addr     <= 0;
        temp_qspi_read_cnt   <= 0;
        qspi_sector_erase_rq <= 1'b0;
        qspi_temperature_wr_enable_d <= 1'b0;
        qspi_page_wr_rq <= 1'b0;
        sdram_read_data <= 0;
        qspi_sensor_init_wr_st <= r_qspi_sensor_init_page_wr_idle;
        sensor_init_rd_data_temp <= 0;
        qspi_rd_cnt <= 0;
        temperature_rd_data_temp <= 0;
        cmd_type_error <= 1'b0;
        switch_to_factory_settings_en_d   <= 1'b0;
        user_settings_mem_wr_addr_temp1   <= 0;
        user_settings_mem_wr_addr1        <= 0; 
        user_settings_mem_rd_addr_temp1   <= 0;
        user_settings_mem_rd_req1         <= 1'b0;
        user_settings_mem_rd_addr1        <= 0;
        user_settings_mem_rd_data1_temp   <= 0;
        adv_pal_init_mem_wr_req           <= 1'b0;
        adv_pal_init_mem_wr_addr          <= 0;  
        adv_init_mem_wr_addr_temp         <= 0;  
        adv_pal_init_mem_wr_data          <= 0;  
        adv_init_mem_rd_addr_temp         <= 0;  
        adv_pal_init_mem_rd_req           <= 1'b0;
        adv_pal_init_mem_rd_addr          <= 0;  
        adv_ntsc_init_mem_wr_req          <= 1'b0;
        adv_ntsc_init_mem_wr_addr         <= 0;    
        adv_ntsc_init_mem_wr_data         <= 0; 
        adv_ntsc_init_mem_rd_req          <= 1'b0;
        adv_ntsc_init_mem_rd_addr         <= 0;                      
        qspi_oled_init_wr_st              <= r_qspi_oled_init_wr_idle;
        oled_init_mem_wr_req              <= 1'b0;
        oled_init_mem_wr_addr             <= 0;
        oled_init_mem_wr_addr_temp        <= 0;
        oled_init_mem_wr_data             <= 0;       
        oled_init_mem_rd_addr_temp        <= 0;
        oled_init_mem_rd_req              <= 1'b0;
        oled_init_mem_rd_addr             <= 0;      
        oled_gamma_coeff_mem_wr_req       <= 1'b0;
        oled_gamma_coeff_mem_wr_addr      <= 0;
        oled_gamma_coeff_mem_wr_addr_temp <= 0;
        oled_gamma_coeff_mem_wr_data      <= 0;       
        oled_gamma_coeff_mem_wr_done      <= 1'b0;
        oled_reint_wait_cnt <= 0;
        
        time_cnt_Start <= 1'b0;
        time_cnt <= 0;
        qspi_reticle_transfer_done <= 1'b0;
        qspi_reticle_transfer_rq_ack <= 1'b0;
        RETICLE_WR_DATA <= 0;
        RETICLE_OFFSET_WR_DATA <= 0;
        LOGO_WR_DATA    <= 0;
        RETICLE_WR_EN   <= 1'b0;
        RETICLE_OFFSET_WR_EN <= 1'b0;
        LOGO_WR_EN      <= 1'b0;
        MUX_WR_DATA     <= 0;
        ADV_DEV_ADDR    <= 0;
        ADV_REG_CNT     <= 0;
        ADV_REG_WR_CNT  <= 0;
        st_adv_init     <= r_adv_init_idle;
        adv_init_done   <= 1'b0;
        OLED_DEV_ADDR   <= 0;
        BAT_GAUGE_DEV_ADDR   <= 0; 
        BAT_ADC_DEV_ADDR    <= 0;   
        OLED_VGN_ADC_DEV_ADDR<= 0;
//        ADV_REG_CNT     <= 0;
//        ADV_REG_WR_CNT  <= 0;
        ADV_OLED_DEV_ADDR    <= 0;
        ADV_OLED_REG_CNT     <= 0;
        ADV_OLED_REG_WR_CNT  <= 0;
        OLED_REG_CNT         <= 0;
        OLED_REG_WR_CNT      <= 0;        
        oled_init_done                    <= 1'b0;
        qspi_oled_init_wr_enable          <= 1'b0;
        oled_init_rd_byte_cnt             <= 0;
        oled_init_rd_data_temp            <= 0;
        oled_gamma_coeff_mem_rd_req       <= 1'b0;
        oled_gamma_coeff_mem_rd_addr      <= 0;
        oled_gamma_coeff_mem_rd_addr_temp <= 0;
        gl_gc_cnt                         <= 0;
        st_oled_gamma_tb_calc             <= oled_gamma_tb_calc_idle;
        st_next_oled_gamma_tb_calc        <= oled_gamma_tb_calc_idle;
        oled_gamma_table_mem_wr_addr      <= 0;  
        oled_gamma_table_mem_wr_data      <= 0; 
        oled_gamma_table_mem_wr_req       <= 1'b0;  
        tmpval                            <= 0; 
        index                             <= 0;   
        val_8_bit                         <= 0; 
        gl_gc_mul                         <= 0; 
        gl_diff                           <= 0; 
        dvsr                              <= 0; 
        dvnd                              <= 0; 
        start_div                         <= 1'b0; 
        oled_gamma_table_mem_rd_addr      <= 0;      
        oled_gamma_table_mem_rd_addr_temp <= 0;
        oled_gamma_table_mem_rd_req       <= 1'b0;    
        oled_reg_addr                     <= 0;
        oled_reg_data                     <= 0; 
        OLED_GAMMA_TABLE_SEL_D            <= 0;        
        OLED_POS_BOTPOS_WR_EN             <= 1'b0;
        OLED_POS_LFTPOS_WR_EN             <= 1'b0;     
        OLED_POS_LFTPOS_MSB_WR_EN         <= 1'b0; 
        OLED_POS_RGTPOS_WR_EN             <= 1'b0; 
        OLED_POS_BOTPOS_WR_DATA           <= 0;          
        OLED_POS_LFTPOS_WR_DATA           <= 0;           
        oled_init_mem_botpos_wr_data      <= 0;
        oled_init_mem_botpos_wr_en        <= 1'b0;  
        oled_init_mem_rgtpos_wr_en        <= 1'b0;
        oled_init_mem_lftpos_wr_data      <= 0;
        oled_init_mem_lftpos_wr_en        <= 1'b0;
        oled_init_mem_lftpos_msb_wr_en    <= 1'b0;
        oled_vgn_gamma_mem_wr_addr_temp   <= 0;        
        oled_vgn_gamma_mem1_wr_addr       <= 0;  
        oled_vgn_gamma_mem1_wr_data       <= 0; 
        oled_vgn_gamma_mem1_wr_req        <= 1'b0;         
        oled_vgn_gamma_mem1_rd_addr       <= 0;      
        oled_vgn_gamma_mem1_rd_req        <= 1'b0; 
        oled_vgn_gamma_mem2_wr_addr       <= 0;  
        oled_vgn_gamma_mem2_wr_data       <= 0; 
        oled_vgn_gamma_mem2_wr_req        <= 1'b0;         
        oled_vgn_gamma_mem2_rd_addr       <= 0;      
        oled_vgn_gamma_mem2_rd_req        <= 1'b0; 
        oled_vgn_gamma_mem3_wr_addr       <= 0;     
        oled_vgn_gamma_mem3_wr_data       <= 0;    
        oled_vgn_gamma_mem3_wr_req        <= 1'b0; 
        oled_vgn_gamma_mem3_rd_addr       <= 0;     
        oled_vgn_gamma_mem3_rd_req        <= 1'b0;  
        oled_cf_mem_wr_addr               <= 0;  
        oled_cf_mem_wr_addr_temp          <= 0;  
        oled_cf_mem_wr_data               <= 0;    
        oled_cf_mem_wr_req                <= 1'b0; 
        oled_cf_mem_rd_addr               <= 0;       
        oled_cf_mem_rd_req                <= 1'b0; 
        vgn_dvsr                          <= 0; 
        vgn_dvnd                          <= 0; 
        vgn_start_div                     <= 1'b0;  
//        st_oled_vgn_gc_coeff_calc         <= oled_vgn_gc_coeff_calc_idle;
        gammaset                          <= 8'h07;
        vgn_settle_time_cnt               <= 8'h00;
//        vgn_gc_sel                        <= 1'b0;
//        MAX_VGN_SETTLE_TIME               <= 8'h32;
        vgn_gamma_mem_wr_sel              <= 2'd0;
        vgn_gamma_mem_rd_sel              <= 2'd0;    
        bat_control_reg_data              <= 8'd0; 
        bat_status_reg_data               <= 8'd0; 
        bat_temp_reg_data                 <= 16'd0; 
        bat_voltage_reg_data              <= 16'd0; 
        bat_acc_charge_reg_data           <= 16'd0; 
        bat_param_rd_time_cnt             <= 16'd0; 
        bat_param_rd_en                   <= 1'b0;
        bat_param_rd_en_latch             <= 1'b0;
        bat_param_initial_rd_done         <= 1'b0;
        bat_param_rd_done                 <= 1'b0;
        bat_gauge_init_done               <= 1'b0; 
        shutter_enable_latch              <= 1'b0;
        control_sdram_write_start_stop    <= 1'b0;
        vgn_rd_en                         <= 1'b0;
        vgn_rd_en_latch                   <= 1'b0;
        oled_reinit_vgn_rd_en             <= 1'b0;
        vgn_rd_done                       <= 1'b0;
        oled_cathode_voltage_dev_sel      <= 1'b0;
        OLED_CATHODE_VOLTAGE_DEV_ADDR     <= 8'h29;        
        OLED_POS_V_VALID_LATCH            <= 1'b0;
        OLED_POS_H_VALID_LATCH            <= 1'b0;
        OLED_BRIGHTNESS_VALID_LATCH       <= 1'b0;
        OLED_CONTRAST_VALID_LATCH         <= 1'b0;
        OLED_IDRF_VALID_LATCH             <= 1'b0;
        OLED_DIMCTL_VALID_LATCH           <= 1'b0; 
        OLED_IMG_FLIP_VALID_LATCH         <= 1'b0;
        OLED_CATHODE_VOLTAGE_VALID_LATCH  <= 1'b0;
        OLED_ROW_START_MSB_VALID_LATCH        <= 1'b0;
        OLED_ROW_START_LSB_VALID_LATCH        <= 1'b0;
        OLED_ROW_END_MSB_VALID_LATCH          <= 1'b0;
        OLED_ROW_END_LSB_VALID_LATCH          <= 1'b0;
        OLED_POS_V_VALID_LATCH_DONE       <= 1'b0;
        OLED_POS_H_VALID_LATCH_DONE       <= 1'b0;
        OLED_BRIGHTNESS_VALID_LATCH_DONE  <= 1'b0;
        OLED_CONTRAST_VALID_LATCH_DONE    <= 1'b0;
        OLED_IDRF_VALID_LATCH_DONE        <= 1'b0;
        OLED_DIMCTL_VALID_LATCH_DONE      <= 1'b0;
        OLED_IMG_FLIP_VALID_LATCH_DONE    <= 1'b0;
        OLED_CATHODE_VOLTAGE_VALID_LATCH_DONE<= 1'b0;
        OLED_ROW_START_MSB_VALID_LATCH_DONE<= 1'b0;
        OLED_ROW_START_LSB_VALID_LATCH_DONE<= 1'b0;
        OLED_ROW_END_MSB_VALID_LATCH_DONE  <= 1'b0;
        OLED_ROW_END_LSB_VALID_LATCH_DONE  <= 1'b0;        
        OLED_POS_BOTPOS_WR_EN_LATCH_DONE  <= 1'b0;
        OLED_POS_LFTPOS_WR_EN_LATCH_DONE  <= 1'b0; 
        OLED_POS_LFTPOS_MSB_WR_EN_LATCH_DONE  <= 1'b0;    
        OLED_POS_RGTPOS_WR_EN_LATCH_DONE  <= 1'b0;             
        oled_reinit_start                 <= 1'b0;
        oled_standby_process_busy         <= 1'b0;    
        st_oled_reinit                    <= r_oled_reinit_idle;                     
        st_oled_reg_update                <= oled_reg_update_idle;
        oled_reset                        <= 1'b0;
        oled_power_off                    <= 1'b0; 
        oled_reg_data1                    <= 8'd0;     
        oled_reg_addr1                    <= 8'd0;  
        oled_vgn_bat_i2c_busy             <= 1'b0; 
        oled_vgn_bat_shutter_process_busy <= 1'b0;   
        sensor_init_rd_done               <= 1'b0;
        pal_ntsc_sel_d                    <= 1'b0;

        snapshot_mode     <= 0;
        snapshot_channel <= 0;
        snapshot_trigger <= 0;
        snapshot_image_numbers <= 0;
        fifo_wr_en           <= 0;
        snapshot_save_en     <= 1'b0;
        snapshot_save_done   <= 1'b0;
        snapshot_delete_en   <= 1'b0;
        snapshot_delete_done <= 1'b0;
        gallery_img_valid_save_en   <= 1'b0;
        gallery_img_valid_save_done <= 1'b0;
        gallery_img_valid           <= 0;
        gallery_img_valid_en        <= 1'b0;
        video_start                 <= 1'b0;
        battery_disp_start          <= 1'b0;
        toggle_gpio_d               <= 1'b0;
        nuc1pt_start                <= 1'b0;
        shutter_i2c_write_again_wait_counter <= 16'd0;
        nuc1pt_start_time_cnt       <= 8'd0;
        magneto_x_data              <= 16'h0000;
        magneto_y_data              <= 16'h0000;
        magneto_z_data              <= 16'h0000;
        accel_x_data                <= 16'h0000;
        accel_y_data                <= 16'h0000;
        accel_z_data                <= 16'h0000;        
		icm_param_initial_rd_done   <= 1'b0;
		icm_param_rd_en             <= 1'b0;  
		icm_param_rd_en_latch       <= 1'b0;
		icm_param_rd_done           <= 1'b0; 
		icm_reg_addr                <= 8'h00; 
		icm_reg_data                <= 8'h00; 
		icm_i2c_dev_addr            <= ICM_DEV_ADDRESS;


    end
    else begin
        gallery_img_valid_en <= 1'b0;
        for(int i=0;i<2;i=i+1) begin
            fifo_wr_en[i+1] <= fifo_wr_en[i];
        end
        fifo_wr_en[0] <= 1'b0;
        
        trigger_reg                    <= trigger;
        user_settings_init_start       <= 1'b0;
        vgn_rd_en                      <= 1'b0; 
        bat_param_rd_en                <= 1'b0;
        icm_param_rd_en                <= 1'b0;
        toggle_gpio_d                  <= toggle_gpio;
        
        if(time_cnt_Start)begin
            if(tick_1us)begin
                time_cnt <= time_cnt +1;
            end
            else  begin
                time_cnt <= time_cnt;
            end  
        end
        else begin
            time_cnt <= time_cnt;
        end
        if(bat_gauge_init_done == 1'b1)begin
            if(tick_1s)begin
                if(bat_param_rd_time_cnt >= MAX_BAT_PARAM_RD_PERIOD)begin
                    bat_param_rd_time_cnt <= 16'd0;
                    bat_param_rd_en       <= 1'b1;
                end
                else begin 
                    bat_param_rd_time_cnt <= bat_param_rd_time_cnt + 1;
                end
            end
            else begin
                bat_param_rd_time_cnt <= bat_param_rd_time_cnt;
            end
        end
        else begin
            bat_param_rd_time_cnt <= 16'd0;
        end

        if(icm_init_done == 1'b1)begin
            if(tick_1ms)begin
                if(icm_param_rd_time_cnt >= 16'd50)begin
                    icm_param_rd_time_cnt <= 16'd0;
                    icm_param_rd_en       <= 1'b1;
                end
                else begin 
                    icm_param_rd_time_cnt <= icm_param_rd_time_cnt + 1;
                end
            end
            else begin
                icm_param_rd_time_cnt <= icm_param_rd_time_cnt;
            end
        end
        else begin
            icm_param_rd_time_cnt <= 16'd0;
        end

            
        if((OLED_GAMMA_TABLE_SEL == 0 || OLED_GAMMA_TABLE_SEL == 1 || OLED_GAMMA_TABLE_SEL == 2) && (oled_init_done == 1'b1))begin
            if(tick_1s)begin
                if(vgn_rd_time_cnt >= MAX_OLED_VGN_RD_PERIOD)begin
                    vgn_rd_time_cnt <= 16'd0;
                    vgn_rd_en       <= 1'b1;
                end
                else begin 
                    vgn_rd_time_cnt <= vgn_rd_time_cnt + 1;
                end
            end
            else begin
                vgn_rd_time_cnt <= vgn_rd_time_cnt;
            end
        end
        else begin
            vgn_rd_time_cnt <= 16'd0;
        end    

        if(icm_param_rd_en == 1'b1)begin
            icm_param_rd_en_latch <= 1'b1;    
        end

        if(bat_param_rd_en == 1'b1)begin
            bat_param_rd_en_latch <= 1'b1;    
        end
        if(vgn_rd_en == 1'b1)begin
            vgn_rd_en_latch <= 1'b1;
        end
        
        if((toggle_gpio_pos_edge == 1'b1 || toggle_gpio_neg_edge == 1'b1 || nuc1pt_start_in == 1'b1)&&(shutter_en== 1'b1)) begin
//        if(toggle_gpio_pos_edge == 1'b1 || toggle_gpio_neg_edge == 1'b1 ) begin
//        if(nuc1pt_start_in == 1'b1) begin
            shutter_enable_latch <= 1'b1;
        end        
        
        if((OLED_POS_V_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_POS_V_VALID_LATCH <= 1'b1;
        end        
        if((OLED_POS_H_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_POS_H_VALID_LATCH <= 1'b1;
        end  
        if((OLED_BRIGHTNESS_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_BRIGHTNESS_VALID_LATCH <= 1'b1;
        end  

        if((OLED_CONTRAST_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_CONTRAST_VALID_LATCH <= 1'b1;
        end 

        if((OLED_IDRF_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_IDRF_VALID_LATCH <= 1'b1;
        end                            

        if((OLED_DIMCTL_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_DIMCTL_VALID_LATCH <= 1'b1;
        end           

        if((OLED_IMG_FLIP_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_IMG_FLIP_VALID_LATCH <= 1'b1;
        end   

        if((OLED_CATHODE_VOLTAGE_VALID == 1'b1))begin
            OLED_CATHODE_VOLTAGE_VALID_LATCH <= 1'b1;
        end  

        if((OLED_ROW_START_MSB_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_ROW_START_MSB_VALID_LATCH <= 1'b1;
        end 

        if((OLED_ROW_START_LSB_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_ROW_START_LSB_VALID_LATCH <= 1'b1;
        end  

        if((OLED_ROW_END_MSB_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_ROW_END_MSB_VALID_LATCH <= 1'b1;
        end 

        if((OLED_ROW_END_LSB_VALID == 1'b1) && (oled_init_done == 1'b1))begin
            OLED_ROW_END_LSB_VALID_LATCH <= 1'b1;
        end    
                             
        case (st)
            r_idle: begin
                timeout_count <= 0;
                datavalid <= 1'b0;
                we_db <= 1'b0;
                av_i2c_write <= 1'b0;
                av_i2c_read <= 1'b0;
                av_sensor_i2c_write <= 1'b0;
                av_sensor_i2c_read <= 1'b0;
                if (((data == HEADER_BYTE) && datavalid && recv_cnt==0)) begin
                    header <= data;
                    uart_data_timeout_error <= 1'b0;
                    devid_error <= 1'b0;
                    devno_error <= 1'b0;
                    crc_error <= 1'b0;
                    footer_error <= 1'b0;
                    sd_card_error <= 1'b0;
                    cmd_error <= 0;
                    recv_cnt <= 1;
                    crc_calculated <= 0;
                end
                if (((recv_cnt == 1) && datavalid)) begin
                    packt_seq1 <= data;
                    recv_cnt <= (recv_cnt + 1);
                end
                else if((recv_cnt == 2) && datavalid) begin  
                    packt_seq2 <= data;
                    recv_cnt <= (recv_cnt + 1);
                end 
                else if (((recv_cnt == 3) && datavalid)) begin  
                    dev_id <= data;    
                    if ((data != DEV_ID)) begin
                        devid_error <= 1'b1;
                    end
                    recv_cnt <= (recv_cnt + 1);
                    crc_calculated <= (crc_calculated + data);
                end
                else if (((recv_cnt == 4) && datavalid)) begin
                    dev_no <= data;
                    if (((data != 255) || (data != DEV_NUM))) begin
                        devno_error <= 1'b1;
                    end
                    recv_cnt <= (recv_cnt + 1);
                    crc_calculated <= (crc_calculated + data);
                end
                else if (((recv_cnt == 5) && datavalid)) begin
                    data_length[8-1:0] <= data - 3;
                    data_length[16-1:8] <= 0;
                    recv_cnt <= (recv_cnt + 1);
                    crc_calculated <= (crc_calculated + data);
                end
                else if (((recv_cnt == 6) && datavalid)) begin
                    cmd_type <= data;
                    if ((data!=8'h77 && data!=8'h57 && data!=8'h72 && data!=8'h52)) begin 
                      cmd_type_error <= 1;
                    end
                    recv_cnt <= (recv_cnt + 1);
                    crc_calculated <= (crc_calculated + data);
                end
                else if (((recv_cnt == 7) && datavalid)) begin
                    cmd[16-1:8] <= data;
                    recv_cnt <= (recv_cnt + 1);
                    crc_calculated <= (crc_calculated + data);
                end
                else if (((recv_cnt == 8) && datavalid)) begin
                    cmd[8-1:0] <= data;
                    recv_cnt <= (recv_cnt + 1);
                    ram_wraddr <= 0;
                    addrA_db <= ((2 ** 9) - 1);
                    crc_calculated <= (crc_calculated + data);
                end
                else 
                  if(data_length==0 && datavalid) begin
                    if( recv_cnt==9 ) begin
                      crc <= data;
                      recv_cnt <= (recv_cnt + 1);
                      if ((data != crc_calculated)) begin
                          crc_error <= 1'b1;
                      end
                    end
                    else if(recv_cnt==10) begin
                      if(data!=FOOTER_BYTE1) begin
                        footer_error <= 1'b1;
                      end
                      recv_cnt <= (recv_cnt + 1);
                    end 
                    else if(recv_cnt==11) begin 
                      if(data!=FOOTER_BYTE2) begin 
                        footer_error <= 1'b1;
                      end
                      recv_cnt <= 0;
                      st <= r_wait;
                      st_temp <= r_take_action;
                      wait_cnt <= 0;
                      addrB_db <= 0;
                      crc_calculated <= 0;
                    end
                  end
                  else if (((recv_cnt >= 9) && ($signed({1'b0, recv_cnt}) <= ((9 + data_length ) - 1)) && datavalid)) begin
                      ram_wraddr <= (ram_wraddr + 1);
                      addrA_db <= (addrA_db + 1);
                      diA_db <= data;
                      we_db <= 1'b1;
                      recv_cnt <= (recv_cnt + 1);
                      crc_calculated <= (crc_calculated + data);
                  end
                  else if (((recv_cnt == (9 + data_length )) && datavalid)) begin
                    crc <= data;
                    recv_cnt <= (recv_cnt + 1);
                    if ((data != crc_calculated)) begin
                        crc_error <= 1'b1;
                    end
                  end
                  else if (((recv_cnt == (10 + data_length )) && datavalid)) begin
                      if(data!=FOOTER_BYTE1) begin
                        footer_error <= 1'b1;
                      end
                      recv_cnt <= (recv_cnt + 1);
                  end
                  else if (((recv_cnt == (11 + data_length )) && datavalid)) begin
                      if(data!=FOOTER_BYTE2) begin 
                        footer_error <= 1'b1;
                      end
                      recv_cnt <= 0;
                      st <= r_wait;
                      st_temp <= r_take_action;
                      wait_cnt <= 0;
                      addrB_db <= 0;
                      crc_calculated <= 0;
                end
                
                if (trigger_edge) begin
                    st <= r_get_data;
                    uart_data_timeout_count <= 0;
                end
                else begin   
                    if(recv_cnt >= 1)begin            
                        if ((uart_data_timeout_count == 16)) begin
                            uart_data_timeout_count <= 0;
                            recv_cnt                <= 0;
                            uart_data_timeout_error <= 1'b1;
                            st <= r_wait;
                            st_temp <= r_take_action;
                        end
                        else begin
                            if (tick_1ms) begin
                                uart_data_timeout_count <= uart_data_timeout_count + 1;
                            end
                        end
                    end
                    else begin
                        uart_data_timeout_count <= 0;
                    end
                end
            end
            r_get_data: begin
                av_uart_address <= 4;
                av_uart_read <= 1'b1;
                st <= r_get_data2;
            end
            r_get_data2: begin
                av_uart_read <= (!read_done);
                if ((!av_uart_waitrequest)) begin
                    av_uart_read <= 1'b0;
                    read_done <= 1'b1;
                end
                if (av_uart_readdatavalid) begin
                    data <= av_uart_readdata[8-1:0];
                    datavalid <= 1'b1;
                    read_done <= 1'b0;
                    st <= r_idle;
                end
            end
            r_response_packet: begin
                we_rdb <= 1'b0;
                we_db <= 1'b0;
                if ((send_cnt == 0)) begin
                    data <= HEADER_RESPONSE_BYTE;
                    st <= r_send_packet;
                    crc_calculated <= 0;
                end
                else if ((send_cnt == 1)) begin
                    data <= packt_seq1;
                    st <= r_send_packet;
                end
                else if ((send_cnt == 2)) begin
                    data <= packt_seq2;
                    st <= r_send_packet;
                end
                else if ((send_cnt == 3)) begin
                    data <= dev_id;
                    st <= r_send_packet;
                    crc_calculated <= (crc_calculated + dev_id);
                end
                else if ((send_cnt == 4)) begin
                    data <= dev_no;
                    st <= r_send_packet;
                    crc_calculated <= (crc_calculated + dev_no);
                end
                else if ((send_cnt == 5)) begin
                    data <= resp_data_length[8-1:0]+4;
                    st <= r_send_packet;
                    crc_calculated <= (crc_calculated + resp_data_length[8-1:0] +4);
                end
                else if ((send_cnt == 6)) begin
                    data <= cmd_type;
                    st <= r_send_packet;
                    crc_calculated <= (crc_calculated + cmd_type);
                    ram_rdaddr <= 0;
                    addrB_rdb <= 0;
                end
                else if ((send_cnt == 7)) begin 
                  data <= cmd_status;
                  st <= r_send_packet;
                  crc_calculated <= (crc_calculated + cmd_status);
                end
                else if ((send_cnt == 8)) begin 
                  data <= resp_cmd[16-1:8];
                  st <= r_send_packet;
                  crc_calculated <= (crc_calculated + resp_cmd[16-1:8]);
                end
                else if ((send_cnt == 9)) begin 
                  data <= resp_cmd[8-1:0];
                  st <= r_send_packet;
                  crc_calculated <= (crc_calculated + resp_cmd[8-1:0]);
                end
                else if(resp_data_length==0) begin
                  if(send_cnt==10) begin 
                    data <= crc_calculated;
                    st <= r_send_packet;
                  end
                  else if(send_cnt==11) begin 
                    data <= FOOTER_BYTE1;
                    st <= r_send_packet;
                  end
                  else if(send_cnt==12) begin 
                    data <= FOOTER_BYTE2;
                    st <= r_send_packet;
                  end
                  else if(send_cnt==13) begin 
                    send_cnt <=0;
                    st <= r_idle;
                  end
                end
                else if (((send_cnt >= 10) && ($signed({1'b0, send_cnt}) <= ((10 + resp_data_length) - 1)))) begin
                    ram_rdaddr <= (ram_rdaddr + 1);
                    addrB_rdb <= (addrB_rdb + 1);
                    data <= doB_rdb;
                    crc_calculated <= (crc_calculated + doB_rdb);
                    st <= r_send_packet;
                end
                else if ((send_cnt == (10 + resp_data_length))) begin
                    data <= crc_calculated;
                    st <= r_send_packet;
                end
                else if ((send_cnt == (11 + resp_data_length))) begin 
                  data <= FOOTER_BYTE1;
                  st <= r_send_packet;
                end
                else if((send_cnt == (12 + resp_data_length))) begin 
                  data <= FOOTER_BYTE2;
                  st <= r_send_packet;
                end
                else if ((send_cnt == ((12 + resp_data_length) + 1))) begin
                    send_cnt <= 0;
                    st <= r_idle;
                end
            end
            r_send_packet: begin
                av_uart_address <= 0;
                av_uart_read <= 1'b1;
                st <= r_send_packet2;
            end
            r_send_packet2: begin
                av_uart_read <= (!read_done);
                if ((!av_uart_waitrequest)) begin
                    av_uart_read <= 1'b0;
                    read_done <= 1'b1;
                end
                if (av_uart_readdatavalid) begin
                    read_done <= 1'b0;
                    if (av_uart_readdata[1]) begin
                        st <= r_send_packet;
                    end
                    else begin
                        st <= r_send_packet3;
                    end
                end
            end
            r_send_packet3: begin
                av_uart_write <= 1'b1;
                av_uart_address <= 8;
                av_uart_writedata <= data;
                st <= r_send_packet4;
            end
            r_send_packet4: begin
                av_uart_write <= 1'b1;
                if ((!av_uart_waitrequest)) begin
                    av_uart_write <= 1'b0;
                    st <= r_response_packet;
                    send_cnt <= (send_cnt + 1);
                end
            end
            r_take_action: begin
                if (uart_data_timeout_error || crc_error || data_length_error || footer_error || devno_error || devid_error || cmd_type_error || sd_card_error) begin 
                  st <= r_send_failure;
                end
                else if (({cmd[16-1:12], 12'h0} == FPGA_RD_REGS) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((data_length != 0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        av_fpga_address_r <= {20'h0, cmd[12-1:0]};
                        av_fpga_read_r <= 1'b1;
                        st <= r_take_action2;
                    end
                end
                else if (({cmd[16-1:12], 12'h0} == FPGA_WR_REGS) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if ((data_length != 4)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        av_fpga_write_r <= 1'b1;
                        av_fpga_address_r <= {20'h0, cmd[12-1:0]};
                        av_fpga_writedata_r <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        st <= r_take_action2;
                    end
                end
                else if ((cmd == SET_SDRAM_ADDR) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if ((data_length != 4)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        sdram_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        st <= r_send_success;
                    end
                end
                else if ((cmd == SET_SDRAM_DATA) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if (((data_length < 4) || (data_length >= 512) || (data_length[2-1:0] != 0))) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        max_burst_c <= data_length[16-1:4];
                        low_burst_c <= data_length[4-1:2];
                        addr_count <= 0;
                        addrB_db <= 0;
                        fifo_wr_en[0] <= 1'b1;
                        st <= r_take_action2;
                        wait_cnt <= 0;
                    end
                end
                else if ((cmd == GET_SDRAM_DATA) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((data_length != 2)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        read_len <= {doB_db[8-1:0], doB_db[16-1:8]};
                        read_len_s = {doB_db[8-1:0], doB_db[16-1:8]};
                        max_burst_c <= read_len_s[16-1:4];
                        low_burst_c <= read_len_s[4-1:2];
                        addr_count <= 0;
                        addrA_rdb <= ((2 ** 7) - 1);
                        st <= r_take_action2;
                    end
                end
                else if (((cmd == SET_I2C) ||(cmd == SET_I2C_16B))&& (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if (((data_length <= 2) || (data_length > 10))) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        send_cnt <= 0;
                        addrB_db <= 0;
                        av_i2c_address <= {doB_db[8-1:0], doB_db[16-1:8]};
                        if(cmd == SET_I2C_16B)begin
                            av_i2c_data_16_en <= 1'b1;
                            burst_count <= (data_length - 2) >> 1;
                        end
                        else begin
                            av_i2c_data_16_en <= 1'b0;
                            burst_count <= (data_length - 2);
                        end
                        st <= r_i2c_set_cmd1;
                    end
                end
                else if (((cmd == GET_I2C) || (cmd == GET_I2C_16B)) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((data_length != 3)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        av_i2c_address <= {doB_db[8-1:0], doB_db[16-1:8]};
                        av_i2c_read <= 1'b1;
                        if(cmd == GET_I2C_16B)begin
                            av_i2c_data_16_en <= 1'b1;
                        end
                        else begin
                            av_i2c_data_16_en <= 1'b0;
                        end
                        recv_cnt <= 0;
                        addrA_rdb <= ((2 ** 7) - 1);
                        burst_count <= doB_db[24-1:16];
                        st <= r_i2c_get_cmd1;
                    end
                end
                else if ((cmd == SET_SENSOR_I2C) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if (((data_length <= 3) || (data_length > 10))) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        burst_count <= (data_length - 3);
                        send_cnt <= 0;
                        addrB_db <= 0;
                        av_sensor_i2c_address <= {8'd0, doB_db[8-1:0], doB_db[16-1:8], doB_db[24-1:16]};
                        st <= r_sensor_i2c_set_cmd1;
                    end
                end
                else if ((cmd == GET_SENSOR_I2C) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((data_length != 4)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        av_sensor_i2c_address <= {8'd0, doB_db[8-1:0], doB_db[16-1:8], doB_db[24-1:16]};
                        av_sensor_i2c_read <= 1'b1;
                        recv_cnt <= 0;
                        addrA_rdb <= ((2 ** 7) - 1);
                        burst_count <= doB_db[32-1:24];
                        st <= r_sensor_i2c_get_cmd1;
                    end
                end
                else if ((cmd == SET_SPI) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
//                    if ((data_length != 2)) begin
                    if ((data_length != 4)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
//                        av_spi_address <= cmd[8-1:0];
//                        av_spi_writedata <= {doB_db[8-1:0], doB_db[16-1:8]};
//                        av_spi_write <= 1'b1;
                        av_sensor_address_r <= doB_db[8-1:0];
                        av_sensor_writedata_r <= {8'd0, doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        av_sensor_write_r <= 1'b1; 
                        st <= r_take_action2;
                    end
                end
                else if ((cmd == GET_SPI) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((data_length != 1)) begin 
                      data_length_error <= 1'b1;
                      st <= r_send_failure;
                    end
                    else begin 
                      av_sensor_read_r <= 1'b1;
                      av_sensor_address_r <= {24'd0, doB_db[8-1:0]};
                      st <= r_take_action2;
                    end
                end
                else if ((cmd == PING_CMD)) begin
                    addrB_db <= 0;
                    st <= r_ping1;
                end
                else if ((cmd == SET_SD_ADDR) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if ((data_length != 4)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        sd_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        st <= r_send_success;
                    end
                end
                else if ((cmd == SET_SD_DATA) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if ((data_length != 512)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        if ((!sd_bus_busy_o)) begin
                            sd_bus_addr_i <= sd_addr;
                            sd_bus_wr_i <= 1'b1;
                            st <= r_take_action2;
                        end
                    end
                end
                else if ((cmd == GET_SD_DATA) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((data_length != 0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        if ((!sd_bus_busy_o)) begin
                            sd_bus_addr_i <= sd_addr;
                            sd_bus_rd_i <= 1'b1;
                            st <= r_take_action2;
                        end
                    end
                end
                else if((cmd == SNAPSHOT) && (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                    if((data_length!=4)) begin 
                      data_length_error <= 1'b1;
                      st <= r_send_failure;
                    end
                    else begin 
                      snapshot_mode <= doB_db[24-1:16];
                      snapshot_channel <= doB_db[16-1:8];
                      snapshot_image_numbers <= doB_db[32-1:24];
                      st <= r_take_snapshot1;
                    end
                end
                else if ((cmd == ERASE_QSPI)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                    if((data_length!=4)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
//                    else if (((doB_db[16-1:8]==8'h00) || (doB_db[16-1:8]==8'h08) || (doB_db[16-1:8]==8'h0f) )&& (doB_db[32-1:24] <=(NO_OF_OFFSET_TABLE)) )begin
                    else if (((doB_db[16-1:8]==8'h00)&&((doB_db[32-1:24] >=1) &&(doB_db[32-1:24] <=(NO_OF_OFFSET_TABLE)))) || ((doB_db[16-1:8]==8'h08) && ((doB_db[32-1:24] ==0) || (doB_db[32-1:24] ==1))) || ((doB_db[16-1:8]==8'h0f) && ((doB_db[32-1:24] >=1) &&(doB_db[32-1:24] <= 8))))begin
                        qspi_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        addrB_db <= addrB_db + 1;
                        st_temp <= r_qspi_erase;
                        wait_cnt <= 0;
                        st <= r_wait;                                           
                    end 
                    else begin
                        data_error <= 1'b1;
                        st <= r_send_failure;
                    end
                
                end
                else if((cmd == ERASE_QSPI_64KB) || (cmd == ERASE_QSPI_32KB) || (cmd == ERASE_QSPI_4KB) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if((data_length!=6)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        qspi_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        addrB_db <= addrB_db + 1;
                        st_temp <= r_qspi_erase1;
                        wait_cnt <= 0;
                        st <= r_wait;
                    end 
                end
                else if((cmd==TRANS_SDRAM_TO_QSPI)&& (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                   if((data_length!=12)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        sdram_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                        addrB_db <= addrB_db + 1;
                        st_temp <= r_qspi_trans1;
                        wait_cnt <= 0;
                        st <= r_wait;
                    end  
                end
                else if((cmd==RD_QSPI_WR_SDRAM)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                     if((data_length!=12)) begin
                         data_length_error <= 1'b1;
                         st <= r_send_failure;
                     end
                     else begin
                         sdram_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                         addrB_db <= addrB_db + 1;
                         st_temp <= r_qspi_trans3;
                         wait_cnt <= 0;
                         st <= r_wait;
                     end  
                end    
                else if((cmd== TEMPERATURE_WR_QSPI)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                     if((data_length!=12)) begin
                         data_length_error <= 1'b1;
                         st <= r_send_failure;
                     end
                     else begin
                         sdram_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                         addrB_db <= addrB_db + 1;
                         st_temp <= r_qspi_trans5;
                         wait_cnt <= 0;
                         st <= r_wait;
                     end 
                end
//                else if(((cmd== LOW_TEMP_SENSOR_INIT_WR_QSPI) || (cmd== HIGH_TEMP_SENSOR_INIT_WR_QSPI))&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
//                    qspi_sensor_init_wr_enable <= 1'b1;
//                    resp_cmd <= cmd;
//                    resp_data_length <= 0;
//                    st <= r_send_success;  
//                    if(cmd== LOW_TEMP_SENSOR_INIT_WR_QSPI)begin 
//                        low_high_sel <= 1'b0;
//                    end 
//                    else begin
//                        low_high_sel <= 1'b1;
//                    end    
                    
//                end    
                else if(((cmd== TEMP_RANGE6_SENSOR_INIT_WR_QSPI)||(cmd== TEMP_RANGE5_SENSOR_INIT_WR_QSPI)||(cmd== TEMP_RANGE4_SENSOR_INIT_WR_QSPI)||(cmd== TEMP_RANGE3_SENSOR_INIT_WR_QSPI)||(cmd== TEMP_RANGE2_SENSOR_INIT_WR_QSPI)||(cmd== TEMP_RANGE1_SENSOR_INIT_WR_QSPI)|| (cmd== TEMP_RANGE0_SENSOR_INIT_WR_QSPI))&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                    qspi_sensor_init_wr_enable <= 1'b1;
                    resp_cmd <= cmd;
                    resp_data_length <= 0;
                    st <= r_send_success;  
                    if(cmd== TEMP_RANGE6_SENSOR_INIT_WR_QSPI)begin 
                        sel_temp_range <= 3'b110;
                    end   
                    else if(cmd== TEMP_RANGE5_SENSOR_INIT_WR_QSPI)begin 
                        sel_temp_range <= 3'b101;
                    end 
                    else if(cmd== TEMP_RANGE4_SENSOR_INIT_WR_QSPI)begin 
                        sel_temp_range <= 3'b100;
                    end                                                           
                    else if(cmd== TEMP_RANGE3_SENSOR_INIT_WR_QSPI)begin 
                        sel_temp_range <= 3'b011;
                    end 
                    else if(cmd== TEMP_RANGE2_SENSOR_INIT_WR_QSPI)begin 
                        sel_temp_range <= 3'b010;
                    end 
                    else if(cmd== TEMP_RANGE1_SENSOR_INIT_WR_QSPI)begin 
                        sel_temp_range <= 3'b001;
                    end 
                    else if(cmd== TEMP_RANGE0_SENSOR_INIT_WR_QSPI)  begin
                        sel_temp_range <= 3'b00;
                    end    
                    else begin
                        sel_temp_range <= 3'b000;   
                    end    
                    
                end
                else if((cmd == SAVE_OLED_SETTINGS)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                    if(product_sel == 1'b0)begin
                     qspi_oled_init_wr_enable <= 1'b1;
                    end
                    else begin
                     qspi_oled_init_wr_enable <= 1'b0;
                    end 
                    resp_cmd         <= cmd;
                    resp_data_length <= 0;
                    st <= r_send_success;                        
                end
                else if(((cmd== MARK_BADPIX) || (cmd== UNMARK_BADPIX))&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin
                    if((data_length!=0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        if(cmd== MARK_BADPIX)begin
                            mark_bp_en   <= 1'b1;
                            unmark_bp_en <= 1'b0;
                        end
                        else begin
                             mark_bp_en   <= 1'b0;
                             unmark_bp_en <= 1'b1;                       
                        end                       
                        mark_bp_error<= 1'b0;
                        unmark_bp_error<= 1'b0;                        
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;
                    end                
                end 
                else if((cmd== SAVE_USER_SETTINGS)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin                           
                    if((data_length!=0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        save_user_settings_en <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;                                  
                    end
                
                
                end
                else if((cmd== SWITCH_TO_FACTORY_SETTINGS)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin                           
                    if((data_length!=0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        switch_to_factory_settings_en <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;                                  
                    end
                end
                else if((cmd== LOAD_USER_SETTINGS)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin                           
                    if((data_length!=0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        load_user_settings_en <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;                                  
                    end
                end 
                else if((cmd== LOAD_FACTORY_SETTINGS)&& (cmd_type == (8'h77) || cmd_type == (8'h57)))begin                           
                    if((data_length!=0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
                        load_factory_settings_en <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;                                  
                    end
                end                                                   
                else if((cmd==QSPI_STATUS_CMD) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if((data_length!=0)) begin
                        data_length_error <= 1'b1;
                        st <= r_send_failure;
                    end
                    else begin
//                        diA_rdb <= {23'd0,ch_img_rd_qspi_wr_sdram_en,qspi_sensor_init_wr_enable,qspi_temperature_wr_enable, rd_qspi_wr_sdram_enable,qspi_sdram_trans_enable,qspi_erase_enable, qspi_erase_64KB_enable,qspi_erase_32KB_enable,qspi_erase_4KB_enable};
//                        diA_rdb <= {15'd0,load_user_settings_en,load_factory_settings_en,switch_to_factory_settings_en | switch_to_factory_settings_en_d,save_user_settings_en |qspi_user_settings_trans_en ,unmark_bp_error,unmark_bp_en,mark_bp_error,mark_bp_en,ch_img_rd_qspi_wr_sdram_en,qspi_sensor_init_wr_enable,qspi_temperature_wr_enable, rd_qspi_wr_sdram_enable,qspi_sdram_trans_enable,qspi_erase_enable, qspi_erase_64KB_enable,qspi_erase_32KB_enable,qspi_erase_4KB_enable};
                        diA_rdb <= {av_wrsdram_write,DMA_WRITE_FREE,qspi_sector_erase_rq,qspi_busy,                                             // 4
//                                    mark_bp_st,  //4
                                    qspi_oled_init_wr_enable,qspi_oled_init_wr_enable_latch,qspi_temperature_wr_enable,qspi_temperature_wr_enable_d, // 4       
                                    qspi_send_busy,qspi_page_wr_rq,qspi_sdram_trans_st,                                                         // 8        
                                    av_rdsdram_read,av_rdsdram_waitrequest,av_rdsdram_readdatavalid,unmark_bp_error,                            // 4
                                    unmark_bp_en,mark_bp_error,mark_bp_en,ch_img_rd_qspi_wr_sdram_en,                                           // 4
                                    qspi_sensor_init_wr_enable,qspi_temperature_wr_enable, rd_qspi_wr_sdram_enable,qspi_sdram_trans_enable,     // 4
                                    qspi_erase_enable, qspi_erase_64KB_enable,qspi_erase_32KB_enable,qspi_erase_4KB_enable};                    // 4
                        addrA_rdb <= 0;
                        we_rdb <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 4;
                        st <= r_send_success;
                    end
                end         
            end
            r_take_action2: begin
                // av_wrsdram_writedata <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                if (({cmd[16-1:12], 12'h0} == FPGA_RD_REGS) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    av_fpga_read_r <= (!read_done);
                    if ((!av_fpga_waitrequest_r)) begin
                        av_fpga_read_r <= 1'b0;
                        read_done <= 1'b1;
                    end
                    if (av_fpga_readdatavalid_r) begin
                        read_done <= 1'b0;
                        addrA_rdb <= 0;
                        diA_rdb <= {av_fpga_readdata_r[8-1:0], av_fpga_readdata_r[16-1:8], av_fpga_readdata_r[24-1:16], av_fpga_readdata_r[32-1:24]};
                        we_rdb <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 4;
                        st <= r_send_success;
                    end
                end
                else if (({cmd[16-1:12], 12'h0} == FPGA_WR_REGS) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    av_fpga_write_r <= 1'b1;
                    if ((!av_fpga_waitrequest_r)) begin
                        av_fpga_write_r <= 1'b0;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;
                    end
                end
                else if ((cmd == SET_SDRAM_DATA) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if ((addr_count == data_length)) begin
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;
                    end
                    else begin

                        if(addrB_db<data_length[16-1:2]-1 && !sdram_fifo_prog_full) begin
                            addrB_db <= (addrB_db + 1);
                            fifo_wr_en[0] <= 1'b1;
                        end

                        if(!sdram_fifo_empty && !sdram_fifo_rst_busy) begin 
                            if ((max_burst_c > 0)) begin
                                max_burst_c <= (max_burst_c - 1);
                                av_wrsdram_burstcount <= 4;
                                burst_count <= 4;
                            end
                            else begin
                                av_wrsdram_burstcount <= low_burst_c;
                                burst_count <= low_burst_c;
                            end
                            av_wrsdram_address <= (sdram_addr + addr_count);
                            av_wrsdram_write <= 1'b1;
                            av_wrsdram_writedata <= sdram_fifo_dout;
                            av_wrsdram_writeburst <= 1'b1;
                            // sdram_fifo_rd_en <= 1'b1;
                            st <= r_take_action3;
                        end
                    end
                end
                else if ((cmd == GET_SDRAM_DATA) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if ((addr_count == read_len)) begin
                        resp_cmd <= cmd;
                        resp_data_length <= read_len;
                        st <= r_send_success;
                    end
                    else begin
                        av_rdsdram_address <= (sdram_addr + addr_count);
                        if ((max_burst_c > 0)) begin
                            max_burst_c <= (max_burst_c - 1);
                            av_rdsdram_burstcount <= 4;
                            burst_count <= 4;
                        end
                        else begin
                            av_rdsdram_burstcount <= low_burst_c;
                            burst_count <= low_burst_c;
                        end
                        av_rdsdram_read <= 1'b1;
                        st <= r_take_action3;
                    end
                end
                // else if ((cmd == SET_I2C)) begin
                //     av_i2c_write <= 1'b1;
                //     if ((!av_i2c_waitrequest)) begin
                //         av_i2c_write <= 1'b0;
                //         resp_cmd <= cmd;
                //         resp_data_length <= 0;
                //         st <= r_send_success;
                //     end
                // end
                // else if ((cmd == GET_I2C)) begin
                //     av_i2c_read <= (!read_done);
                //     if ((!av_i2c_waitrequest)) begin
                //         av_i2c_read <= 1'b0;
                //         read_done <= 1'b1;
                //     end
                //     if (av_i2c_readdatavalid) begin
                //         read_done <= 1'b0;
                //         resp_cmd <= cmd;
                //         resp_data_length <= 1;
                //         we_rdb <= 1'b1;
                //         diA_rdb <= {24'h0, av_i2c_readdata};
                //         st <= r_send_success;
                //     end
                // end
                else if ((cmd == SET_SPI) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
//                    av_spi_write <= 1'b1;
                    av_sensor_write_r <= 1'b1;
                    if ((!av_sensor_waitrequest_r)) begin
//                        av_spi_write <= 1'b0;
                        av_sensor_write_r <= 1'b0;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        st <= r_send_success;
                    end
                end
                else if((cmd ==  GET_SPI) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin 
                    av_sensor_read_r <= (!read_done);
                    if ((!av_sensor_waitrequest_r)) begin
                        av_sensor_read_r <= 1'b0;
                        read_done <= 1'b1;
                    end
                    if (av_sensor_readdatavalid_r) begin
                        read_done <= 1'b0;
                        addrA_rdb <= 0;
                        diA_rdb <= {av_sensor_readdata_r[8-1:0], av_sensor_readdata_r[16-1:8], av_sensor_readdata_r[24-1:16], av_sensor_readdata_r[32-1:24]};
                        we_rdb <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= 4;
                        st <= r_send_success;
                    end
                end                
                else if ((cmd == SET_SD_DATA) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                    if (sd_bus_busy_o) begin
                        send_cnt <= 0;
                        addrB_db <= 0;
                        sd_bus_wr_i <= 1'b0;
                        st_temp <= r_sd_write1;
                        wait_cnt <= 0;
                        st <= r_wait;
                    end
                end
                else if ((cmd == GET_SD_DATA) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                    if (sd_bus_busy_o) begin
                        recv_cnt <= 0;
                        addrA_rdb <= ((2 ** 7) - 1);
                        sd_bus_rd_i <= 1'b0;
                        st <= r_sd_read1;
                    end
                end
            end
            r_take_action3: begin
                   // av_wrsdram_writedata <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                   if ((cmd == SET_SDRAM_DATA) && (cmd_type == (8'h77) || cmd_type == (8'h57))) begin
                       av_wrsdram_write <= 1'b1;
                       if(addrB_db<data_length[16-1:2]-1 && !sdram_fifo_prog_full) begin
                            addrB_db <= (addrB_db + 1);
                            fifo_wr_en[0] <= 1'b1;
                        end
                       if ((!av_wrsdram_waitrequest)) begin
                           av_wrsdram_writedata <= sdram_fifo_dout;
                           av_wrsdram_writeburst <= 1'b0;
                           // sdram_fifo_rd_en <= 1'b1;
                           addr_count <= (addr_count + 4);
                           burst_count <= (burst_count - 1);
                           if ((burst_count == 1)) begin
                               av_wrsdram_write <= 1'b0;
                               // sdram_fifo_rd_en <= 1'b0;
                               st <= r_take_action2;
                           end
                       end
                   end
                   else if ((cmd == GET_SDRAM_DATA) && (cmd_type == (8'h72) || cmd_type == (8'h52))) begin
                       av_rdsdram_read <= (!read_done);
                       if ((!av_rdsdram_waitrequest)) begin
                           av_rdsdram_read <= 1'b0;
                           read_done <= 1'b1;
                       end
                       if (av_rdsdram_readdatavalid) begin
                           addr_count <= (addr_count + 4);
                           burst_count <= (burst_count - 1);
                           diA_rdb <= {av_rdsdram_readdata[8-1:0], av_rdsdram_readdata[16-1:8], av_rdsdram_readdata[24-1:16], av_rdsdram_readdata[32-1:24]};
                           addrA_rdb <= (addrA_rdb + 1);
                           we_rdb <= 1'b1;
                           if ((burst_count == 1)) begin
                               read_done <= 1'b0;
                               st <= r_take_action2;
                           end
                       end
                       else begin
                           we_rdb <= 1'b0;
                       end
                   end
            end
            
            r_qspi_erase : begin
                //qspi_trans_len <= doB_db;
                qspi_erase_enable <= 1'b1;
                resp_cmd <= cmd;
                resp_data_length <= 0;
                st <= r_send_success;                  
            end
            
            
            r_qspi_erase1: begin
//                erase_cnt <= doB_db[8-1:0];
                number_of_erase_block <= {doB_db[8-1:0],doB_db[16-1:8]};
//                qspi_trans_len <= doB_db;
                qspi_erase_64KB_enable <= !cmd[1] & !cmd[0];
                qspi_erase_32KB_enable <= !cmd[1] & cmd[0];
                qspi_erase_4KB_enable  <= cmd[1] & cmd[1];
                resp_cmd <= cmd;
                resp_data_length <= 0;
                st <= r_send_success;
            end 
            
            r_qspi_trans1: begin
                qspi_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                addrB_db <= addrB_db + 1;
                st_temp <= r_qspi_trans2;
                wait_cnt <= 0;
                st <= r_wait;
            end
            r_qspi_trans2: begin
                qspi_trans_len <= {8'd0,doB_db[8-1:0], doB_db[16-1:8], doB_db[24-1:16]};
                if(doB_db[32-1:24]!=0) begin
                    st <= r_send_failure;
                    data_error <= 1'b1;
                end
                else begin
                    qspi_sdram_trans_enable <= 1'b1;
                    resp_cmd <= cmd;
                    resp_data_length <= 0;
                    st <= r_send_success; 
                end
            end           

            r_qspi_trans3: begin
                qspi_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                addrB_db <= addrB_db + 1;
                st_temp <= r_qspi_trans4;
                wait_cnt <= 0;
                st <= r_wait;
            end
            r_qspi_trans4: begin
                qspi_trans_len <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                if(doB_db[32-1:24]!=0) begin
                    st <= r_send_failure;
                    data_error <= 1'b1;
                end
                else begin
                    rd_qspi_wr_sdram_enable <= 1'b1;
                    resp_cmd <= cmd;
                    resp_data_length <= 0;
                    st <= r_send_success; 
                end
            end            
            r_qspi_trans5:begin
                qspi_addr <= {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};
                addrB_db <= addrB_db + 1;
                st_temp <= r_qspi_trans6;
                wait_cnt <= 0;
                st <= r_wait;
            end
            r_qspi_trans6: begin
                qspi_trans_len <= {8'd0,doB_db[8-1:0], doB_db[16-1:8], doB_db[24-1:16]};
                if(doB_db[32-1:24]!=0) begin
                    st <= r_send_failure;
                    data_error <= 1'b1;
                end
                else begin
                    qspi_temperature_wr_enable <= 1'b1;
                    resp_cmd <= cmd;
                    resp_data_length <= 0;
                    st <= r_send_success; 
                end
            end                       
 

 
           
            r_sd_write1: begin
                if (sd_bus_hndShk_o) begin
                    sd_bus_hndShk_i <= 1'b1;
                    if ((send_cnt[2-1:0] == 0)) begin
                        sd_bus_data_i <= doB_db[8-1:0];
                    end
                    else if ((send_cnt[2-1:0] == 1)) begin
                        sd_bus_data_i <= doB_db[16-1:8];
                    end
                    else if ((send_cnt[2-1:0] == 2)) begin
                        sd_bus_data_i <= doB_db[24-1:16];
                    end
                    else begin
                        sd_bus_data_i <= doB_db[32-1:24];
                    end
                    st <= r_sd_write2;
                end
                if ((!sd_bus_busy_o)) begin
                    sd_card_error <= 1'b1;
                    st <= r_send_failure;
                end
            end
            r_sd_write2: begin
                if ((!sd_bus_hndShk_o)) begin
                    sd_bus_hndShk_i <= 1'b0;
                    send_cnt <= (send_cnt + 1);
                    if (($signed({1'b0, send_cnt}) == (512 - 1))) begin
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        send_cnt <= 0;
                        st <= r_send_success;
                    end
                    else begin
                        if ((send_cnt[2-1:0] == 3)) begin
                            addrB_db <= (addrB_db + 1);
                            wait_cnt <= 0;
                            st_temp <= r_sd_write1;
                            st <= r_wait;
                        end
                        else begin
                            st <= r_sd_write1;
                        end
                    end
                end
                if ((!sd_bus_busy_o)) begin
                    sd_card_error <= 1'b1;
                    st <= r_send_failure;
                end
            end
            r_sd_read1: begin
                if (sd_bus_hndShk_o) begin
                    if ((recv_cnt[2-1:0] == 0)) begin
                        diA_rdb[8-1:0] <= sd_bus_data_o;
                    end
                    else if ((recv_cnt[2-1:0] == 1)) begin
                        diA_rdb[16-1:8] <= sd_bus_data_o;
                    end
                    else if ((recv_cnt[2-1:0] == 2)) begin
                        diA_rdb[24-1:16] <= sd_bus_data_o;
                    end
                    else begin
                        diA_rdb[32-1:24] <= sd_bus_data_o;
                    end
                    if ((recv_cnt[2-1:0] == 3)) begin
                        addrA_rdb <= (addrA_rdb + 1);
                        we_rdb <= 1'b1;
                    end
                    else begin
                        we_rdb <= 1'b0;
                    end
                    sd_bus_hndShk_i <= 1'b1;
                    st <= r_sd_read2;
                end
                if ((!sd_bus_busy_o)) begin
                    sd_card_error <= 1'b1;
                    st <= r_send_failure;
                end
            end
            r_sd_read2: begin
                we_rdb <= 1'b0;
                if ((!sd_bus_hndShk_o)) begin
                    sd_bus_hndShk_i <= 1'b0;
                    recv_cnt <= (recv_cnt + 1);
                    if (($signed({1'b0, recv_cnt}) == (512 - 1))) begin
                        recv_cnt <= 0;
                        resp_cmd <= cmd;
                        resp_data_length <= 512;
                        st <= r_send_success;
                    end
                    else begin
                        st <= r_sd_read1;
                    end
                end
                if ((!sd_bus_busy_o)) begin
                    sd_card_error <= 1'b1;
                    st <= r_send_failure;
                end
            end
            r_i2c_set_cmd1: begin
                if ((send_cnt[2-1:0]==0)) begin
                    if(av_i2c_data_16_en==1) begin
                        av_i2c_writedata <= {doB_db[32-1:24],doB_db[24-1:16]};
                    end else begin
                        av_i2c_writedata <= doB_db[24-1:16];
                    end
                end
                else if ((send_cnt[2-1:0]==1)) begin
                    av_i2c_writedata <= doB_db[32-1:24];
                end
                else if ((send_cnt[2-1:0]==2)) begin
                    av_i2c_writedata <= doB_db[8-1:0];
                end
                else begin
                    av_i2c_writedata <= doB_db[16-1:8];
                end
                av_i2c_write <= 1'b1;
                st <= r_i2c_set_cmd2;
            end
            r_i2c_set_cmd2: begin
                if (av_i2c_waitrequest) begin
                    st <=r_i2c_set_cmd3;
                    // if (($signed({1'b0,send_cnt}) == ($signed({1'b0, burst_count}) -1))) begin
                    //     av_i2c_write <= 1'b0;
                    // end
                end
            end
            r_i2c_set_cmd3: begin
                if ((!av_i2c_waitrequest)) begin
                    send_cnt <= (send_cnt + 1);
                    if (($signed({1'b0,send_cnt}) == ($signed({1'b0, burst_count}) -1))) begin
                        av_i2c_write <= 1'b0;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        send_cnt <= 0;
                        st <= r_send_success;
                        av_i2c_data_16_en <= 1'b0;
                    end
                    else begin
                        if ((send_cnt[2-1:0]==1)) begin
                            addrB_db <= (addrB_db + 1);
                            wait_cnt <= 0;
                            st_temp <= r_i2c_set_cmd1;
                            st <= r_wait;
                        end
                        else begin
                            st <= r_i2c_set_cmd1;
                        end
                    end
                end
            end
            r_i2c_get_cmd1: begin
                we_rdb <= 1'b0;
                if (av_i2c_waitrequest) begin
                    st <= r_i2c_get_cmd2;
                    // if (($signed({1'b0, recv_cnt}) == ($signed({1'b0, burst_count}) - 1))) begin
                    //     av_i2c_read <= 1'b0;
                    // end
                end
            end
            r_i2c_get_cmd2: begin
                if ((!av_i2c_waitrequest)) begin
                    if ((recv_cnt[2-1:0]==0)) begin
                        diA_rdb[8-1:0] <= av_i2c_readdata[7:0];
                        diA_rdb[16-1:8]<= av_i2c_readdata[15:8];
                    end
                    else if ((recv_cnt[2-1:0]==1)) begin
                        diA_rdb[16-1:8] <= av_i2c_readdata;                       
                    end
                    else if ((recv_cnt[2-1:0]==2)) begin
                        diA_rdb[24-1:16] <= av_i2c_readdata;
                    end
                    else begin
                        diA_rdb[32-1:24] <= av_i2c_readdata;
                    end
                    if ((recv_cnt[2-1]==3)) begin
                        addrA_rdb <= (addrA_rdb + 1);
                        we_rdb <= 1'b1;
                    end
                    else begin
                        we_rdb <=1'b0;
                    end
                    if (($signed({1'b0, recv_cnt}) == ($signed({1'b0, burst_count}) - 1))) begin
                        recv_cnt <= 0;
                        av_i2c_read <= 1'b0;
                        addrA_rdb <= (addrA_rdb + 1);
                        we_rdb <= 1'b1;
                        resp_cmd <= cmd;
                        if(av_i2c_data_16_en==1) begin
                            resp_data_length <= burst_count  << 1;
                        end else begin
                            resp_data_length <= burst_count;
                        end
                        st <= r_send_success;
                        av_i2c_data_16_en <= 1'b0;
                    end
                    else begin
                        recv_cnt <= (recv_cnt + 1);
                        st <= r_i2c_get_cmd1;
                    end
                end
            end
            r_take_snapshot1: begin 
              if(snapshot_image_numbers<1 || (snapshot_image_numbers>TOTAL_FRAME_BUFFERS<<1)) begin 
                data_error <= 1'b1;
                st <= r_send_failure;
              end
//              else if((snapshot_channel==0 || snapshot_channel==1) && snapshot_image_numbers>TOTAL_FRAME_BUFFERS) begin
              else if((snapshot_channel==0 || snapshot_channel==1 || snapshot_channel==3) && snapshot_image_numbers>TOTAL_FRAME_BUFFERS) begin
                data_error <= 1'b1;
                st <= r_send_failure;
              end 
              else begin
                if(snapshot_mode==4) begin 
                  qspi_addr <= {20'h000A0, 1'b0, snapshot_channel, snapshot_image_numbers};
                end
                else begin
                  qspi_addr <= 32'h000A_0000;
                end
                snapshot_trigger <= 1'b1;
                st <= r_take_snapshot2;
              end
            end
            r_take_snapshot2: begin 
              snapshot_trigger <= 1'b0;
              if(snapshot_done) begin 
                if(snapshot_mode==3||snapshot_mode>=4'h8) begin 
                  st <= r_send_success;
                end
                else begin 
                  st <= r_qspi_erase;  
                end                
              end
            end
            r_sensor_i2c_set_cmd1: begin
                if ((send_cnt[2-1:0]==0)) begin
                    av_sensor_i2c_writedata <= doB_db[32-1:24];
                end
                else if ((send_cnt[2-1:0]==1)) begin
                    av_sensor_i2c_writedata <= doB_db[8-1:0];
                end
                else if ((send_cnt[2-1:0]==2)) begin
                    av_sensor_i2c_writedata <= doB_db[16-1:8];
                end
                else begin
                    av_sensor_i2c_writedata <= doB_db[24-1:16];
                end
                av_sensor_i2c_write <= 1'b1;
                st <= r_sensor_i2c_set_cmd2;
            end
            r_sensor_i2c_set_cmd2: begin
                if (av_sensor_i2c_waitrequest) begin
                    st <=r_sensor_i2c_set_cmd3;
                    // if (($signed({1'b0,send_cnt}) == ($signed({1'b0, burst_count}) -1))) begin
                    //     av_i2c_write <= 1'b0;
                    // end
                end
            end
            r_sensor_i2c_set_cmd3: begin
                if ((!av_sensor_i2c_waitrequest)) begin
                    send_cnt <= (send_cnt + 1);
                    if (($signed({1'b0,send_cnt}) == ($signed({1'b0, burst_count}) -1))) begin
                        av_sensor_i2c_write <= 1'b0;
                        resp_cmd <= cmd;
                        resp_data_length <= 0;
                        send_cnt <= 0;
                        st <= r_send_success;
                    end
                    else begin
                        if ((send_cnt[2-1:0]==0)) begin
                            addrB_db <= (addrB_db + 1);
                            wait_cnt <= 0;
                            st_temp <= r_sensor_i2c_set_cmd1;
                            st <= r_wait;
                        end
                        else begin
                            st <= r_sensor_i2c_set_cmd1;
                        end
                    end
                end
            end
            r_sensor_i2c_get_cmd1: begin
                we_rdb <= 1'b0;
                if (av_sensor_i2c_waitrequest) begin
                    st <= r_sensor_i2c_get_cmd2;
                    // if (($signed({1'b0, recv_cnt}) == ($signed({1'b0, burst_count}) - 1))) begin
                    //     av_i2c_read <= 1'b0;
                    // end
                end
            end
            r_sensor_i2c_get_cmd2: begin
                if ((!av_sensor_i2c_waitrequest)) begin
                    if ((recv_cnt[2-1:0]==0)) begin
                        diA_rdb[8-1:0] <= av_sensor_i2c_readdata;
                    end
                    else if ((recv_cnt[2-1:0]==1)) begin
                        diA_rdb[16-1:8] <= av_sensor_i2c_readdata;
                    end
                    else if ((recv_cnt[2-1:0]==2)) begin
                        diA_rdb[24-1:16] <= av_sensor_i2c_readdata;
                    end
                    else begin
                        diA_rdb[32-1:24] <= av_sensor_i2c_readdata;
                    end
                    if ((recv_cnt[2-1]==3)) begin
                        addrA_rdb <= (addrA_rdb + 1);
                        we_rdb <= 1'b1;
                    end
                    else begin
                        we_rdb <=1'b0;
                    end
                    if (($signed({1'b0, recv_cnt}) == ($signed({1'b0, burst_count}) - 1))) begin
                        recv_cnt <= 0;
                        av_i2c_read <= 1'b0;
                        addrA_rdb <= (addrA_rdb + 1);
                        we_rdb <= 1'b1;
                        resp_cmd <= cmd;
                        resp_data_length <= burst_count;
                        st <= r_send_success;
                    end
                    else begin
                        recv_cnt <= (recv_cnt + 1);
                        st <= r_sensor_i2c_get_cmd1;
                    end
                end
            end
            r_send_success: begin
                we_rdb <= 1'b0;
                we_db <= 1'b0;
                timeout_count <= 0;
                cmd_status <= 8'h00;
                st <= r_response_packet;
            end
            r_send_failure: begin
               resp_cmd <= cmd;
               if(uart_data_timeout_error)begin
                 cmd_status <= 8'hF;
               end  
               else if(crc_error) begin
                 cmd_status <= 8'h1;
               end
               else if(footer_error) begin 
                 cmd_status <= 8'h2;
               end
               else if(sd_card_error) begin 
                 cmd_status <= 8'h3;
               end
               else if(data_length_error) begin 
                 cmd_status <= 8'h4;
               end
               else if(cmd_type_error || cmd_error) begin 
                 cmd_status <= 8'h5;
               end
               else if(devno_error || devid_error) begin 
                 cmd_status <= 8'h6;
               end
               else if(data_error)begin
                 cmd_status <= 8'h7;
               end
               else begin 
                 cmd_status <= 8'hD;
               end   
               uart_data_timeout_error <= 0;     
               data_error <=0;        
               crc_error <= 0;
               footer_error <= 0;
               sd_card_error <= 0;
               data_length_error <= 0;
               cmd_type_error <= 0;
               cmd_error <= 0;
               devno_error <= 0;
               devid_error <= 0;
               resp_data_length <= 0;
               addrA_rdb <= 0;
               we_rdb <= 1'b0;
               diA_rdb <= {26'h0, data_error,sd_card_error, data_length_error, crc_error, devno_error, devid_error};
               st <= r_response_packet;
            end
            r_ping1: begin
                recv_cnt <= ((data_length % 4) + 1);
                addrB_db <= (addrB_db + 1);
                addrA_rdb <= ((2 ** 7) - 1);
                diA_rdb <= doB_db;
                st <= r_ping2;
            end
            r_ping2: begin
                diA_rdb <= doB_db;
                if ((recv_cnt == 0)) begin
                    we_rdb <= 1'b0;
                    addrA_rdb <= 0;
                    addrB_db <= 0;
                    resp_cmd <= cmd;
                    resp_data_length <= data_length;
                    st <= r_send_success;
                end
                else begin
                    recv_cnt <= (recv_cnt - 1);
                    we_rdb <= 1'b1;
                    addrA_rdb <= (addrA_rdb + 1);
                    addrB_db <= (addrB_db + 1);
                end
            end
            r_wait: begin
                if ((wait_cnt == 0)) begin
                    st <= st_temp;
                end
                else begin
                    wait_cnt <= (wait_cnt - 1);
                end
            end
            r_init: begin
                st <= r_adv_reset;
//                 st <= r_sensor_init;
                send_cnt <= 0;
                sensor_trigger <= 1'b1;
                adv_reset_n <=1'b1;
            end
            r_adv_reset: begin
                
                if ((send_cnt == 150)) begin
//                    st <= r_adv_init;
                    st <= r_icm_init;//r_qspi_rd_init;
                   // st <= r_idle;
                    adv_reset_n <=1'b1;
                    // st <= r_sensor_init;
                    send_cnt <= 0;
                end
                else begin
                    adv_reset_n <=1'b0;
                    if (tick_1ms) begin
                        send_cnt <= (send_cnt + 1);
                    end
                end
            end            
//            r_adv_init: begin
//                adv_reset_n <=1'b1;
//                case (send_cnt)
//                    'h0: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_1};
//                        av_i2c_writedata <= ADV_REG_VALUES_1;
//                    end
//                    'h1: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_2};
//                        av_i2c_writedata <= ADV_REG_VALUES_2;
//                    end
//                    'h2: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_3};
//                        av_i2c_writedata <= ADV_REG_VALUES_3;
//                    end
//                    'h3: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_4};
//                        av_i2c_writedata <= ADV_REG_VALUES_4;
//                    end
//                    'h4: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_5};
//                        av_i2c_writedata <= ADV_REG_VALUES_5;
//                    end
//                    'h5: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_6};
//                        av_i2c_writedata <= ADV_REG_VALUES_6;
//                    end
//                    'h6: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_7};
//                        av_i2c_writedata <= ADV_REG_VALUES_7;
//                    end
//                    'h7: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_8};
//                        av_i2c_writedata <= ADV_REG_VALUES_8;
//                    end
//                    'h8: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_9};
//                        av_i2c_writedata <= ADV_REG_VALUES_9;
//                    end
//                    default: begin
//                        av_i2c_address <= {ADV_DEV_ADDRESS, ADV_REG_ADDRESS_9};
//                        av_i2c_writedata <= ADV_REG_VALUES_9;
//                    end
//                endcase
//                av_i2c_write <= 1'b1;
//                if(av_i2c_waitrequest) begin 
//                    av_i2c_write <= 1'b0;
//                    st <= r_adv_init2;
//                end
//            end
//            r_adv_init2: begin
//                av_wrsdram_writedata <= doB_db;
//                if ((!av_i2c_waitrequest)) begin
//                    av_i2c_write <= 1'b0;
//                    if (($signed({1'b0, send_cnt}) == (9 - 1))) begin
//                        send_cnt <= 0;
//                        //st <= r_sensor_init;
//                        st <= r_qspi_rd_init;//r_qspi_rd;//r_sdram_write1;
//                        //st <= r_idle;
//                    end
//                    else begin
//                        send_cnt <= (send_cnt + 1);
//                        st <= r_adv_init;
//                    end
//                end
//            end


           r_icm_init: begin
               case (send_cnt)
                   'h00: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h7F};
                       av_i2c_writedata <= 8'h00;
                   end
                   'h01: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h03};
                       av_i2c_writedata <= 8'h00;
                   end
                   'h02: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h06};
                       av_i2c_writedata <= 8'h05;
                   end
                   'h03: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h07};
                       av_i2c_writedata <= 8'h00;
                   end
                   'h04: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h67};
                       av_i2c_writedata <= 8'h1F;
                   end                   
                   'h05: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h69};
                       av_i2c_writedata <= 8'h00;
                   end 
                   'h06: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h7F};
                       av_i2c_writedata <= 8'h20;
                   end 
                   'h07: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h00};
                       av_i2c_writedata <= 8'h22;
                   end                                       
                   'h08: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h01};
                       av_i2c_writedata <= 8'h1F;
                   end 
                   'h09: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h10};
                       av_i2c_writedata <= 8'h00;
                   end 
                   'h0A: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h11};
                       av_i2c_writedata <= 8'h71;
                   end   
                   'h0B: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h14};
                       av_i2c_writedata <= 8'h1F;
                   end 
                   'h0C: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h12};
                       av_i2c_writedata <= 8'h03;
                   end 
                   'h0D: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h15};
                       av_i2c_writedata <= 8'h03;
                   end   
                   'h0E: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h53};
                       av_i2c_writedata <= 8'h05;
                   end 
                   'h0F: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h7F};
                       av_i2c_writedata <= 8'h00;
                   end 
                   'h10: begin
                       av_i2c_address <= {ICM_DEV_ADDRESS, 8'h0F};
                       av_i2c_writedata <= 8'h02;
                   end                                         
                   'h11: begin
                       av_i2c_address <= {MAGNETO_DEV_ADDRESS, 8'h32};
                       av_i2c_writedata <= 8'h01;
                   end                                                                          
                   'h12: begin
                       av_i2c_address <= {MAGNETO_DEV_ADDRESS, 8'h31};
                       av_i2c_writedata <= 8'h06;
                   end  

                   default: begin
                       av_i2c_address <= {MAGNETO_DEV_ADDRESS, 8'h31};
                       av_i2c_writedata <= 8'h06;
                   end
               endcase
               av_i2c_write <= 1'b1;
               if(av_i2c_waitrequest) begin 
                   av_i2c_write <= 1'b0;
                   st <= r_icm_init2;
               end
           end
           r_icm_init2: begin
               if ((!av_i2c_waitrequest)) begin
                   av_i2c_write <= 1'b0;
                   if (($signed({1'b0, send_cnt}) == (19 - 1))) begin
                       send_cnt <= 0;
                       st <= r_qspi_rd_init;//r_qspi_rd;//r_sdram_write1;
                   end
                   else begin
                       send_cnt <= (send_cnt + 1);
                       st <= r_icm_init;
                   end
               end
           end


            r_sdram_write1: begin
                if(sdram_write_byte_cnt == 256)begin
                    st <= r_qspi_rd; 
                    sdram_write_byte_cnt <= 0;   
                end
                else begin
                    sdram_write_byte_cnt <= sdram_write_byte_cnt + 4;
                    st <= r_sdram_write2;
                    sdram_write_data <= sdram_write_data;
                    if(sdram_write_byte_cnt==0)begin
                        sdram_write_addr <= sdram_send_adddr;//32'h00f00000;
                    end
                    else begin
                        sdram_write_addr <= sdram_write_addr + 4; 
                    end               
                end                           
            end           
            r_sdram_write2: begin
                av_wrsdram_address    <= sdram_write_addr;  
                av_wrsdram_burstcount <= 1;
                av_wrsdram_write      <= 1'b1;
                av_wrsdram_writeburst <= 1'b1;
                av_wrsdram_writedata  <= sdram_write_data;//32'hAABBCCDD;
                burst_count           <= 1;
                st <= r_sdram_write3;
            end
            r_sdram_write3: begin    
                av_wrsdram_write      <= 1'b1;
                if ((!av_wrsdram_waitrequest)) begin
                    av_wrsdram_writeburst <= 1'b0;
                    av_wrsdram_writedata  <= 0;//32'h11223344;
                    burst_count <= (burst_count - 1);
                    if ((burst_count == 1)) begin
                        av_wrsdram_write <= 1'b0;
                        st <= r_qspi_rd1;
                    end
                end
            end
            
            r_qspi_rd: begin
                if(data_trans_len_d > 0 )begin
                    qspi_mem_rd_rq    <= 1'b1;
                    qspi_send_addr    <= src_address_d;
                    sdram_send_adddr  <= dest_address_d;
                    qspi_send_rd_size <= qspi_block_rd_size;
                    qspi_send_cmd     <= `CMD_READ;
                    if(qspi_send_busy)begin
                         if(data_trans_len_d > qspi_block_rd_size)begin
                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
                         end
                         else begin
                            data_trans_len_d  <= 0;
                         end
                         src_address_d     <= src_address_d  + qspi_block_rd_size;
                         dest_address_d    <= dest_address_d + qspi_block_rd_size;
                         st                <= r_qspi_rd1;
                         sdram_send_adddr  <= sdram_send_adddr;
                         qspi_mem_rd_rq    <= 1'b0; 
                         qspi_send_addr    <= 32'h00000000;  
                         //qspi_send_rd_size <= 0;
                         qspi_send_cmd     <= 8'd0;   
                    end
                end
                else begin
                    st                <= r_qspi_rd_init;
                    data_trans_len_d  <= 0;
                    sdram_send_adddr  <= 0;
                    qspi_mem_rd_rq    <= 0;
                    qspi_send_rd_size <= 0;
                    qspi_send_cmd     <= 0; 
                    gain_wr_done      <= 1'b1;          
                end       
            end
            r_qspi_rd1 : begin
                if(!qspi_send_busy)begin
                    if(temp_qspi_read_cnt == qspi_block_rd_size)begin
                        st <= r_qspi_rd;
                        temp_qspi_read_cnt <=0;
                        sdram_write_byte_cnt<=0;  
                    end
                    else begin
                        st <= r_qspi_rd1;
                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
                            
                            if(qspi_rd_cnt == 3)begin
                                qspi_rx_rd_fifo_rq <= 1'b0;  
                            end
                            if(qspi_rd_cnt == 4)begin
                                qspi_rd_cnt <= 0;
                                st <= r_sdram_write1;
                                temp_qspi_read_cnt<= temp_qspi_read_cnt +4; 
                                sdram_write_data <= sdram_write_data;
                            end
                            else begin
                                sdram_write_data <= {qspi_rx_rd_fifo_data,sdram_write_data[31:8]};
                                qspi_rd_cnt <= qspi_rd_cnt +1;
                                
                            end 
                        end
                        else begin
                                qspi_rx_rd_fifo_rq <= 1'b1;
                        end
                     end          
                end
            end
            r_qspi_rd_init :begin
                if(qspi_init_done)begin
                    if(!qspi_send_busy)begin
                        st  <= r_qspi_rd_init1;
                        
                    end
                    else begin
                        st  <= r_qspi_rd_init; 
                    end  
                end
            end
            r_qspi_rd_init1: begin
                qspi_mem_rd_rq        <= 1'b1;
                qspi_send_addr        <= qspi_init_st_addr_reg;
                qspi_send_rd_size     <= qspi_init_rd_len;
                qspi_send_cmd         <= `CMD_READ;
                 if(qspi_send_busy)begin
                     st                <= r_qspi_rd_init2;
                     qspi_mem_rd_rq    <= 1'b0; 
                     qspi_send_addr    <= 32'h00000000;
                     qspi_init_st_addr_reg <= qspi_init_st_addr_reg + 14;
                     //qspi_send_rd_size <= 0;
                     qspi_send_cmd     <= 8'd0;   
                 end          
            end 
            r_qspi_rd_init2 : begin
                if(!qspi_send_busy)begin
                    if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 14) )begin
                        if(qspi_rd_cnt == 13)begin
                            qspi_rx_rd_fifo_rq <= 1'b0;
                        end           
                        if(qspi_rd_cnt == 14)begin
                            qspi_rd_cnt <= 0;
                            st <= r_qspi_cmd_decode; 
                        end
                        else if(qspi_rd_cnt < 2)begin
                            c_cmd    <= {qspi_rx_rd_fifo_data,c_cmd[15:8]};
                            qspi_rd_cnt <= qspi_rd_cnt +1;      
                        end
                        else if(qspi_rd_cnt < 6)begin 
                            src_address <= {qspi_rx_rd_fifo_data,src_address[31:8]};
                            qspi_rd_cnt <= qspi_rd_cnt +1; 
                        end
                        else if(qspi_rd_cnt < 10) begin
                            dest_address <= {qspi_rx_rd_fifo_data,dest_address[31:8]};
                            qspi_rd_cnt <= qspi_rd_cnt +1;     
                        end 
                        else if(qspi_rd_cnt < 14)begin
                            data_trans_len <= {qspi_rx_rd_fifo_data,data_trans_len[31:8]};
                            qspi_rd_cnt <= qspi_rd_cnt +1; 
                        end 
                    end
                    else begin
                        qspi_rx_rd_fifo_rq <= 1'b1;
                    end     
                end  
            end
            r_qspi_cmd_decode: begin
                if(c_cmd == RD_QSPI_WR_SDRAM)begin                
                   src_address_d    <= src_address;
                   dest_address_d   <= dest_address;
                   data_trans_len_d <= data_trans_len;
                   st               <= r_qspi_rd;
                   if(product_sel == 1'b1)begin
                       if((logo_frame_wr_cnt == 5'd3))begin
                        BT656_START      <= 1'b1;
                       end
                       else begin
                        logo_frame_wr_cnt<= logo_frame_wr_cnt + 1;
                        BT656_START      <= 1'b0;
                       end 
                   end    
                    // st               <= r_qspi_rd_init;
                end
                else if(c_cmd == RD_QSPI_WR_TEMPERATURE)begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_temperature;            
                end
                else if(c_cmd == RD_QSPI_WR_PRDCT_NAME)begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_prdct_name;            
                end
                else if(c_cmd == RD_QSPI_WR_RETICLE)begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_mux;   
                    time_cnt_Start    <= 1'b1;         
                end
                else if(c_cmd == RD_QSPI_WR_RETICLE_OFFSET )begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_mux;   
                    time_cnt_Start    <= 1'b1;         
                end                
                else if(c_cmd == RD_QSPI_WR_LOGO)begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_mux;   
                    time_cnt_Start    <= 1'b1;         
                end
                else if(c_cmd == RD_QSPI_WR_ADV_PAL)begin
                    if(PAL_nNTSC == 1'b1)begin
                        src_address_d        <= QSPI_ADDR_ADV_PAL_INIT;
                    end
                    else begin
                        src_address_d        <= QSPI_ADDR_ADV_NTSC_INIT;
                    end    
//                    src_address_d        <= QSPI_ADDR_ADV_PAL_INIT;               
                    ADV_OLED_DEV_ADDR    <= dest_address[7:0];
                    ADV_OLED_REG_CNT     <= dest_address[31:16];
                    ADV_REG_CNT          <= dest_address[31:16];
                    ADV_DEV_ADDR         <= dest_address[7:0];
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
                    if(PAL_nNTSC_SEL_DONE == 1'b1)begin
                        st <= r_qspi_rd_mux; 
                    end
                    else begin
                        st <= r_qspi_cmd_decode; 
                    end                  
                    ADV_OLED_REG_WR_CNT  <= 0;
                    time_cnt_Start       <= 1'b1;         
                end
                else if(c_cmd == RD_QSPI_WR_ADV_NTSC)begin
                    src_address_d        <= QSPI_ADDR_ADV_NTSC_INIT;                  
                    ADV_OLED_DEV_ADDR    <= dest_address[7:0];
                    ADV_OLED_REG_CNT     <= dest_address[31:16];
                    ADV_REG_CNT          <= dest_address[31:16];
                    ADV_DEV_ADDR         <= dest_address[7:0];
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
                    if(PAL_nNTSC_SEL_DONE == 1'b1)begin
                        st <= r_qspi_rd_mux; 
                    end
                    else begin
                        st <= r_qspi_cmd_decode; 
                    end                  
                    ADV_OLED_REG_WR_CNT  <= 0;
                    time_cnt_Start       <= 1'b1;         
                end
                else if(c_cmd == RD_QSPI_WR_OLED)begin
                    src_address_d        <= src_address;
                    ADV_OLED_DEV_ADDR    <= dest_address[7:0];
                    ADV_OLED_REG_CNT     <= dest_address[31:16];
                    OLED_REG_CNT         <= dest_address[31:16];
                    OLED_DEV_ADDR        <= dest_address[7:0];
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;
//                    st                   <= r_qspi_rd_mux;                    
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end
                    ADV_OLED_REG_WR_CNT  <= 0;
                    time_cnt_Start       <= 1'b1;         
                end
                else if(c_cmd == RD_QSPI_WR_BATTERY_GAUGE)begin
                    src_address_d        <= src_address;
                    ADV_OLED_DEV_ADDR    <= dest_address[7:0];
                    ADV_OLED_REG_CNT     <= dest_address[31:16];
                    BAT_GAUGE_DEV_ADDR   <= dest_address[7:0];
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
//                    st                   <= r_qspi_rd_mux;   
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end                    
                    ADV_OLED_REG_WR_CNT  <= 0;
                    time_cnt_Start       <= 1'b1;         
                end                                
                else if(c_cmd == RD_QSPI_WR_BATTERY_ADC)begin
                    src_address_d        <= src_address;
                    ADV_OLED_DEV_ADDR    <= dest_address[7:0];
                    ADV_OLED_REG_CNT     <= dest_address[31:16];
                    BAT_ADC_DEV_ADDR     <= dest_address[7:0];
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
//                    st                   <= r_qspi_rd_mux;
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end                       
                    ADV_OLED_REG_WR_CNT  <= 0;
                    time_cnt_Start       <= 1'b1;         
                end                                                
                else if(c_cmd == RD_QSPI_WR_OLED_VGN_ADC)begin
                    src_address_d        <= src_address;
                    ADV_OLED_DEV_ADDR    <= dest_address[7:0];
                    ADV_OLED_REG_CNT     <= dest_address[31:16];
                    OLED_VGN_ADC_DEV_ADDR<= dest_address[7:0];
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
//                    st                   <= r_qspi_rd_mux;
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end                       
                    ADV_OLED_REG_WR_CNT  <= 0;
                    time_cnt_Start       <= 1'b1;         
                end                                
                else if(c_cmd == RD_QSPI_WR_OLED_GAMMA_COEFF)begin
                    src_address_d        <= src_address;
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
//                    st                   <= r_qspi_rd_mux;   
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end
                    time_cnt_Start       <= 1'b1;                    
                end
                else if(c_cmd == RD_QSPI_WR_OLED_CF)begin
                    src_address_d        <= src_address;
                    dest_address_d       <= dest_address;
                    data_trans_len_d     <= data_trans_len;  
//                    st                   <= r_qspi_rd_mux;                      
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end
                end                
                else if(c_cmd == RD_QSPI_WR_OLED_VGN_GAMMA)begin
                    src_address_d        <= src_address;
                    dest_address_d       <= dest_address;
                    vgn_gamma_mem_wr_sel <= dest_address[9:8];
                    data_trans_len_d     <= data_trans_len;  
//                    st                   <= r_qspi_rd_mux;                       
                    if(product_sel == 1'b0)begin  
                     st <= r_qspi_rd_mux;   
                    end
                    else begin
                     st <= r_qspi_rd_init;
                    end
                end
                else if(c_cmd == RD_QSPI_WR_SENSOR_INIT)begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_sensor_init;
                    sensor_init_data_len <= (data_trans_len>>2);            
                end
                else if(c_cmd == RD_QSPI_WR_USER_SETTINGS)begin
                    src_address_d     <= src_address;
                    dest_address_d    <= dest_address;
                    data_trans_len_d  <= data_trans_len;  
                    st                <= r_qspi_rd_user_settings;
                end                
                else if(c_cmd == END_INIT_CMD)begin
                    src_address_d      <= 0;
                    dest_address_d     <= 0;
                    data_trans_len_d   <= 0; 
                    st                 <= r_idle; 
                    qspi_init_cmd_done <= 1'b1;
                    sensor_trigger     <= 1'b0;
                    qspi_reticle_transfer_done <= 1'b1;
                    adv_init_done      <= 1'b1;
                    video_start        <= 1'b1;
                    logo_frame_wr_cnt  <= 5'd0;
                    if(product_sel == 1'b0)begin
                     oled_init_done      <= 1'b1;
                     bat_gauge_init_done <= 1'b1;
                     icm_init_done       <= 1'b1;
                    end
                    else begin
                     oled_init_done      <= 1'b0;
                     bat_gauge_init_done <= 1'b0;
                     icm_init_done       <= 1'b0;
                    end
                    
                end
            end

            r_qspi_rd_mux : begin
               if(data_trans_len_d > 0 )begin
                    qspi_mem_rd_rq    <= 1'b1;
                    qspi_send_addr    <= src_address_d;
                    qspi_send_rd_size <= qspi_block_rd_size;
                    qspi_send_cmd     <= `CMD_READ;
                    if(qspi_send_busy)begin
                         if(data_trans_len_d > qspi_block_rd_size)begin
                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
                         end
                         else begin
                            data_trans_len_d  <= 0;
                         end
                         src_address_d     <= src_address_d  + qspi_block_rd_size;                
                         st                <= r_qspi_rd1_mux;
                         qspi_mem_rd_rq    <= 1'b0; 
                         qspi_send_addr    <= 32'h00000000;  
                         //qspi_send_rd_size <= 0;
                         qspi_send_cmd     <= 8'd0;   
                    end
                end    
                 else begin
                    st                <= r_qspi_rd_init;
                    data_trans_len_d  <= 0;
                    qspi_mem_rd_rq    <= 0;
                    qspi_send_rd_size <= 0;
                    qspi_send_cmd     <= 0;  
                    time_cnt_Start    <= 1'b0; 
                    adv_init_mem_wr_addr_temp <= 0;      
                    oled_init_mem_wr_addr_temp <= 0;
                    oled_gamma_coeff_mem_wr_addr_temp <= 0;
                    oled_vgn_gamma_mem_wr_addr_temp   <= 0;
                    oled_cf_mem_wr_addr_temp          <= 0;
                    if(c_cmd == RD_QSPI_WR_OLED_GAMMA_COEFF)begin
                        oled_gamma_coeff_mem_wr_done <= 1'b1;  
                    end
                end                                      
            end
            
            r_qspi_rd1_mux : begin
                LOGO_WR_EN    <= 1'b0;
                RETICLE_WR_EN <= 1'b0;
                RETICLE_OFFSET_WR_EN <= 1'b0;
                adv_pal_init_mem_wr_req     <= 1'b0;
                adv_ntsc_init_mem_wr_req    <= 1'b0;
                oled_gamma_coeff_mem_wr_req <= 1'b0; 
                oled_cf_mem_wr_req          <= 1'b0; 
                oled_vgn_gamma_mem1_wr_req  <= 1'b0; 
                oled_vgn_gamma_mem2_wr_req  <= 1'b0; 
                oled_vgn_gamma_mem3_wr_req  <= 1'b0; 
                if(!qspi_send_busy)begin
                    if(temp_qspi_read_cnt == qspi_block_rd_size )begin
                        st                 <= r_qspi_rd_mux;
                        temp_qspi_read_cnt <=0;
                    end
                    else begin
                        st <= r_qspi_rd1_mux;             
                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
                            if(qspi_rd_cnt == 3)begin
                                qspi_rx_rd_fifo_rq <= 1'b0;  
                            end
                            if(qspi_rd_cnt == 4)begin
                                qspi_rd_cnt          <= 0;
//                                if(c_cmd == RD_QSPI_WR_ADV || c_cmd == RD_QSPI_WR_OLED || c_cmd == RD_QSPI_WR_BATTERY_GAUGE || c_cmd == RD_QSPI_WR_OLED_VGN_ADC )begin
                                if(c_cmd == RD_QSPI_WR_OLED || c_cmd == RD_QSPI_WR_BATTERY_GAUGE || c_cmd == RD_QSPI_WR_BATTERY_ADC || c_cmd == RD_QSPI_WR_OLED_VGN_ADC )begin
                                    st   <= r_adv_oled_init;
                                end    
                                else if(c_cmd == RD_QSPI_WR_ADV_PAL ||c_cmd == RD_QSPI_WR_ADV_NTSC )begin
                                    st   <= r_adv_init;
                                end
                                else if(c_cmd == RD_QSPI_WR_RETICLE ||  c_cmd == RD_QSPI_WR_LOGO || c_cmd == RD_QSPI_WR_RETICLE_OFFSET)begin
                                    st   <= r_reticle_logo_write;
                                end    
                                else if(c_cmd == RD_QSPI_WR_OLED_GAMMA_COEFF)begin
                                    st   <= r_oled_gamma_write;    
                                end    
                                else if(c_cmd == RD_QSPI_WR_OLED_CF)begin
                                    st   <= r_oled_cf_write;    
                                end
                                else if(c_cmd == RD_QSPI_WR_OLED_VGN_GAMMA)begin
                                    st   <= r_oled_vgn_gamma_write;    
                                end
                                temp_qspi_read_cnt <= temp_qspi_read_cnt +4; 
                                MUX_WR_DATA        <= MUX_WR_DATA;
                            end
                            else begin
                                MUX_WR_DATA <= {qspi_rx_rd_fifo_data,MUX_WR_DATA [31:8]};
                                qspi_rd_cnt <= qspi_rd_cnt +1;
                            end              
                        end
                        else begin
                                qspi_rx_rd_fifo_rq <= 1'b1;
                        end
                     end          
                end            
             end
            
            r_reticle_logo_write: begin
                if(c_cmd == RD_QSPI_WR_RETICLE)begin
                    RETICLE_WR_EN        <= 1'b1;
                    RETICLE_OFFSET_WR_EN <= 1'b0;
                    LOGO_WR_EN           <= 1'b0;
                end
                else if(c_cmd == RD_QSPI_WR_RETICLE_OFFSET)begin
                    RETICLE_WR_EN        <= 1'b0;
                    RETICLE_OFFSET_WR_EN <= 1'b1;
                    LOGO_WR_EN           <= 1'b0;
                end                
                else if(c_cmd == RD_QSPI_WR_LOGO)begin
                    LOGO_WR_EN           <= 1'b1;
                    RETICLE_WR_EN        <= 1'b0;
                    RETICLE_OFFSET_WR_EN <= 1'b0;
                end
                RETICLE_WR_DATA        <= MUX_WR_DATA;
                RETICLE_OFFSET_WR_DATA <= MUX_WR_DATA;
                LOGO_WR_DATA           <= MUX_WR_DATA;
                st                     <= r_qspi_rd1_mux;
            end     

            r_adv_oled_init: begin
                if(ADV_OLED_REG_WR_CNT == ADV_OLED_REG_CNT)begin
                    st <= r_qspi_rd1_mux;
                end
                else begin
                    av_i2c_address   <= {ADV_OLED_DEV_ADDR,MUX_WR_DATA[7: 0]};
                    av_i2c_writedata <= MUX_WR_DATA[23:16];
                    av_i2c_write <= 1'b1;
                    if(c_cmd == RD_QSPI_WR_OLED_VGN_ADC || c_cmd == RD_QSPI_WR_BATTERY_ADC)begin
                        if(MUX_WR_DATA[7: 0] == OLED_VGN_ADC_ALERT_REG_ADDR || MUX_WR_DATA[7: 0]== OLED_VGN_ADC_CONFIG_REG_ADDR)begin
                            av_i2c_data_16_en <= 1'b0;
                        end
                        else begin
                            av_i2c_data_16_en <= 1'b1;
                        end     
                    end
                    
                    if(av_i2c_waitrequest) begin 
                        av_i2c_write <= 1'b0;
                        av_i2c_data_16_en <= 1'b0;
                        st <= r_adv_oled_init2; 
                        ADV_OLED_REG_WR_CNT <= ADV_OLED_REG_WR_CNT +1;
                        if(c_cmd == RD_QSPI_WR_OLED)begin
                            oled_init_mem_wr_req       <= 1'b1;  
                            oled_init_mem_wr_data      <= MUX_WR_DATA;
                            oled_init_mem_wr_addr      <= oled_init_mem_wr_addr_temp; 
                            oled_init_mem_wr_addr_temp <= oled_init_mem_wr_addr_temp +1;
                        end
//                        else if(c_cmd == RD_QSPI_WR_ADV_PAL)begin
//                            adv_init_mem_wr_req       <= 1'b1;  
//                            adv_init_mem_wr_data      <= MUX_WR_DATA;
//                            adv_init_mem_wr_addr      <= adv_init_mem_wr_addr_temp; 
//                            adv_init_mem_wr_addr_temp <= adv_init_mem_wr_addr_temp +1;                        
//                        end   
                    end    
                    else begin
                        st <= r_adv_oled_init;    
                    end          
                end
            end
            
            r_adv_oled_init2: begin
                oled_init_mem_wr_req       <= 1'b0;
//                adv_init_mem_wr_req        <= 1'b0;
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write <= 1'b0;
                    st <= r_qspi_rd1_mux;
                end
            end
            

            r_adv_init: begin
                if(ADV_OLED_REG_WR_CNT == ADV_OLED_REG_CNT)begin
                    st <= r_qspi_rd1_mux;
                    adv_init_mem_wr_addr_temp <= 0;
                end
                else begin
//                    if((PAL_nNTSC== 1'b1 && c_cmd == RD_QSPI_WR_ADV_PAL) ||(PAL_nNTSC == 1'b0 && c_cmd == RD_QSPI_WR_ADV_NTSC) )begin
                        av_i2c_address   <= {ADV_OLED_DEV_ADDR,MUX_WR_DATA[7: 0]};
                        av_i2c_writedata <= MUX_WR_DATA[23:16];
                        av_i2c_write <= 1'b1;
                        if(av_i2c_waitrequest) begin 
                            av_i2c_write              <= 1'b0;
                            av_i2c_data_16_en         <= 1'b0;
                            st                        <= r_adv_init2; 
                            ADV_OLED_REG_WR_CNT       <= ADV_OLED_REG_WR_CNT +1;
//                            if(c_cmd == RD_QSPI_WR_ADV_PAL)begin
                            if((PAL_nNTSC== 1'b1))begin
                                adv_pal_init_mem_wr_req   <= 1'b1;  
                                adv_pal_init_mem_wr_data  <= MUX_WR_DATA;
                                adv_pal_init_mem_wr_addr  <= adv_init_mem_wr_addr_temp; 
                                adv_init_mem_wr_addr_temp <= adv_init_mem_wr_addr_temp +1;   
                            end
                            else begin
                                adv_ntsc_init_mem_wr_req  <= 1'b1;  
                                adv_ntsc_init_mem_wr_data <= MUX_WR_DATA;
                                adv_ntsc_init_mem_wr_addr <= adv_init_mem_wr_addr_temp; 
                                adv_init_mem_wr_addr_temp <= adv_init_mem_wr_addr_temp +1;                              
                            end                      
                        end    
                        else begin
                            st <= r_adv_init;    
                        end    
//                     end
//                     else begin
//                           ADV_OLED_REG_WR_CNT       <= ADV_OLED_REG_WR_CNT +1;
//                           if(c_cmd == RD_QSPI_WR_ADV_PAL)begin
//                                adv_pal_init_mem_wr_req   <= 1'b1;  
//                                adv_pal_init_mem_wr_data  <= MUX_WR_DATA;
//                                adv_pal_init_mem_wr_addr  <= adv_init_mem_wr_addr_temp; 
//                                adv_init_mem_wr_addr_temp <= adv_init_mem_wr_addr_temp +1;   
//                            end
//                            else begin
//                                adv_ntsc_init_mem_wr_req  <= 1'b1;  
//                                adv_ntsc_init_mem_wr_data <= MUX_WR_DATA;
//                                adv_ntsc_init_mem_wr_addr <= adv_init_mem_wr_addr_temp; 
//                                adv_init_mem_wr_addr_temp <= adv_init_mem_wr_addr_temp +1;                              
//                            end                     
//                        st <= r_qspi_rd1_mux;
//                     end                       
                end
            end
            r_adv_init2: begin
//                oled_init_mem_wr_req       <= 1'b0;
                adv_pal_init_mem_wr_req    <= 1'b0;
                adv_ntsc_init_mem_wr_req   <= 1'b0;
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write <= 1'b0;
                    st <= r_qspi_rd1_mux;
                end
            end




            
            r_oled_gamma_write : begin
                oled_gamma_coeff_mem_wr_req       <= 1'b1;  
                oled_gamma_coeff_mem_wr_data      <= MUX_WR_DATA[15:0];
                oled_gamma_coeff_mem_wr_addr      <= oled_gamma_coeff_mem_wr_addr_temp; 
                oled_gamma_coeff_mem_wr_addr_temp <= oled_gamma_coeff_mem_wr_addr_temp +1;  
                st                                <= r_oled_gamma_write1;          
            
            end
            r_oled_gamma_write1 : begin
                oled_gamma_coeff_mem_wr_req       <= 1'b1;  
                oled_gamma_coeff_mem_wr_data      <= MUX_WR_DATA[31:16];
                oled_gamma_coeff_mem_wr_addr      <= oled_gamma_coeff_mem_wr_addr_temp; 
                oled_gamma_coeff_mem_wr_addr_temp <= oled_gamma_coeff_mem_wr_addr_temp +1;          
                st                                <= r_qspi_rd1_mux;            
            end

            r_oled_cf_write : begin
                oled_cf_mem_wr_req       <= 1'b1;  
                oled_cf_mem_wr_data      <= MUX_WR_DATA[15:0];
                oled_cf_mem_wr_addr      <= oled_cf_mem_wr_addr_temp; 
                oled_cf_mem_wr_addr_temp <= oled_cf_mem_wr_addr_temp +1;  
                st                       <= r_oled_cf_write1;          
           
            end
            r_oled_cf_write1 : begin
                oled_cf_mem_wr_req       <= 1'b1;  
                oled_cf_mem_wr_data      <= MUX_WR_DATA[31:16];
                oled_cf_mem_wr_addr      <= oled_cf_mem_wr_addr_temp; 
                oled_cf_mem_wr_addr_temp <= oled_cf_mem_wr_addr_temp +1;          
                st                       <= r_qspi_rd1_mux;            
            end   
      
            r_oled_vgn_gamma_write : begin
                if(vgn_gamma_mem_wr_sel == 2'd2)begin
                    oled_vgn_gamma_mem3_wr_req       <= 1'b1;  
                    oled_vgn_gamma_mem3_wr_data      <= MUX_WR_DATA[19:0];
                    oled_vgn_gamma_mem3_wr_addr      <= oled_vgn_gamma_mem_wr_addr_temp;                 
                end
                else if(vgn_gamma_mem_wr_sel == 2'd1)begin
                    oled_vgn_gamma_mem2_wr_req       <= 1'b1;  
                    oled_vgn_gamma_mem2_wr_data      <= MUX_WR_DATA[19:0];
                    oled_vgn_gamma_mem2_wr_addr      <= oled_vgn_gamma_mem_wr_addr_temp; 
                end
                else if(vgn_gamma_mem_wr_sel == 2'd0)begin
                    oled_vgn_gamma_mem1_wr_req       <= 1'b1;  
                    oled_vgn_gamma_mem1_wr_data      <= MUX_WR_DATA[19:0];
                    oled_vgn_gamma_mem1_wr_addr      <= oled_vgn_gamma_mem_wr_addr_temp;
                end
                else begin
                    oled_vgn_gamma_mem1_wr_req       <= 1'b1;  
                    oled_vgn_gamma_mem1_wr_data      <= MUX_WR_DATA[19:0];
                    oled_vgn_gamma_mem1_wr_addr      <= oled_vgn_gamma_mem_wr_addr_temp;                
                end
                oled_vgn_gamma_mem_wr_addr_temp <= oled_vgn_gamma_mem_wr_addr_temp +1;  
                st                              <= r_qspi_rd1_mux;          
            end         
         
//            r_oled_init: begin
//                if(OLED_REG_WR_CNT == OLED_REG_CNT)begin
//                    st <= r_qspi_rd1_mux;
//                end
//                else begin
//                    av_i2c_address   <= {OLED_DEV_ADDRESS,MUX_WR_DATA[7: 0]};
//                    av_i2c_writedata <= MUX_WR_DATA[23:16];
//                    av_i2c_write <= 1'b1;
//                    if(av_i2c_waitrequest) begin 
//                        av_i2c_write <= 1'b0;
//                        st <= r_oled_init2;
//                        OLED_REG_WR_CNT <= OLED_REG_WR_CNT +1;
//                    end    
//                    else begin
//                        st <= r_oled_init;    
//                    end          
//                end
//            end
            
//            r_oled_init2: begin
//                if ((!av_i2c_waitrequest)) begin
//                    av_i2c_write <= 1'b0;
//                    st <= r_qspi_rd1_mux;
//                end
//            end
            
//            r_adv_init: begin
//                if(ADV_REG_WR_CNT == ADV_REG_CNT)begin
//                    st <= r_qspi_rd1_mux;
//                end
//                else begin
//                    av_i2c_address   <= {ADV_DEV_ADDRESS,MUX_WR_DATA[7: 0]};
//                    av_i2c_writedata <= MUX_WR_DATA[23:16];
//                    av_i2c_write <= 1'b1;
//                    if(av_i2c_waitrequest) begin 
//                        av_i2c_write <= 1'b0;
//                        st <= r_adv_init2;
//                        ADV_REG_WR_CNT <= ADV_REG_WR_CNT +1;
//                    end    
//                    else begin
//                        st <= r_adv_init;    
//                    end          
//                end
//            end
            
//            r_adv_init2: begin
//                if ((!av_i2c_waitrequest)) begin
//                    av_i2c_write <= 1'b0;
//                    st <= r_qspi_rd1_mux;
//                end
//            end                   

//              r_qspi_rd_oled:begin
//               if(data_trans_len_d > 0 )begin
//                    qspi_mem_rd_rq    <= 1'b1;
//                    qspi_send_addr    <= src_address_d;
//                    qspi_send_rd_size <= qspi_block_rd_size;
//                    qspi_send_cmd     <= `CMD_READ;
//                    if(qspi_send_busy)begin
//                         if(data_trans_len_d > qspi_block_rd_size)begin
//                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
//                         end
//                         else begin
//                            data_trans_len_d  <= 0;
//                         end
//                         src_address_d     <= src_address_d  + qspi_block_rd_size;                
//                         st                <= r_qspi_rd1_oled;
//                         qspi_mem_rd_rq    <= 1'b0; 
//                         qspi_send_addr    <= 32'h00000000;  
//                         //qspi_send_rd_size <= 0;
//                         qspi_send_cmd     <= 8'd0;   
//                    end
//                end    
//                 else begin
//                    st                <= r_qspi_rd_init;
//                    data_trans_len_d  <= 0;
//                    qspi_mem_rd_rq    <= 0;
//                    qspi_send_rd_size <= 0;
//                    qspi_send_cmd     <= 0;  
//                    time_cnt_Start    <= 1'b0;         
//                end              
//            end
          
//            r_qspi_rd1_oled: begin
//                if(!qspi_send_busy)begin
//                    if(temp_qspi_read_cnt == qspi_block_rd_size )begin
//                        st                 <= r_qspi_rd_oled;
//                        temp_qspi_read_cnt <= 0;
//                    end
//                    else begin
//                        st <= r_qspi_rd1_oled;             
//                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
//                            if(qspi_rd_cnt == 3)begin
//                                qspi_rx_rd_fifo_rq <= 1'b0;  
//                            end
//                            if(qspi_rd_cnt == 4)begin
//                                qspi_rd_cnt         <= 0;
//                                st                  <= r_oled_init;
//                                temp_qspi_read_cnt  <= temp_qspi_read_cnt +4; 
//                                OLED_WR_DATA        <= OLED_WR_DATA;
//                            end
//                            else begin
//                                OLED_WR_DATA    <= {qspi_rx_rd_fifo_data,OLED_WR_DATA [31:8]};
//                                qspi_rd_cnt     <= qspi_rd_cnt +1;
                                
//                            end              
//                        end
//                        else begin
//                                qspi_rx_rd_fifo_rq <= 1'b1;
//                        end
//                     end          
//                end            
//             end 
            
//            r_oled_init: begin
//                if(OLED_REG_WR_CNT == OLED_REG_CNT)begin
//                    st <= r_qspi_rd1_oled;
//                end
//                else begin
//                    av_i2c_address   <= {OLED_DEV_ADDRESS,OLED_WR_DATA[7: 0]};
//                    av_i2c_writedata <= OLED_WR_DATA[23:16];
//                    av_i2c_write <= 1'b1;
//                    if(av_i2c_waitrequest) begin 
//                        av_i2c_write <= 1'b0;
//                        st <= r_oled_init2;
//                        OLED_REG_WR_CNT <= OLED_REG_WR_CNT +1;
//                    end    
//                    else begin
//                        st <= r_oled_init;    
//                    end          
//                end
//            end
            
//            r_oled_init2: begin
//                if ((!av_i2c_waitrequest)) begin
//                    av_i2c_write <= 1'b0;
//                    st <= r_qspi_rd1_oled;
//                end
//            end

//              r_qspi_rd_adv:begin
//               if(data_trans_len_d > 0 )begin
//                    qspi_mem_rd_rq    <= 1'b1;
//                    qspi_send_addr    <= src_address_d;
//                    qspi_send_rd_size <= qspi_block_rd_size;
//                    qspi_send_cmd     <= `CMD_READ;
//                    if(qspi_send_busy)begin
//                         if(data_trans_len_d > qspi_block_rd_size)begin
//                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
//                         end
//                         else begin
//                            data_trans_len_d  <= 0;
//                         end
//                         src_address_d     <= src_address_d  + qspi_block_rd_size;                
//                         st                <= r_qspi_rd1_adv;
//                         qspi_mem_rd_rq    <= 1'b0; 
//                         qspi_send_addr    <= 32'h00000000;  
//                         //qspi_send_rd_size <= 0;
//                         qspi_send_cmd     <= 8'd0;   
//                    end
//                end    
//                 else begin
//                    st                <= r_qspi_rd_init;
//                    data_trans_len_d  <= 0;
//                    qspi_mem_rd_rq    <= 0;
//                    qspi_send_rd_size <= 0;
//                    qspi_send_cmd     <= 0;  
//                    time_cnt_Start    <= 1'b0;         
//                end              
//            end
          
//            r_qspi_rd1_adv: begin
//                if(!qspi_send_busy)begin
//                    if(temp_qspi_read_cnt == qspi_block_rd_size )begin
//                        st                 <= r_qspi_rd_adv;
//                        temp_qspi_read_cnt <=0;
//                    end
//                    else begin
//                        st <= r_qspi_rd1_adv;             
//                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
//                            if(qspi_rd_cnt == 3)begin
//                                qspi_rx_rd_fifo_rq <= 1'b0;  
//                            end
//                            if(qspi_rd_cnt == 4)begin
//                                qspi_rd_cnt         <= 0;
//                                st                  <= r_adv_init;
//                                temp_qspi_read_cnt  <= temp_qspi_read_cnt +4; 
//                                ADV_WR_DATA         <= ADV_WR_DATA;
//                            end
//                            else begin
//                                ADV_WR_DATA    <= {qspi_rx_rd_fifo_data,ADV_WR_DATA [31:8]};
//                                qspi_rd_cnt     <= qspi_rd_cnt +1;
                                
//                            end              
//                        end
//                        else begin
//                                qspi_rx_rd_fifo_rq <= 1'b1;
//                        end
//                     end          
//                end            
//             end 
            
//            r_adv_init: begin
//                if(ADV_REG_WR_CNT == ADV_REG_CNT)begin
//                    st <= r_qspi_rd1_adv;
//                end
//                else begin
//                    av_i2c_address   <= {ADV_DEV_ADDRESS,ADV_WR_DATA[7: 0]};
//                    av_i2c_writedata <= ADV_WR_DATA[23:16];
//                    av_i2c_write <= 1'b1;
//                    if(av_i2c_waitrequest) begin 
//                        av_i2c_write <= 1'b0;
//                        st <= r_adv_init2;
//                        ADV_REG_WR_CNT <= ADV_REG_WR_CNT +1;
//                    end    
//                    else begin
//                        st <= r_adv_init;    
//                    end          
//                end
//            end
            
//            r_adv_init2: begin
//                if ((!av_i2c_waitrequest)) begin
//                    av_i2c_write <= 1'b0;
//                    st <= r_qspi_rd1_adv;
//                end
//            end


//             r_qspi_rd_reticle:begin
//               if(data_trans_len_d > 0 )begin
//                    qspi_mem_rd_rq    <= 1'b1;
//                    qspi_send_addr    <= src_address_d;
//                    qspi_send_rd_size <= qspi_block_rd_size;
//                    qspi_send_cmd     <= `CMD_READ;
//                    if(qspi_send_busy)begin
//                         if(data_trans_len_d > qspi_block_rd_size)begin
//                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
//                         end
//                         else begin
//                            data_trans_len_d  <= 0;
//                         end
//                         src_address_d     <= src_address_d  + qspi_block_rd_size;                
//                         st                <= r_qspi_rd1_reticle;
//                         qspi_mem_rd_rq    <= 1'b0; 
//                         qspi_send_addr    <= 32'h00000000;  
//                         //qspi_send_rd_size <= 0;
//                         qspi_send_cmd     <= 8'd0;   
//                    end
//                end    
//                 else begin
//                    st                <= r_qspi_rd_init;
//                    data_trans_len_d  <= 0;
//                    qspi_mem_rd_rq    <= 0;
//                    qspi_send_rd_size <= 0;
//                    qspi_send_cmd     <= 0;  
//                    time_cnt_Start    <= 1'b0;         
//                end              
//            end

            
//            r_qspi_rd1_reticle: begin
//                LOGO_WR_EN    <= 1'b0;
//                RETICLE_WR_EN <= 1'b0;
//                if(!qspi_send_busy)begin
//                    if(temp_qspi_read_cnt == qspi_block_rd_size )begin
//                        st                 <= r_qspi_rd_reticle;
//                        temp_qspi_read_cnt <=0;
//                    end
//                    else begin
//                        st <= r_qspi_rd1_reticle;             
//                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
//                            if(qspi_rd_cnt == 3)begin
//                                qspi_rx_rd_fifo_rq <= 1'b0;  
//                            end
//                            if(qspi_rd_cnt == 4)begin
//                                qspi_rd_cnt          <= 0;
//                                st                   <= r_reticle_write;
//                                temp_qspi_read_cnt   <= temp_qspi_read_cnt +4; 
//                                RETICLE_WR_DATA      <= RETICLE_WR_DATA;
//                                LOGO_WR_DATA         <= LOGO_WR_DATA;
//                            end
//                            else begin
//                                LOGO_WR_DATA    <= {qspi_rx_rd_fifo_data,LOGO_WR_DATA [31:8]};
//                                RETICLE_WR_DATA <= {qspi_rx_rd_fifo_data,RETICLE_WR_DATA[31:8]};
//                                qspi_rd_cnt <= qspi_rd_cnt +1;
                                
//                            end              
//                        end
//                        else begin
//                                qspi_rx_rd_fifo_rq <= 1'b1;
//                        end
//                     end          
//                end            
//             end 
            
//            r_reticle_write: begin
//                if(c_cmd == RD_QSPI_WR_RETICLE)begin
//                    RETICLE_WR_EN <= 1'b1;
//                    LOGO_WR_EN    <= 1'b0;
//                end
//                else if(c_cmd == RD_QSPI_WR_LOGO)begin
//                    LOGO_WR_EN   <= 1'b1;
//                    RETICLE_WR_EN <= 1'b0;
//                end
//                RETICLE_WR_DATA <= RETICLE_WR_DATA;
//                LOGO_WR_DATA    <= LOGO_WR_DATA;
//                st              <= r_qspi_rd1_reticle;
//            end

            
            r_qspi_rd_temperature:begin
               if(data_trans_len_d > 0 )begin
                    qspi_mem_rd_rq    <= 1'b1;
                    qspi_send_addr    <= src_address_d;
                    qspi_send_rd_size <= data_trans_len_d;
                    qspi_send_cmd     <= `CMD_READ;
                    if(qspi_send_busy)begin
                         st                <= r_qspi_rd1_temperature;
                         qspi_mem_rd_rq    <= 1'b0; 
                         qspi_send_addr    <= 32'h00000000;  
                         //qspi_send_rd_size <= 0;
                         qspi_send_cmd     <= 8'd0;   
                    end
                end                
            end
            
            r_qspi_rd1_temperature: begin
                if(!qspi_send_busy)begin
                    if(temp_qspi_read_cnt == data_trans_len_d )begin
                        st                <= r_qspi_rd_init;
                        data_trans_len_d  <= 0;
                        qspi_mem_rd_rq    <= 0;
                        qspi_send_rd_size <= 0;
                        qspi_send_cmd     <= 0;
                        temp_qspi_read_cnt <=0;
                        temperature_write_data_valid <= 0;  
                    end
                    else begin
                        st <= r_qspi_rd1_temperature;             
                        if(qspi_rx_rd_fifo_rq== 1'b1 || (temp_qspi_read_cnt == (data_trans_len_d - 1)) )begin
                            if(temp_qspi_read_cnt == (data_trans_len_d-2))begin
                                qspi_rx_rd_fifo_rq <= 1'b0;  
                            end
//                            if(temp_qspi_read_cnt >= (data_trans_len_d - 4)) begin
//                                device_id <= {qspi_rx_rd_fifo_data,device_id[31:8]};
//                            end
                            if(temp_qspi_read_cnt >= (data_trans_len_d - 9)) begin
                               gallery_img_valid <= {qspi_rx_rd_fifo_data,gallery_img_valid[71:8]};
                               
                            end
                            if(temp_qspi_read_cnt >= (data_trans_len_d - 1)) begin
                               gallery_img_valid_en <= 1'b1;
                            end
                            
                            temperature_write_data <= qspi_rx_rd_fifo_data;
                            temperature_write_data_valid <= 1'b1;
                            temp_qspi_read_cnt <= temp_qspi_read_cnt +1;
                        end
                        else begin
                                qspi_rx_rd_fifo_rq <= 1'b1;
                        end
                     end          
                end            
             end 


            r_qspi_rd_prdct_name:begin
               if(data_trans_len_d > 0 )begin
                    qspi_mem_rd_rq    <= 1'b1;
                    qspi_send_addr    <= src_address_d;
                    qspi_send_rd_size <= data_trans_len_d;
                    qspi_send_cmd     <= `CMD_READ;
                    if(qspi_send_busy)begin
                         st                <= r_qspi_rd1_prdct_name;
                         qspi_mem_rd_rq    <= 1'b0; 
                         qspi_send_addr    <= 32'h00000000;  
                         //qspi_send_rd_size <= 0;
                         qspi_send_cmd     <= 8'd0;   
                    end
                end                
            end
            
            r_qspi_rd1_prdct_name: begin
                if(!qspi_send_busy)begin
                    if(temp_qspi_read_cnt == data_trans_len_d )begin
                        st                          <= r_qspi_rd_init;
                        data_trans_len_d            <= 0;
                        qspi_mem_rd_rq              <= 0;
                        qspi_send_rd_size           <= 0;
                        qspi_send_cmd               <= 0;
                        temp_qspi_read_cnt          <= 0;
                        PRDCT_NAME_WRITE_DATA_VALID <= 0;  
                    end
                    else begin
                        st <= r_qspi_rd1_prdct_name;             
                        if(qspi_rx_rd_fifo_rq== 1'b1 || (temp_qspi_read_cnt == (data_trans_len_d - 1)) )begin
                            if(temp_qspi_read_cnt == (data_trans_len_d-2))begin
                                qspi_rx_rd_fifo_rq <= 1'b0;  
                            end
//                            if(temp_qspi_read_cnt >= (data_trans_len_d - 4)) begin
//                                device_id <= {qspi_rx_rd_fifo_data,device_id[31:8]};
//                            end
                            PRDCT_NAME_WRITE_DATA       <= qspi_rx_rd_fifo_data;
                            PRDCT_NAME_WRITE_DATA_VALID <= 1'b1;
                            temp_qspi_read_cnt <= temp_qspi_read_cnt +1;
                        end
                        else begin
                                qspi_rx_rd_fifo_rq <= 1'b1;
                        end
                     end          
                end            
             end 


            
             r_qspi_rd_sensor_init: begin
                 if(data_trans_len_d > 0 )begin
                      qspi_mem_rd_rq    <= 1'b1;
                      qspi_send_addr    <= src_address_d;
                      qspi_send_rd_size <= data_trans_len_d;
                      qspi_send_cmd     <= `CMD_READ;
                      if(qspi_send_busy)begin
                           st                <= r_qspi_rd1_sensor_init;
                           qspi_mem_rd_rq    <= 1'b0; 
                           qspi_send_addr    <= 32'h00000000;  
                           //qspi_send_rd_size <= 0;
                           qspi_send_cmd     <= 8'd0;   
                      end
                  end  
             end
             
             r_qspi_rd1_sensor_init: begin
                 if(!qspi_send_busy)begin
                     if(temp_qspi_read_cnt == data_trans_len_d )begin
                         st                  <= r_qspi_rd_init;
                         sensor_init_rd_done <= 1'b1;
                         data_trans_len_d    <= 0;
                         qspi_mem_rd_rq      <= 0;
                         qspi_send_rd_size   <= 0;
                         qspi_send_cmd       <= 0;
                         temp_qspi_read_cnt  <=0;
                         sensor_init_write_data_valid <= 0;  
                     end
                     else begin
                         st <= r_qspi_rd1_sensor_init;             
                         if(qspi_rx_rd_fifo_rq== 1'b1 || (temp_qspi_read_cnt == (data_trans_len_d - 1)) )begin
                             if(temp_qspi_read_cnt == (data_trans_len_d-2))begin
                                 qspi_rx_rd_fifo_rq <= 1'b0;  
                             end
                             sensor_init_write_data <= qspi_rx_rd_fifo_data;
                             sensor_init_write_data_valid <= 1'b1;
                             temp_qspi_read_cnt <= temp_qspi_read_cnt +1;
                         end
                         else begin
                                 qspi_rx_rd_fifo_rq <= 1'b1;
                         end
                      end          
                 end            
             end            

            r_qspi_rd_user_settings: begin
                 temp_qspi_read_cnt <= 0;
                 if(data_trans_len_d > 0 )begin
                     qspi_mem_rd_rq    <= 1'b1;
                     qspi_send_addr    <= src_address_d;
                     qspi_send_rd_size <= qspi_block_rd_size;
                     qspi_send_cmd     <= `CMD_READ;
                     if(qspi_send_busy)begin
                          if(data_trans_len_d > qspi_block_rd_size)begin
                             data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
                          end
                          else begin
                             data_trans_len_d  <= 0;
                          end
                          src_address_d     <= src_address_d  + qspi_block_rd_size;
                          st                <= r_qspi_rd1_user_settings;
                          qspi_mem_rd_rq    <= 1'b0; 
                          qspi_send_addr    <= 32'h00000000;  
                          qspi_send_cmd     <= 8'd0;   
                     end
                 end
                 else begin
                     st                <= r_qspi_rd_init;
                     data_trans_len_d  <= 0;
                     qspi_mem_rd_rq    <= 0;
                     qspi_send_rd_size <= 0;
                     qspi_send_cmd     <= 0; 
                     gain_wr_done      <= 1'b1;
                     user_settings_mem_wr_addr_temp1 <= 0;
                     user_settings_mem_wr_addr1 <= 0;  
                     user_settings_init_start <= 1'b1;   
                     user_settings_mux_sel    <= 1'b1;
                 end       
             end
             r_qspi_rd1_user_settings : begin
                 user_settings_mem_wr_req1  <= 1'b0;
                 if(!qspi_send_busy)begin
                     if(temp_qspi_read_cnt == qspi_block_rd_size)begin
                         st <= r_qspi_rd_user_settings;
                         temp_qspi_read_cnt <=0;  
                     end
                     else begin
                         st <= r_qspi_rd1_user_settings;
                         if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
                             if(qspi_rd_cnt == 3)begin
                                 qspi_rx_rd_fifo_rq <= 1'b0;  
                             end
                             if(qspi_rd_cnt == 4)begin
                                 //st <= r_qspi_wr_user_settings;
                                 //st <= r_qspi_rd1_user_settings;
                                 qspi_rd_cnt <= 0;
                                 user_settings_mem_wr_req1       <= 1'b1;  
                                 user_settings_mem_wr_data1      <= user_settings_mem_wr_data1;
                                 user_settings_mem_wr_addr1      <= user_settings_mem_wr_addr_temp1; 
                                 user_settings_mem_wr_addr_temp1 <= user_settings_mem_wr_addr_temp1 +1;
                                 temp_qspi_read_cnt<= temp_qspi_read_cnt +4; 
                             end
                             else begin
                                 user_settings_mem_wr_data1 <= {qspi_rx_rd_fifo_data,user_settings_mem_wr_data1[31:8]};
                                 qspi_rd_cnt <= qspi_rd_cnt +1;
                             end 
                         end
                         else begin
                                 qspi_rx_rd_fifo_rq <= 1'b1;
                         end
                      end          
                 end
             end    



        endcase


        case(qspi_sdram_trans_st)
            r_qspi_sdram_trans_idle: begin
                 snapshot_save_done   <= 1'b0;
                 snapshot_delete_done <= 1'b0;
                 if ((osd_snapshot_delete_en || single_snapshot_en|| burst_snapshot_en || qspi_erase_enable || switch_to_factory_settings_en || save_user_settings_en|| OSD_SAVE_USER_SETTINGS || OSD_SAVE_BP)&& qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0)begin
                     qspi_sdram_trans_st <= r_qspi_erase_block_cal1;
                     qspi_erase_enable   <= 1'b1;
                      if(single_snapshot_en) begin 
                          qspi_addr <= {20'h000A0, 1'b0, 3'd2, snapshot_counter};
                          snapshot_save_en   <= 1'b1;
                          snapshot_delete_en <= 1'b0;
                      end
//                      else if(continuous_snapshot_en) begin
//                          qspi_addr <= 32'h000A_0000;
//                          snapshot_save_en   <= 1'b1;
//                          snapshot_delete_en <= 1'b0;
//                      end    
                      else if(burst_snapshot_en) begin
                          qspi_addr <= {20'h000A0, 1'b0, 3'd5, snapshot_counter};
                          snapshot_save_en   <= 1'b1;
                          snapshot_delete_en <= 1'b0;
                      end   
                      else if(osd_snapshot_delete_en)begin 
//                           qspi_addr <= {20'h000A0, 1'b0, 3'd2, gallery_img_number}; // Delete single image 
                           qspi_addr <= 32'h000A_0000; // Delete all image
                           snapshot_save_en   <= 1'b0;
                           snapshot_delete_en <= 1'b1;                        
                      end
                     
                     if(OSD_SAVE_BP)begin
                        qspi_addr <= 32'h000f0008;//32'h000f0005;
                     end
                     if(OSD_SAVE_USER_SETTINGS)begin
                        save_user_settings_en          <= 1'b1;
                     end
                                       
                 end
                 else if((qspi_user_settings_trans_en)&& qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0)begin
                     qspi_sdram_trans_st      <= r_sdram_to_qspi_data_transfer;
                     user_settings_mux_sel    <= 1'b0;
                 end
                 else if((load_factory_settings_en || OSD_LOAD_FACTORY_SETTINGS)&& qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0)begin
                     qspi_sdram_trans_st <= r_qspi_rd_user_settings_wr;
                     data_trans_len_d    <= QSPI_ADDR_USER_SETTINGS_DATA_SIZE;
                     src_address_d       <= QSPI_ADDR_FACTORY_SETTINGS_DATA;
                     user_settings_mux_sel    <= 1'b0;
                     load_factory_settings_en <= 1'b1;
                     
                 end
                 else if((load_user_settings_en || OSD_LOAD_USER_SETTINGS)&& qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0)begin
                     qspi_sdram_trans_st <=r_qspi_rd_user_settings_wr;
                     data_trans_len_d    <= QSPI_ADDR_USER_SETTINGS_DATA_SIZE;
                     src_address_d       <= QSPI_ADDR_USER_SETTINGS_DATA;
                     user_settings_mux_sel    <= 1'b0;
                     load_user_settings_en <= 1'b1;
                     
                 end
                else if((qspi_erase_64KB_enable))begin
                    qspi_sdram_trans_st <= r_qspi_64KB_erase_start;
                    dest_address_d        <= qspi_addr; 
                end
                else if((qspi_erase_32KB_enable))begin
                    qspi_sdram_trans_st <= r_qspi_32KB_erase_start;
                    dest_address_d        <= qspi_addr;
                end
                else if(qspi_erase_4KB_enable)begin
                    qspi_sdram_trans_st <= r_qspi_4KB_erase_start;
                    dest_address_d        <= qspi_addr;
                end
                else if((qspi_sdram_trans_enable)&& qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0) begin
                    if(DMA_WRITE_FREE)begin
                        qspi_sdram_trans_st <= r_sdram_to_qspi_data_transfer; 
                        qspi_init_cmd_done <= 1'b0;                   
                    end    
                end
                //else if(rd_qspi_wr_sdram_enable) begin
                else if((rd_qspi_wr_sdram_enable || ch_img_rd_qspi_wr_sdram_en || gallery_img_rd_qspi_wr_sdram_en)&& qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0) begin
                    if(DMA_WRITE_FREE)begin
                        qspi_sdram_trans_st <= r_qspi_to_sdram_data_transfer; 
                        qspi_init_cmd_done <= 1'b0;
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                        qspi_init_cmd_done  <= qspi_init_cmd_done ;
                    end    
                    
                    if(ch_img_rd_qspi_wr_sdram_en)begin
                        qspi_addr <= ch_img_qspi_addr;
                        sdram_addr <= ch_img_sdram_addr;    
                        qspi_trans_len <= ch_img_len;
                    end    
                    else if(gallery_img_rd_qspi_wr_sdram_en)begin
                        qspi_trans_len <= TOTAL_FRAME_BUFFERS*ADDR_SNAPSHOT_OFFSET_1;
                        qspi_addr      <= QSPI_ADDR_SNAPSHOT_BASE;
                        sdram_addr     <= ADDR_SNAPSHOT_BASE;                                             
                    end
                    ch_img_sum_temp <= 64'd0;
                    ch_img_sum      <= 64'd0; 
                end
                else if(qspi_reticle_transfer_rq==1'b1 && qspi_oled_init_wr_enable == 1'b0 && qspi_oled_init_wr_enable_latch == 1'b0 && qspi_temperature_wr_enable == 1'b0 && qspi_temperature_wr_enable_d == 1'b0)begin
                     qspi_reticle_transfer_rq_ack <= 1'b1;
                     qspi_sdram_trans_st <= r_qspi_to_bram_rd_reticle;
                     data_trans_len_d    <= QSPI_RETICLE_SIZE;
                     if(reticle_sel[6:4] == 3'd2)begin
                         if(reticle_sel[3:0]==4'd1)begin
                            src_address_d       <= QSPI_ADDR_RETICLE_3;
                         end
                         else if(reticle_sel[3:0]==4'd2) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_6;              
                         end
                         else if(reticle_sel[3:0]==4'd3) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_9;              
                         end
                         else if(reticle_sel[3:0]==4'd4) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_12;              
                         end                                          
                         else if(reticle_sel[3:0]==4'd5) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_15;              
                         end
//                         else if(reticle_sel[3:0]==4'd6) begin
//                            src_address_d       <= QSPI_ADDR_RETICLE_8;              
//                         end
//                         else if(reticle_sel[3:0]==4'd7) begin
//                            src_address_d       <= QSPI_ADDR_RETICLE_7;              
//                         end
//                         else if(reticle_sel[3:0]==4'd8) begin
//                            src_address_d       <= QSPI_ADDR_RETICLE_8;              
//                         end
                         else begin
                            src_address_d       <= QSPI_ADDR_RETICLE_16; 
                         end
                     end
                     else if(reticle_sel[6:4] == 3'd1)begin
                         if(reticle_sel[3:0]==4'd1)begin
                            src_address_d       <= QSPI_ADDR_RETICLE_2;
                         end
                         else if(reticle_sel[3:0]==4'd2) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_5;              
                         end
                         else if(reticle_sel[3:0]==4'd3) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_8;              
                         end
                         else if(reticle_sel[3:0]==4'd4) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_11;              
                         end                                          
                         else if(reticle_sel[3:0]==4'd5) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_14;              
                         end
//                         else if(reticle_sel[3:0]==4'd6) begin
//                            src_address_d       <= QSPI_ADDR_RETICLE_6;              
//                         end
//                         else if(reticle_sel[3:0]==4'd7) begin
//                            src_address_d       <= QSPI_ADDR_RETICLE_7;              
//                         end
//                         else if(reticle_sel[3:0]==4'd8) begin
//                            src_address_d       <= QSPI_ADDR_RETICLE_8;              
//                         end
                         else begin
                            src_address_d       <= QSPI_ADDR_RETICLE_16; 
                         end                     
                     end
                     else begin
                         if(reticle_sel[3:0]==4'd1)begin
                            src_address_d       <= QSPI_ADDR_RETICLE_1;
                         end
                         else if(reticle_sel[3:0]==4'd2) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_4;              
                         end
                         else if(reticle_sel[3:0]==4'd3) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_7;              
                         end
                         else if(reticle_sel[3:0]==4'd4) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_10;              
                         end                                          
                         else if(reticle_sel[3:0]==4'd5) begin
                            src_address_d       <= QSPI_ADDR_RETICLE_13;              
                         end
                         else begin
                            src_address_d       <= QSPI_ADDR_RETICLE_16; 
                         end                                           
                     end    
                                          
                     time_cnt_Start      <= 1'b1;      
                     qspi_reticle_transfer_done <= 1'b0;
                end 
                      
            end
            

            r_qspi_erase_block_cal1: begin
                qspi_sdram_trans_st <= r_qspi_erase_block_cal2;
//                qspi_trans_len      <= NUC_TABLE_SIZE;
                // if(switch_to_factory_settings_en)begin
                //     qspi_trans_len      <= QSPI_ADDR_FACTORY_SETTINGS_DATA_SIZE;
                // end
                // else if(save_user_settings_en)begin
                //     qspi_trans_len      <= QSPI_ADDR_USER_SETTINGS_DATA_SIZE;
                // end
                // else begin
                //     qspi_trans_len      <= NUC_TABLE_SIZE;
                // end

               if(switch_to_factory_settings_en || save_user_settings_en)begin
                    dest_address_d <= QSPI_ADDR_USER_SETTINGS_DATA;
                    src_address_d  <= ADDR_FACTORY_SETTINGS;
                    if(switch_to_factory_settings_en)begin
                        qspi_trans_len      <= QSPI_ADDR_FACTORY_SETTINGS_DATA_SIZE;
                    end
                    else if(save_user_settings_en)begin
                        qspi_trans_len      <= QSPI_ADDR_USER_SETTINGS_DATA_SIZE;
                    end
               end
               else if(qspi_addr[19:16] ==4'h0 )begin
                    dest_address_d      <= ((qspi_addr[7:0]-1'b1) * QSPI_ADDR_OFFM_OFFSET) + QSPI_ADDR_OFFM_START;
                    src_address_d       <= ADDR_OFFM_NUC1PT;
                    temperature_wr_addr <= qspi_addr[7:0]- 1'b1;
                    temperature_wr_rq   <= 1'b1;
                    qspi_trans_len      <= NUC_TABLE_SIZE;
                end
                else if(qspi_addr[19:16] ==4'h8 )begin
                    qspi_trans_len      <= NUC_TABLE_SIZE;
                    if(qspi_addr[15:0] == 16'h0)begin
                        dest_address_d      <= QSPI_ADDR_IMG_COLD;
                        src_address_d       <= ADDR_IMG_COLD;
                    end
                    else if(qspi_addr[15:0] == 16'h1) begin
                        dest_address_d      <= QSPI_ADDR_IMG_HOT;
                        src_address_d       <= ADDR_IMG_HOT;
                    end
                end
                else if(qspi_addr[19:16] ==4'hf) begin
                    qspi_trans_len      <= NUC_TABLE_SIZE;
                    if(qspi_addr[15:0] == 16'h1) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_A;
                        src_address_d       <= ADDR_GAIN;  
                    end
                    else if(qspi_addr[15:0] == 16'h2)begin
                        dest_address_d      <= QSPI_ADDR_GAINM_B;
                        src_address_d       <= ADDR_GAIN;  
                    end 
                    else if(qspi_addr[15:0] == 16'h3) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_C;
                        src_address_d       <= ADDR_GAIN;  
                    end
                    else if(qspi_addr[15:0] == 16'h4)begin
                        dest_address_d      <= QSPI_ADDR_GAINM_D;
                        src_address_d       <= ADDR_GAIN;  
                    end 
                    else if(qspi_addr[15:0] == 16'h5)begin
                        dest_address_d      <= QSPI_ADDR_GAINM_E;
                        src_address_d       <= ADDR_GAIN;  
                    end 
                    else if(qspi_addr[15:0] == 16'h6)begin
                        dest_address_d      <= QSPI_ADDR_GAINM_F;
                        src_address_d       <= ADDR_GAIN;  
                    end 
                    else if(qspi_addr[15:0] == 16'h7)begin
                        dest_address_d      <= QSPI_ADDR_GAINM_G;
                        src_address_d       <= ADDR_GAIN;  
                    end                                         
                    else if(qspi_addr[15:0] == 16'h8) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_A;
                        src_address_d       <= ADDR_GAIN_BADPIX_A;    
                    end 
                    else if(qspi_addr[15:0] == 16'h9) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_B;
                        src_address_d       <= ADDR_GAIN_BADPIX_B;    
                    end     
                    else if(qspi_addr[15:0] == 16'h10) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_C;
                        src_address_d       <= ADDR_GAIN_BADPIX_C;    
                    end 
                    else if(qspi_addr[15:0] == 16'h11) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_D;
                        src_address_d       <= ADDR_GAIN_BADPIX_D;    
                    end     
                    else if(qspi_addr[15:0] == 16'h12) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_E;
                        src_address_d       <= ADDR_GAIN_BADPIX_E;    
                    end 
                    else if(qspi_addr[15:0] == 16'h13) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_F;
                        src_address_d       <= ADDR_GAIN_BADPIX_F;    
                    end 
                    else if(qspi_addr[15:0] == 16'h14) begin
                        dest_address_d      <= QSPI_ADDR_GAINM_G;
                        src_address_d       <= ADDR_GAIN_BADPIX_G;    
                    end                                                             
                end
                else if(qspi_addr[19:16] == 4'hA) begin
                  if(qspi_addr[7:0]==8'd0) begin 
                    qspi_trans_len      <= TOTAL_FRAME_BUFFERS*ADDR_SNAPSHOT_OFFSET_1;
                    dest_address_d      <= QSPI_ADDR_SNAPSHOT_BASE;
                    src_address_d       <= ADDR_SNAPSHOT_BASE;    
                  end
                  else begin 
                    if(qspi_addr[10:8]==5) begin 
                      qspi_trans_len    <= burst_capture_size * ADDR_SNAPSHOT_OFFSET_2;
                      dest_address_d    <= QSPI_ADDR_SNAPSHOT_BASE + (qspi_addr[7:0]-burst_capture_size)*ADDR_SNAPSHOT_OFFSET_2;
                      src_address_d     <= ADDR_SNAPSHOT_BASE + (qspi_addr[7:0]-burst_capture_size)*ADDR_SNAPSHOT_OFFSET_2;
                    end 
                    else if(qspi_addr[10:8]==2) begin 
                      qspi_trans_len    <= ADDR_SNAPSHOT_OFFSET_2;
                      dest_address_d    <= QSPI_ADDR_SNAPSHOT_BASE + (qspi_addr[7:0]-1)*ADDR_SNAPSHOT_OFFSET_2;
                      src_address_d     <= ADDR_SNAPSHOT_BASE + (qspi_addr[7:0]-1)*ADDR_SNAPSHOT_OFFSET_2;
                    end
                    else begin 
                      qspi_trans_len    <= ADDR_SNAPSHOT_OFFSET_1;
                      dest_address_d    <= QSPI_ADDR_SNAPSHOT_BASE + (qspi_addr[7:0]-1)*ADDR_SNAPSHOT_OFFSET_1;
                      src_address_d     <= ADDR_SNAPSHOT_BASE + (qspi_addr[7:0]-1)*ADDR_SNAPSHOT_OFFSET_1;
                    end
                  end   
//                dest_address_d        <= qspi_addr;
//                src_address_d         <= sdram_addr; 
                end
            end

            
            r_qspi_erase_block_cal2: begin 
               temperature_wr_rq   <= 1'b0;
               sdram_addr <= src_address_d;
               qspi_addr  <= dest_address_d;
               qspi_erase_start_addr <= dest_address_d;
//               qspi_erase_end_addr   <= dest_address_d + qspi_trans_len;
//               if(qspi_trans_len < 13'h1000)begin 
//                 qspi_sdram_trans_st <=  r_qspi_sdram_trans_idle;
//                 qspi_erase_enable <= 1'b0;
//               end
//               else begin
//                 qspi_sdram_trans_st   <= r_qspi_check_64k_boundary;
//               end 

               qspi_sdram_trans_st   <= r_qspi_check_64k_boundary;
               if(qspi_trans_len < 13'h1000)begin 
                 //qspi_sdram_trans_st <=  r_qspi_sdram_trans_idle;
                 //qspi_erase_enable <= 1'b0;
                 qspi_erase_end_addr   <= dest_address_d + 32'h1000;
               end
               else begin
                 //qspi_sdram_trans_st   <= r_qspi_check_64k_boundary;
                 qspi_erase_end_addr   <= dest_address_d + qspi_trans_len;
               end 
               
            end
            
            r_qspi_check_64k_boundary : begin
                           if(qspi_erase_start_addr[15:0] == 16'h0000)begin
                             qspi_sdram_trans_st <= r_qspi_calc_64k_block_start;
                           end 
                           else begin
                             qspi_sdram_trans_st <=  r_qspi_check_32k_boundary;
                           end                           
            end
            r_qspi_check_32k_boundary : begin
                           if(qspi_erase_start_addr[15:0] == 16'h8000)begin
                             qspi_sdram_trans_st <= r_qspi_calc_32k_block_start;
                           end 
                           else begin
                             qspi_sdram_trans_st <=  r_qspi_check_4k_boundary;
                           end
            
            end
            r_qspi_check_4k_boundary : begin
                           if(qspi_erase_start_addr[11:0] == 12'h000)begin
                             qspi_sdram_trans_st <= r_qspi_calc_4k_block_start;
                           end 
                           else begin
                             qspi_sdram_trans_st <=  r_qspi_sdram_trans_idle;
                             qspi_erase_enable <= 1'b0;
                           end
            end
            
            r_qspi_erase_wait : begin
                       qspi_sdram_trans_st <= qspi_sdram_trans_st_next; 
                       qspi_sdram_trans_st_next <=  r_qspi_sdram_trans_idle;
//                       if(qspi_sdram_trans_st_next == r_qspi_sdram_trans_idle)begin
//                        qspi_erase_enable <= 1'b0;   
//                        qspi_sdram_trans_enable <= 1'b1;
//                        sdram_addr <= sdram_addr;
//                        qspi_addr  <= qspi_addr;
//                        qspi_trans_len <= {8'd0, qspi_trans_len[32-1:8]};
//                       end

                       if(qspi_sdram_trans_st_next == r_qspi_sdram_trans_idle)begin
                        qspi_erase_enable <= 1'b0;
                        if(switch_to_factory_settings_en)begin
                            switch_to_factory_settings_en_d <= 1'b1; 
                            switch_to_factory_settings_en   <= 1'b0;
                            save_user_settings_en           <= 1'b0;
                            qspi_user_settings_trans_en     <= 1'b0;
                            qspi_sdram_trans_enable         <= 1'b1;
                            snapshot_delete_done            <= 1'b0;
                            snapshot_delete_en              <= 1'b0;
                            gallery_img_valid_save_en       <= 1'b0; 
                            qspi_temperature_wr_enable      <= 1'b0;                 
                        end          
                        else if(save_user_settings_en)begin
                            switch_to_factory_settings_en_d <= 1'b0; 
                            switch_to_factory_settings_en   <= 1'b0;
                            save_user_settings_en           <= 1'b0;
                            qspi_user_settings_trans_en     <= 1'b1;
                            qspi_sdram_trans_enable         <= 1'b0;
                            snapshot_delete_done            <= 1'b0;
                            snapshot_delete_en              <= 1'b0; 
                            gallery_img_valid_save_en       <= 1'b0;
                            qspi_temperature_wr_enable      <= 1'b0;                              
                        end
                        else if(snapshot_delete_en)begin 
                            switch_to_factory_settings_en_d <= 1'b0; 
                            switch_to_factory_settings_en   <= 1'b0;
                            save_user_settings_en           <= 1'b0;
                            qspi_user_settings_trans_en     <= 1'b0;
                            qspi_sdram_trans_enable         <= 1'b0;
                            snapshot_delete_done            <= 1'b1;
                            snapshot_delete_en              <= 1'b0; 
                            gallery_img_valid_save_en       <= 1'b1;
                            qspi_temperature_wr_enable      <= 1'b1;        
                        end
                        else begin
                            switch_to_factory_settings_en_d <= 1'b0; 
                            switch_to_factory_settings_en   <= 1'b0;
                            save_user_settings_en           <= 1'b0;
                            qspi_user_settings_trans_en     <= 1'b0;
                            qspi_sdram_trans_enable         <= 1'b1;
                            snapshot_delete_done            <= 1'b0;
                            snapshot_delete_en              <= 1'b0; 
                            gallery_img_valid_save_en       <= 1'b0; 
                            qspi_temperature_wr_enable      <= 1'b0;
                        end
                        sdram_addr <= sdram_addr;
                        qspi_addr      <= qspi_addr;
                        qspi_trans_len <= {8'd0, qspi_trans_len[32-1:8]}; 
                                                                     
                       end

            end
            
            r_qspi_calc_64k_block_start : begin
                            if(qspi_erase_end_addr >= (qspi_erase_start_addr + 17'h10000)) begin
                              number_of_erase_block   <= ({qspi_erase_end_addr[31:16],16'd0} -  qspi_erase_start_addr)>>16;
                              dest_address_d          <= qspi_erase_start_addr;
                              qspi_erase_start_addr   <= {qspi_erase_end_addr[31:16],16'd0} ;
                              qspi_sdram_trans_st     <=  r_qspi_64KB_erase_start;
                              //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                            end  
                            else begin
                              number_of_erase_block  <= 0;
                              //dest_address_d         <= qspi_erase_start_addr;
                              qspi_erase_start_addr  <= qspi_erase_start_addr;
                              qspi_sdram_trans_st    <= r_qspi_calc_32k_block_end; 
                            end  
                            qspi_sdram_trans_st_next <= r_qspi_calc_32k_block_end;
            end
            r_qspi_calc_32k_block_end :begin
                            if((qspi_erase_start_addr+ 16'h8000) <= qspi_erase_end_addr )begin
                              number_of_erase_block    <= 1; 
                              dest_address_d           <= qspi_erase_start_addr;
                              qspi_erase_start_addr    <= qspi_erase_start_addr+ 16'h8000;
                              qspi_sdram_trans_st      <= r_qspi_32KB_erase_start;
                              //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                            end
                            else begin
                              number_of_erase_block        <= 0; 
                              //dest_address_d         <= qspi_erase_start_addr;
                              qspi_erase_start_addr  <= qspi_erase_start_addr; 
                              qspi_sdram_trans_st    <= r_qspi_calc_4k_block_end;
                            end
                            qspi_sdram_trans_st_next <= r_qspi_calc_4k_block_end;
                            
                            
            end                
            r_qspi_calc_4k_block_end :begin
                            if(qspi_erase_end_addr  >= (qspi_erase_start_addr + 16'h1000)) begin
                                number_of_erase_block  <= (qspi_erase_end_addr - qspi_erase_start_addr)>>12;
                                dest_address_d         <= qspi_erase_start_addr;
                                qspi_erase_start_addr  <= qspi_erase_end_addr;
                                qspi_sdram_trans_st    <= r_qspi_4KB_erase_start;
                                //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                            end
                            else begin
                                number_of_erase_block  <= 0;
                                //dest_address_d         <= qspi_erase_start_addr;
                                qspi_erase_start_addr <= qspi_erase_start_addr;
                                qspi_sdram_trans_st   <= r_qspi_erase_wait;
                                //qspi_erase_enable <= 1'b0;
                            end   
                            qspi_sdram_trans_st_next <= r_qspi_sdram_trans_idle; 
            end
            r_qspi_calc_32k_block_start :begin              
                            if(qspi_erase_end_addr    >= (qspi_erase_start_addr + 16'h8000))begin
                              number_of_erase_block    <= 1;
                              dest_address_d           <= qspi_erase_start_addr;
                              qspi_erase_start_addr    <= qspi_erase_start_addr + 16'h8000;
                              qspi_sdram_trans_st      <= r_qspi_32KB_erase_start;
                              //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                              qspi_sdram_trans_st_next <= r_qspi_calc_64k_block_end ;
                            end
                            else begin
                              number_of_erase_block    <= 0;
                              //dest_address_d           <= qspi_erase_start_addr;
                              qspi_erase_start_addr    <= qspi_erase_start_addr;
                              qspi_sdram_trans_st      <= r_qspi_calc_4k_block_end;
                              qspi_sdram_trans_st_next <= r_qspi_calc_4k_block_end;
                            end  
                             
            end
            r_qspi_calc_64k_block_end :begin
                           if(qspi_erase_end_addr  >= (qspi_erase_start_addr +17'h10000)) begin                     
                                number_of_erase_block  <= ({qspi_erase_end_addr[31:16],16'd0} - qspi_erase_start_addr)>>16;
                                dest_address_d         <= qspi_erase_start_addr;  
                                qspi_erase_start_addr  <= qspi_erase_start_addr +({qspi_erase_end_addr[31:16],16'd0} - qspi_erase_start_addr);
                                qspi_sdram_trans_st    <= r_qspi_64KB_erase_start;
                                //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                                qspi_sdram_trans_st_next <= r_qspi_calc_32k_block_end;
                           end
                           else begin
                               number_of_erase_block  <= 0;
                               //dest_address_d         <= qspi_erase_start_addr; 
                               qspi_erase_start_addr    <= qspi_erase_start_addr;
                               if((qspi_erase_end_addr - {qspi_erase_end_addr[31:16],16'd0}) > 0  )begin
                                  qspi_sdram_trans_st      <= r_qspi_calc_32k_block_end;
                                  qspi_sdram_trans_st_next <= r_qspi_calc_32k_block_end;
                               end
                               else begin
                                  qspi_sdram_trans_st      <=  r_qspi_erase_wait;
                                  //qspi_erase_enable   <= 1'b0;
                                  qspi_sdram_trans_st_next <= r_qspi_sdram_trans_idle;
                               end
                           end     
            end                
            r_qspi_calc_4k_block_start : begin               
                              if(qspi_erase_end_addr < (qspi_erase_start_addr +16'h8000))begin
                                if(qspi_erase_end_addr >= (qspi_erase_start_addr + 16'h1000))begin
                                    number_of_erase_block    <= (qspi_erase_end_addr- qspi_erase_start_addr)>>12;
                                    dest_address_d           <= qspi_erase_start_addr;
                                    qspi_erase_start_addr    <= qspi_erase_end_addr;
                                    qspi_sdram_trans_st      <= r_qspi_4KB_erase_start ;
                                    //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                                    qspi_sdram_trans_st_next <= r_qspi_sdram_trans_idle;
                                end
                                else begin
                                    number_of_erase_block    <= 0;
                                    //dest_address_d         <= qspi_erase_start_addr;
                                    qspi_erase_start_addr    <= qspi_erase_start_addr;
                                    qspi_sdram_trans_st      <= r_qspi_erase_wait;
                                    qspi_sdram_trans_st_next <= r_qspi_sdram_trans_idle;
                                    //qspi_erase_enable <= 1'b0;
                                end 
                              end
                              else begin
                                if(({qspi_erase_start_addr[31:16],16'h8000})> qspi_erase_start_addr) begin
                                  number_of_erase_block    <= ({qspi_erase_start_addr[31:16],16'h8000} - qspi_erase_start_addr)>>12;
                                  dest_address_d           <= qspi_erase_start_addr;
                                  qspi_erase_start_addr    <= {qspi_erase_start_addr[31:16],16'h8000};
                                  qspi_sdram_trans_st      <= r_qspi_4KB_erase_start ;
                                  //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                                  qspi_sdram_trans_st_next <= r_qspi_calc_32k_block_start;
                                end
                                else begin
                                      number_of_erase_block    <= (({qspi_erase_start_addr[31:16],16'h0000} + 17'h10000) - qspi_erase_start_addr)>>12;
                                      dest_address_d           <= qspi_erase_start_addr;
                                      qspi_erase_start_addr    <= ({qspi_erase_start_addr[31:16],16'h0000} + 17'h10000);
                                      qspi_sdram_trans_st      <= r_qspi_4KB_erase_start ;
                                      //qspi_sdram_trans_st     <= r_qspi_erase_wait;
                                      qspi_sdram_trans_st_next <= r_qspi_calc_64k_block_end;     
                                end  
                               end 
                                
            end
            
            
//            r_qspi_erase_start: begin
//                qspi_sdram_trans_st            <= r_qspi_64KB_erase_start;
//                //dest_address_d <= dest_address;
//                //src_address_d  <= src_address;
//                dest_address_d        <= qspi_addr;
//                //src_address_d         <= 32'h00060000;   
//            end
            
            r_qspi_64KB_erase_start : begin
                if(sector_erase_cnt == number_of_erase_block)begin
                    if(qspi_erase_64KB_enable)begin
                        qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_erase_wait;
                    end
//                    qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
//                    qspi_sdram_trans_st <= r_qspi_erase_wait;
                    sector_erase_cnt    <= 0;
                    dest_address_d      <= 0;
                    qspi_erase_64KB_enable <= 1'b0;
                end 
                else begin
                    qspi_sector_erase_rq      <= 1'b1;
                    qspi_send_addr             <= dest_address_d;
                    qspi_send_sector_erase_cmd <= `CMD_SE_64KB;
                    if(qspi_send_busy)begin
                        qspi_sdram_trans_st  <= r_qspi_64KB_erase_done;
                        qspi_sector_erase_rq <= 1'b0;
                        sector_erase_cnt     <= sector_erase_cnt + 1;
                        dest_address_d       <= dest_address_d + OFFSET_64KB;
                    end
                end    
            end     
            
            r_qspi_64KB_erase_done: begin
                if(!qspi_send_busy)begin
                    qspi_sdram_trans_st <= r_qspi_64KB_erase_start;
                end
            end
    
            r_qspi_32KB_erase_start : begin
                if(sector_erase_cnt == number_of_erase_block)begin
                    if(qspi_erase_32KB_enable)begin
                        qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_erase_wait;
                    end                
//                    qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
//                    qspi_sdram_trans_st <= r_qspi_erase_wait;
                    sector_erase_cnt    <= 0;
                    dest_address_d      <= 0;
                    qspi_erase_32KB_enable <= 1'b0;
                end 
                else begin
                    qspi_sector_erase_rq       <= 1'b1;
                    qspi_send_addr             <= dest_address_d;
                    qspi_send_sector_erase_cmd <= `CMD_SE_32KB;
                    if(qspi_send_busy)begin
                        qspi_sdram_trans_st  <= r_qspi_32KB_erase_done;
                        qspi_sector_erase_rq <= 1'b0;
                        sector_erase_cnt     <= sector_erase_cnt + 1;
                        dest_address_d       <= dest_address_d + OFFSET_32KB;
                    end
                end    
            end     
            
            r_qspi_32KB_erase_done: begin
                if(!qspi_send_busy)begin
                    qspi_sdram_trans_st <= r_qspi_32KB_erase_start;
                end
            end
    
            r_qspi_4KB_erase_start : begin
                if(sector_erase_cnt == number_of_erase_block)begin
                    if(qspi_erase_4KB_enable)begin
                        qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_erase_wait;
                    end                  
//                    qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
//                    qspi_sdram_trans_st <= r_qspi_erase_wait;
                    qspi_erase_4KB_enable <= 1'b0;
                    sector_erase_cnt    <= 0;
                    dest_address_d      <= 0;
                end 
                else begin
                    qspi_sector_erase_rq       <= 1'b1;
                    qspi_send_addr             <= dest_address_d;
                    qspi_send_sector_erase_cmd <= `CMD_SE_4KB;
                    if(qspi_send_busy)begin
                        qspi_sdram_trans_st  <= r_qspi_4KB_erase_done;
                        qspi_sector_erase_rq <= 1'b0;
                        sector_erase_cnt     <= sector_erase_cnt + 1;
                        dest_address_d       <= dest_address_d + OFFSET_4KB;
                    end
                end    
            end     
            
            r_qspi_4KB_erase_done: begin
                if(!qspi_send_busy)begin
                    qspi_sdram_trans_st <= r_qspi_4KB_erase_start;
                end
            end             



             r_qspi_rd_user_settings_wr: begin
                 temp_qspi_read_cnt <= 0;
                 if(data_trans_len_d > 0 )begin
                     qspi_mem_rd_rq    <= 1'b1;
                     qspi_send_addr    <= src_address_d;
                     qspi_send_rd_size <= qspi_block_rd_size;
                     qspi_send_cmd     <= `CMD_READ;
                     if(qspi_send_busy)begin
                          if(data_trans_len_d > qspi_block_rd_size)begin
                             data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
                          end
                          else begin
                             data_trans_len_d  <= 0;
                          end
                          src_address_d       <= src_address_d  + qspi_block_rd_size;
                          qspi_sdram_trans_st <= r_qspi_rd1_user_settings_wr;
                          qspi_mem_rd_rq      <= 1'b0; 
                          qspi_send_addr      <= 32'h00000000;  
                          qspi_send_cmd       <= 8'd0;   
                     end
                 end
                 else begin
                     qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                     if((switch_to_factory_settings_en_d == 1'b1) && (product_sel == 1'b0))begin
                        qspi_oled_init_wr_enable_latch <= 1'b1;
                     end
                     else begin
                        qspi_oled_init_wr_enable_latch <= 1'b0;
                     end

                     switch_to_factory_settings_en_d <= 1'b0;
                     data_trans_len_d  <= 0;
                     qspi_mem_rd_rq    <= 0;
                     qspi_send_rd_size <= 0;
                     qspi_send_cmd     <= 0; 
                     user_settings_mem_wr_addr_temp1 <= 0;
                     user_settings_mem_wr_addr1 <= 0;  
                     user_settings_init_start <= 1'b1;  
                     user_settings_mux_sel    <= 1'b1;
                     load_factory_settings_en <= 1'b0;
                     load_user_settings_en    <= 1'b0;  
                 end       
             end
             r_qspi_rd1_user_settings_wr : begin
                 user_settings_mem_wr_req1  <= 1'b0;
                 if(!qspi_send_busy)begin
                     if(temp_qspi_read_cnt == qspi_block_rd_size)begin
                         qspi_sdram_trans_st <= r_qspi_rd_user_settings_wr;
                         temp_qspi_read_cnt <=0;  
                     end
                     else begin
                         qspi_sdram_trans_st <= r_qspi_rd1_user_settings_wr;
                         if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
                             if(qspi_rd_cnt == 3)begin
                                 qspi_rx_rd_fifo_rq <= 1'b0;  
                             end
                             if(qspi_rd_cnt == 4)begin
                                 //st <= r_qspi_wr_user_settings;
                                 //st <= r_qspi_rd1_user_settings;
                                 qspi_rd_cnt <= 0;
                                 user_settings_mem_wr_req1       <= 1'b1;  
                                 user_settings_mem_wr_data1      <= user_settings_mem_wr_data1;
                                 user_settings_mem_wr_addr1      <= user_settings_mem_wr_addr_temp1; 
                                 user_settings_mem_wr_addr_temp1 <= user_settings_mem_wr_addr_temp1 +1;
                                 temp_qspi_read_cnt<= temp_qspi_read_cnt +4; 
                             end
                             else begin
                                 user_settings_mem_wr_data1 <= {qspi_rx_rd_fifo_data,user_settings_mem_wr_data1[31:8]};
                                 qspi_rd_cnt <= qspi_rd_cnt +1;
                             end 
                         end
                         else begin
                                 qspi_rx_rd_fifo_rq <= 1'b1;
                         end
                      end          
                 end
             end    



              r_qspi_to_bram_rd_reticle:begin
               qspi_reticle_transfer_rq_ack <= 1'b0;
               temp_qspi_read_cnt  <=0;
               if(data_trans_len_d > 0 )begin
                    qspi_mem_rd_rq    <= 1'b1;
                    qspi_send_addr    <= src_address_d;
                    qspi_send_rd_size <= qspi_block_rd_size;
                    qspi_send_cmd     <= `CMD_READ;
                    if(qspi_send_busy)begin
                         if(data_trans_len_d > qspi_block_rd_size)begin
                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
                         end
                         else begin
                            data_trans_len_d  <= 0;
                         end
                         src_address_d       <= src_address_d  + qspi_block_rd_size;                
                         qspi_sdram_trans_st <= r_qspi_to_bram_rd1_reticle;
                         qspi_mem_rd_rq      <= 1'b0; 
                         qspi_send_addr      <= 32'h00000000;  
                         //qspi_send_rd_size <= 0;
                         qspi_send_cmd       <= 8'd0;   
                    end
                end    
                 else begin
                    qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                    data_trans_len_d    <= 0;
                    qspi_mem_rd_rq      <= 0;
                    qspi_send_rd_size   <= 0;
                    qspi_send_cmd       <= 0;  
                    time_cnt_Start      <= 1'b0;        
                    qspi_reticle_transfer_done <= 1'b1; 
                end              
            end

            
            r_qspi_to_bram_rd1_reticle: begin
                RETICLE_WR_EN   <= 1'b0;
                if(!qspi_send_busy)begin
                    if(temp_qspi_read_cnt == qspi_block_rd_size )begin
                        qspi_sdram_trans_st <= r_qspi_to_bram_rd_reticle;
                        temp_qspi_read_cnt  <=0;
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_to_bram_rd1_reticle;             
                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
                            if(qspi_rd_cnt == 3)begin
                                qspi_rx_rd_fifo_rq <= 1'b0;  
                            end
                            if(qspi_rd_cnt == 4)begin
                                qspi_rd_cnt          <= 0;
                                qspi_sdram_trans_st  <= r_qspi_to_bram_reticle_write;
                                temp_qspi_read_cnt   <= temp_qspi_read_cnt +4; 
                                RETICLE_WR_DATA      <= RETICLE_WR_DATA;
                            end
                            else begin
                                RETICLE_WR_DATA <= {qspi_rx_rd_fifo_data,RETICLE_WR_DATA[31:8]};
                                qspi_rd_cnt <= qspi_rd_cnt +1;
                                
                            end              
                        end
                        else begin
                                qspi_rx_rd_fifo_rq <= 1'b1;
                        end
                     end          
                end            
             end 
            
            r_qspi_to_bram_reticle_write: begin
                RETICLE_WR_DATA     <= RETICLE_WR_DATA;
                RETICLE_WR_EN       <= 1'b1;
                qspi_sdram_trans_st <= r_qspi_to_bram_rd1_reticle;
            end

            
            r_qspi_to_sdram_data_transfer : begin
                src_address_d       <= qspi_addr;
                dest_address_d      <= sdram_addr;
                data_trans_len_d    <= qspi_trans_len;
                qspi_sdram_trans_st <= r_qspi_rd_data_transfer;                   
            end
            
            r_qspi_rd_data_transfer: begin
                if(data_trans_len_d > 0 )begin
                    qspi_mem_rd_rq    <= 1'b1;
                    qspi_send_addr    <= src_address_d;
                    sdram_send_adddr  <= dest_address_d;
                    qspi_send_rd_size <= qspi_block_rd_size;
                    qspi_send_cmd     <= `CMD_READ;
                    if(qspi_send_busy)begin
                         if(data_trans_len_d > qspi_block_rd_size)begin
                            data_trans_len_d  <= data_trans_len_d - qspi_block_rd_size;
                         end
                         else begin
                            data_trans_len_d  <= 0;
                         end
                         src_address_d     <= src_address_d  + qspi_block_rd_size;
                         dest_address_d    <= dest_address_d + qspi_block_rd_size;
                         qspi_sdram_trans_st <= r_qspi_rd1_data_transfer;
                         sdram_send_adddr  <= sdram_send_adddr;
                         qspi_mem_rd_rq    <= 1'b0; 
                         qspi_send_addr    <= 32'h00000000;  
                         //qspi_send_rd_size <= 0;
                         qspi_send_cmd     <= 8'd0;   
                    end
                end
                else begin
                    qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                    data_trans_len_d  <= 0;
                    sdram_send_adddr  <= 0;
                    qspi_mem_rd_rq    <= 0;
                    qspi_send_rd_size <= 0;
                    qspi_send_cmd     <= 0; 
                    gain_wr_done      <= 1'b1;  
                    rd_qspi_wr_sdram_enable <= 1'b0;
                    qspi_init_cmd_done <= 1'b1; 
                    ch_img_sum_temp <= 64'd0;
                    ch_img_sum <= ch_img_sum_temp;      
                end       
            end
            r_qspi_rd1_data_transfer : begin
                if(!qspi_send_busy)begin
                    if(temp_qspi_read_cnt == qspi_block_rd_size)begin
                        qspi_sdram_trans_st <= r_qspi_rd_data_transfer;
                        temp_qspi_read_cnt <=0;
                        sdram_write_byte_cnt<=0;  
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_rd1_data_transfer;
                        if(qspi_rx_rd_fifo_rq== 1'b1 || (qspi_rd_cnt == 4) )begin
                            
                            if(qspi_rd_cnt == 3)begin
                                qspi_rx_rd_fifo_rq <= 1'b0;  
                            end
                            if(qspi_rd_cnt == 4)begin
                                qspi_rd_cnt <= 0;
                                qspi_sdram_trans_st <= r_sdram_write1_data_transfer;
                                temp_qspi_read_cnt<= temp_qspi_read_cnt +4; 
                                sdram_write_data <= sdram_write_data;
                            end
                            else begin
                                sdram_write_data <= {qspi_rx_rd_fifo_data,sdram_write_data[31:8]};
                                qspi_rd_cnt <= qspi_rd_cnt +1;
                                
                            end 
                        end
                        else begin
                                qspi_rx_rd_fifo_rq <= 1'b1;
                        end
                     end          
                end
            end
            
            r_sdram_write1_data_transfer: begin
                if(sdram_write_byte_cnt == 256)begin
                    qspi_sdram_trans_st  <= r_qspi_rd_data_transfer; 
                    sdram_write_byte_cnt <= 0;   
                end
                else begin
                    sdram_write_byte_cnt <= sdram_write_byte_cnt + 4;
                    qspi_sdram_trans_st  <= r_sdram_write2_data_transfer;
                    sdram_write_data <= sdram_write_data;
                    ch_img_sum_temp <= ch_img_sum_temp + sdram_write_data[15:0] +sdram_write_data[31:16];
                    if(sdram_write_byte_cnt==0)begin
                        sdram_write_addr <= sdram_send_adddr;//32'h00f00000;
                    end
                    else begin
                        sdram_write_addr <= sdram_write_addr + 4; 
                    end    
                               
                end                           
            end           
            r_sdram_write2_data_transfer: begin
                av_wrsdram_address    <= sdram_write_addr;  
                av_wrsdram_burstcount <= 1;
                av_wrsdram_write      <= 1'b1;
                av_wrsdram_writeburst <= 1'b1;
                av_wrsdram_writedata  <= sdram_write_data;//32'hAABBCCDD;
                burst_count           <= 1;
                qspi_sdram_trans_st   <= r_sdram_write3_data_transfer;
            end
            r_sdram_write3_data_transfer: begin    
                av_wrsdram_write      <= 1'b1;
                if ((!av_wrsdram_waitrequest)) begin
                    av_wrsdram_writeburst <= 1'b0;
                    av_wrsdram_writedata  <= 0;//32'h11223344;
                    burst_count <= (burst_count - 1);
                    if ((burst_count == 1)) begin
                        av_wrsdram_write    <= 1'b0;
                        qspi_sdram_trans_st <= r_qspi_rd1_data_transfer;
                    end
                end
            end
            
                        
              
            r_sdram_to_qspi_data_transfer : begin
                qspi_sdram_trans_st  <= r_qspi_page_wr_start;
                //dest_address_d <= dest_address;
                //src_address_d  <= src_address;
                dest_address_d        <= qspi_addr;
                src_address_d         <= sdram_addr;  
                if((qspi_addr >= QSPI_ADDR_OFFM_TEMP_1) && (qspi_addr <= QSPI_ADDR_OFFM_TEMP_45))begin
                    //temperature_wr_rq   <= 1'b1; 
                    qspi_temperature_wr_enable_d <= 1'b1;
                end
                else begin
                    qspi_temperature_wr_enable_d <= 1'b0;
                    //temperature_wr_rq   <= 1'b0; 
                end
                                                                                    
            end
                    
            r_qspi_page_wr_start: begin
                //temperature_wr_rq <= 1'b0;
                if(page_wr_cnt == qspi_trans_len)begin
//                    qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                    qspi_sdram_trans_enable <= 1'b0;
                    
                    qspi_user_settings_trans_en <= 1'b0;
                    
                    if((qspi_user_settings_trans_en== 1'b1) && (product_sel == 1'b0))begin
                        qspi_oled_init_wr_enable <= 1'b1;
                    end
                    else begin
                        qspi_oled_init_wr_enable <= 1'b0;
                    end
                    
                    qspi_init_cmd_done <= 1'b1;
                    page_wr_cnt <= 0;
                    
                    user_settings_mem_rd_addr_temp1 <= 0;
                    
                    if(snapshot_save_en == 1'b1)begin
                        snapshot_save_done        <= 1'b1;
                        gallery_img_valid_save_en <= 1'b1;
                    end
                    snapshot_save_en   <= 1'b0;
                    if(switch_to_factory_settings_en_d)begin
                        qspi_sdram_trans_st <= r_qspi_rd_user_settings_wr;
                        data_trans_len_d    <= QSPI_ADDR_USER_SETTINGS_DATA_SIZE;
                        src_address_d       <= QSPI_ADDR_USER_SETTINGS_DATA;
                        user_settings_mux_sel    <= 1'b0;
                    end
                    else begin
                        qspi_sdram_trans_st <= r_qspi_sdram_trans_idle;
                        user_settings_mux_sel    <= 1'b1;
                    end
                    
                    if(qspi_temperature_wr_enable_d == 1'b1 || snapshot_save_en == 1'b1)begin
                        qspi_temperature_wr_enable   <= 1'b1;
                        qspi_temperature_wr_enable_d <= 1'b0;
                        qspi_addr                    <= QSPI_ADDR_TEMPERATURE_DATA ;     
                        qspi_trans_len               <= QSPI_TEMPERATURE_DATA_BLOCK_SIZE ; 
                    end
                end
                else begin             
                    qspi_page_wr_rq <= 1'b1;
                    qspi_send_addr   <= dest_address_d;
                    sdram_send_adddr <= src_address_d;
    
                    if(qspi_send_busy)begin
                        qspi_sdram_trans_st <= r_sdram_rd_rq;
                        qspi_page_wr_rq <= 1'b0;
                        page_wr_cnt <= page_wr_cnt + 1;
                        dest_address_d <= dest_address_d + 32'd256;
                        src_address_d  <= src_address_d + 32'd256;
                    end 
                end    
            end
            r_qspi_page_wr_done: begin
                if(!qspi_send_busy)begin
                    qspi_sdram_trans_st<= r_qspi_page_wr_start;
                end
            end 
       
            r_sdram_read1 : begin       
                av_rdsdram_address <= sdram_read_addr;
                //sdram_read_addr    <= sdram_read_addr+4;  
                av_rdsdram_burstcount <= 1;
                av_rdsdram_read <= 1'b1;
                burst_count     <= 1;
                qspi_sdram_trans_st<= r_sdram_read2; 
            end
            r_sdram_read2 : begin 
                if ((!av_rdsdram_waitrequest)) begin
                    av_rdsdram_read <= 1'b0;
                end
                if (av_rdsdram_readdatavalid) begin
                    burst_count    <= burst_count - 1;
                    sdram_read_data <= av_rdsdram_readdata;
                    if ((burst_count == 1)) begin
                        read_done <= 1'b0;
                        qspi_sdram_trans_st<= r_qspi_wr;
                    end
                end
            end

            r_user_settings_rd_rq :begin
                user_settings_mem_rd_req1       <= 1'b1;  
                user_settings_mem_rd_addr1      <= user_settings_mem_rd_addr_temp1; 
                user_settings_mem_rd_addr_temp1 <= user_settings_mem_rd_addr_temp1 +1;
                qspi_sdram_trans_st             <= r_user_settings_rd_wait;
            end 
            
            r_user_settings_rd_wait: begin
                user_settings_mem_rd_req1       <= 1'b0; 
                qspi_sdram_trans_st             <= r_user_settings_rd_data;
            end
            r_user_settings_rd_data : begin
                 user_settings_mem_rd_data1_temp <=  user_settings_mem_rd_data1;
                 qspi_sdram_trans_st <= r_qspi_wr; 
            end
            


            
            
            r_sdram_rd_rq: begin
                if(read_sdram_data_rq)begin     
                    if(sdram_read_byte_cnt == 256)begin
                        sdram_read_byte_cnt <= 0;
                        qspi_sdram_trans_st <= r_qspi_page_wr_done;//r_qspi_wr;//r_qspi_rd;//r_qspi_rd_init;//r_idle;
                        //sdram_send_adddr    <= 0; 
                        sdram_write_byte_cnt <= 0 ;      
                    end
                    else begin
//                        qspi_sdram_trans_st <=r_sdram_read1;
//                        sdram_read_byte_cnt <= sdram_read_byte_cnt + 4;
//                        if(sdram_read_byte_cnt == 0)begin
//                            sdram_read_addr <= sdram_send_adddr;//32'h00f00000;
//                        end       
//                        else begin
//                            sdram_read_addr <= sdram_read_addr + 4;
//                        end  

                         if(qspi_user_settings_trans_en)begin
                             qspi_sdram_trans_st <=r_user_settings_rd_rq;
                         end
                         else begin
                             qspi_sdram_trans_st <=r_sdram_read1;
                         end
                         sdram_read_byte_cnt <= sdram_read_byte_cnt + 4;
                         if(sdram_read_byte_cnt == 0)begin
                             sdram_read_addr <= sdram_send_adddr;//32'h00f00000;
                         end       
                         else begin
                             sdram_read_addr <= sdram_read_addr + 4;
                         end  

                    end        
                end
    
            end
            r_qspi_wr: begin
                if(qspi_wr_cnt == 4)begin
                    qspi_wr_cnt <= 0;
                    qspi_sdram_trans_st <=r_sdram_rd_rq;
                    qspi_wr_data_valid <= 1'b0; 
                    qspi_wr_data <= 0;     
                end
                else begin
//                    qspi_wr_data <= sdram_read_data[7:0] ;//sdram_read_data[7:0];
//                    sdram_read_data <= {sdram_read_data[7:0],sdram_read_data[31:8]};
//                    qspi_wr_data_valid <= 1'b1; 
//                    qspi_wr_cnt <= qspi_wr_cnt +1;
//                    temp_qspi_write_cnt<= temp_qspi_write_cnt +1;
                    if(qspi_user_settings_trans_en)begin
                        qspi_wr_data  <= user_settings_mem_rd_data1_temp[7:0];
                        user_settings_mem_rd_data1_temp <={user_settings_mem_rd_data1_temp[7:0],user_settings_mem_rd_data1_temp[31:8]};
                    end
                    else begin
                        qspi_wr_data <= sdram_read_data[7:0] ;//sdram_read_data[7:0];
                        sdram_read_data <= {sdram_read_data[7:0],sdram_read_data[31:8]};
                    end
                    qspi_wr_data_valid <= 1'b1; 
                    qspi_wr_cnt <= qspi_wr_cnt +1;
                    temp_qspi_write_cnt<= temp_qspi_write_cnt +1;


                end  
            end
        endcase

        case(qspi_temperature_wr_st)
            r_qspi_temperature_page_wr_idle: begin
               gallery_img_valid_save_done <= 1'b0;
               if(qspi_temperature_wr_enable) begin
                    qspi_erase_4KB_enable  <= 1'b1;
                    number_of_erase_block  <= 1;
                    qspi_addr              <= QSPI_ADDR_TEMPERATURE_DATA;
                    qspi_temperature_wr_st <= r_qspi_temperature_page_erase_wait;
                end
                else begin
                    qspi_temperature_wr_st <= r_qspi_temperature_page_wr_idle;
                end    
            end   
            r_qspi_temperature_page_erase_wait:begin
                if(qspi_erase_4KB_enable == 1'b0)begin
                    qspi_temperature_wr_st <= r_qspi_temperature_page_wr_start; 
                    dest_address_d         <= QSPI_ADDR_TEMPERATURE_DATA ;          
                    data_trans_len_d       <= QSPI_TEMPERATURE_DATA_BLOCK_SIZE ;   
                end
                else begin
                    qspi_temperature_wr_st <= r_qspi_temperature_page_erase_wait;
                end        
            end     
            r_qspi_temperature_page_wr_start: begin
                if(page_wr_cnt == data_trans_len_d)begin
                    qspi_temperature_wr_st     <= r_qspi_temperature_page_wr_idle;
                    qspi_temperature_wr_enable <= 1'b0;
                    if(gallery_img_valid_save_en)begin
                        gallery_img_valid_save_done <= 1'b1;
                        gallery_img_valid_save_en   <= 1'b0;
                    end
                    page_wr_cnt                <= 0;
                end
                else begin             
                    qspi_page_wr_rq <= 1'b1;
                    qspi_send_addr   <= dest_address_d;       
                    if(qspi_send_busy)begin
                        qspi_temperature_wr_st <=  r_temperature_rd1;
                        qspi_page_wr_rq <= 1'b0;
                        page_wr_cnt <= page_wr_cnt + 1;
                        dest_address_d <= dest_address_d + 32'd256;
                    end 
                end    
            end

            r_qspi_temperature_page_wr_done: begin
                if(!qspi_send_busy)begin
                    qspi_temperature_wr_st<= r_qspi_temperature_page_wr_start;
                end
            end 
            
            r_temperature_rd1 : begin   
               if(read_sdram_data_rq)begin       
                 if(temperature_rd_byte_cnt == 256)begin
                     temperature_rd_byte_cnt <= 0;
                     qspi_temperature_wr_st <= r_qspi_temperature_page_wr_done;//r_qspi_wr;//r_qspi_rd;//r_qspi_rd_init;//r_idle; 
                     temperature_rd_rq       <= 1'b0;
                 end
                 else begin
                     qspi_temperature_wr_st <= r_temperature_rd2;
                     temperature_rd_rq       <= 1'b1;
                     temperature_rd_byte_cnt <= temperature_rd_byte_cnt + 2; 
                 end 
               end          
             end
            r_temperature_rd2:begin
                temperature_rd_rq       <= 1'b0;
                if(temperature_rd_data_valid)begin
                    qspi_temperature_wr_st <= r_qspi_temperature_wr;
                    temperature_rd_data_temp <= temperature_rd_data;
                end    
                else begin
                    qspi_temperature_wr_st   <= r_temperature_rd2;
                    temperature_rd_data_temp <= temperature_rd_data_temp;
                end
            end

            r_qspi_temperature_wr: begin 
                if(qspi_wr_cnt == 2)begin
                    qspi_wr_cnt <= 0;
                    qspi_temperature_wr_st <= r_temperature_rd1;
                    qspi_wr_data_valid <= 1'b0; 
                    qspi_wr_data <= 0;     
                end
                else begin
                    qspi_wr_data             <= temperature_rd_data_temp[7:0] ;//sdram_read_data[7:0];
                    temperature_rd_data_temp <= {temperature_rd_data_temp[7:0],temperature_rd_data_temp[15:8]};
                    qspi_wr_data_valid       <= 1'b1; 
                    qspi_wr_cnt              <= qspi_wr_cnt +1;
                end  
            end
        endcase             
        


        case(qspi_oled_init_wr_st)
            r_qspi_oled_init_wr_idle: begin
               if(av_i2c_write==1'b1 && oled_init_done ==1'b1 && (av_i2c_address[15:8]== OLED_DEV_ADDR) && oled_reinit_start == 1'b0 )begin
                   oled_init_mem_wr_data <= {8'd0,av_i2c_writedata[7:0],8'd0,av_i2c_address[7:0]};  
                   case (av_i2c_address[7:0])
                    8'h01 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_vinmode_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
                    8'h07 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_brightness_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end 
                    8'h08 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_contrast_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
//                    8'h0F : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_gammaset_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end
//                    8'h10 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_vcommode_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end
//                    8'h14 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_idrf_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end
//                    8'h15 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_dimctl_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end
//                    8'h1C : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_tpmode_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end
//                    8'h21 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_lut_addr_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end                                                                                                                                                                                                                                               
//                    8'h22 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_lut_datal_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end 
//                    8'h23 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_lut_datah_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end 
//                    8'h24 : begin
//                        oled_init_mem_wr_addr  <= oled_init_mem_lut_update_addr;
//                        oled_init_mem_wr_req   <= 1'b1;   
//                    end   
//                    8'h02 : begin
                    8'h30 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_dispmode_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
                    8'h31 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_lftpos_msb_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end                    
//                    8'h03 : begin
                    8'h32 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_lftpos_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
                    8'h33 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_rgtpos_msb_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end                    
//                    8'h04 : begin
                    8'h34 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_rgtpos_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
//                    8'h05 : begin
                    8'h35 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_toppos_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
//                    8'h06 : begin
                    8'h36 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_botpos_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
                    8'h37 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_row_start_msb_addr;
                        oled_init_mem_wr_req   <= 1'b1;   
                    end
                    8'h38 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_row_start_lsb_addr;
                        oled_init_mem_wr_req   <= 1'b1;                      
                    end
                    8'h39 : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_row_end_msb_addr;
                        oled_init_mem_wr_req   <= 1'b1;                      
                    end
                    8'h3A : begin
                        oled_init_mem_wr_addr  <= oled_init_mem_row_end_lsb_addr;
                        oled_init_mem_wr_req   <= 1'b1;                      
                    end
                    default :begin
                        oled_init_mem_wr_addr  <= 0;
                        oled_init_mem_wr_req   <= 1'b0;                                                            
                    end                   
                   endcase     
                   qspi_oled_init_wr_st <= r_qspi_oled_init_wr_idle1;                                    
               end
               else if((OLED_POS_V_VALID || OLED_POS_H_VALID || OLED_BRIGHTNESS_VALID || OLED_CONTRAST_VALID || OLED_IDRF_VALID || OLED_DIMCTL_VALID || OLED_IMG_FLIP_VALID || OLED_ROW_START_MSB_VALID || OLED_ROW_START_LSB_VALID || OLED_ROW_END_MSB_VALID || OLED_ROW_END_LSB_VALID ||  oled_init_mem_rgtpos_wr_en || oled_init_mem_lftpos_wr_en || oled_init_mem_lftpos_msb_wr_en || oled_init_mem_botpos_wr_en) &&(oled_init_done ==1'b1))begin
                  qspi_oled_init_wr_st <= r_qspi_oled_init_wr_idle1; 
                  if(OLED_BRIGHTNESS_VALID == 1'b1)begin
//                    oled_init_mem_wr_data <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_BRIGHTNESS_REG_ADDR};
                    oled_init_mem_wr_data <= {8'd0,OLED_BRIGHTNESS,8'd0,OLED_BRIGHTNESS_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_brightness_addr;
                  end
                  else if(OLED_CONTRAST_VALID == 1'b1)begin  
//                    oled_init_mem_wr_data <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_CONTRAST_REG_ADDR};
                    oled_init_mem_wr_data <= {8'd0,OLED_CONTRAST,8'd0,OLED_CONTRAST_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_contrast_addr;
                  end  
                  else if(OLED_IDRF_VALID == 1'b1)begin
//                    oled_init_mem_wr_data <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_IDRF_REG_ADDR};
                    oled_init_mem_wr_data <= {8'd0,OLED_IDRF,8'd0,OLED_IDRF_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_idrf_addr;
                  end
                  else if(OLED_DIMCTL_VALID == 1'b1)begin
//                    oled_init_mem_wr_data <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_DIMCTL_REG_ADDR};
                    oled_init_mem_wr_data <= {8'd0,OLED_DIMCTL,8'd0,OLED_DIMCTL_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_dimctl_addr;           
                  end
                  else if(OLED_IMG_FLIP_VALID == 1'b1)begin
                    oled_init_mem_wr_data <= {8'd0,OLED_IMG_FLIP,8'd0,OLED_DISPMODE_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_dispmode_addr;           
                  end
                  else if(OLED_ROW_START_MSB_VALID == 1'b1)begin
                    oled_init_mem_wr_data <= {8'd0,OLED_ROW_START_MSB,8'd0,OLED_ROW_START_MSB_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_row_start_msb_addr;           
                  end
                  else if(OLED_ROW_START_LSB_VALID == 1'b1)begin
                    oled_init_mem_wr_data <= {8'd0,OLED_ROW_START_LSB,8'd0,OLED_ROW_START_LSB_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_row_start_lsb_addr;           
                  end
                  else if(OLED_ROW_END_MSB_VALID == 1'b1)begin
                    oled_init_mem_wr_data <= {8'd0,OLED_ROW_END_MSB,8'd0,OLED_ROW_END_MSB_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_row_end_msb_addr;           
                  end
                  else if(OLED_ROW_END_LSB_VALID == 1'b1)begin
                    oled_init_mem_wr_data <= {8'd0,OLED_ROW_END_LSB,8'd0,OLED_ROW_END_LSB_REG_ADDR}; 
                    oled_init_mem_wr_req  <= 1'b1;
                    oled_init_mem_wr_addr <= oled_init_mem_row_end_lsb_addr;           
                  end                                    
                  else if(OLED_POS_V_VALID == 1'b1)begin
//                    if(OLED_REG_DATA_IN > OLED_POS_MAX_OFFSET)begin
                    if(OLED_POS_V > OLED_POS_V_MAX_OFFSET)begin
                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_V_MAX_OFFSET,8'd0,OLED_TOPPOS_REG_ADDR}; 
//                        oled_init_mem_botpos_wr_data <= 0;                      
                    end
                    else begin    
//                        oled_init_mem_wr_data        <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_TOPPOS_REG_ADDR};
                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_V,8'd0,OLED_TOPPOS_REG_ADDR};                        
////                        oled_init_mem_botpos_wr_data <= OLED_POS_MAX_OFFSET - OLED_REG_DATA_IN;
//                        oled_init_mem_botpos_wr_data <= OLED_POS_V_MAX_OFFSET - OLED_POS_V;
                    end
                    oled_init_mem_botpos_wr_data <= 0;
                    oled_init_mem_wr_addr      <= oled_init_mem_toppos_addr;
                    oled_init_mem_wr_req       <= 1'b1;
                    oled_init_mem_botpos_wr_en <= 1'b1;                                         
                  end
                  else if(OLED_POS_H_VALID == 1'b1)begin
//                    if(OLED_REG_DATA_IN > OLED_POS_MAX_OFFSET)begin
                    if(OLED_POS_H > OLED_POS_H_MAX_OFFSET)begin
//                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_H_MAX_OFFSET,8'd0,OLED_LFTPOS_REG_ADDR};
                        oled_init_mem_wr_data        <= {8'd0,7'd0,OLED_POS_H_MAX_OFFSET[8],8'd0,OLED_RGTPOS_MSB_REG_ADDR}; 
//                        oled_init_mem_rgtpos_wr_data <= 0;                      
                    end
                    else begin    
//                        oled_init_mem_wr_data        <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_LFTPOS_REG_ADDR};
//                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_H,8'd0,OLED_LFTPOS_REG_ADDR};
                        oled_init_mem_wr_data        <= {8'd0,7'd0,OLED_POS_H[8],8'd0,OLED_RGTPOS_MSB_REG_ADDR};
////                        oled_init_mem_rgtpos_wr_data <= OLED_POS_MAX_OFFSET - OLED_REG_DATA_IN;
//                        oled_init_mem_rgtpos_wr_data <= OLED_POS_H_MAX_OFFSET - OLED_POS_H;
                    end

                    if(OLED_POS_H < 336)begin
                        oled_init_mem_lftpos_wr_data <= 336- OLED_POS_H;
                    end
                    else begin
                        oled_init_mem_lftpos_wr_data <= 0;
                    end 
                    oled_init_mem_wr_addr      <= oled_init_mem_rgtpos_msb_addr;
                    oled_init_mem_wr_req       <= 1'b1;
                    oled_init_mem_rgtpos_wr_en <= 1'b1;                  
                  end
                  else if(oled_init_mem_rgtpos_wr_en == 1'b1)begin
//                    oled_init_mem_wr_data      <= {8'd0,oled_init_mem_rgtpos_wr_data,8'd0,OLED_RGTPOS_REG_ADDR};                    
                    if(OLED_POS_H > OLED_POS_H_MAX_OFFSET)begin
//                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_H_MAX_OFFSET,8'd0,OLED_LFTPOS_REG_ADDR};
                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_H_MAX_OFFSET[7:0],8'd0,OLED_RGTPOS_REG_ADDR}; 
//                        oled_init_mem_rgtpos_wr_data <= 0;                      
                    end
                    else begin    
//                        oled_init_mem_wr_data        <= {8'd0,OLED_REG_DATA_IN,8'd0,OLED_LFTPOS_REG_ADDR};
//                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_H,8'd0,OLED_LFTPOS_REG_ADDR};
                        oled_init_mem_wr_data        <= {8'd0,OLED_POS_H[7:0],8'd0,OLED_RGTPOS_REG_ADDR};
////                        oled_init_mem_rgtpos_wr_data <= OLED_POS_MAX_OFFSET - OLED_REG_DATA_IN;
//                        oled_init_mem_rgtpos_wr_data <= OLED_POS_H_MAX_OFFSET - OLED_POS_H;
                    end
                    oled_init_mem_wr_addr      <= oled_init_mem_rgtpos_addr;
                    oled_init_mem_wr_req       <= 1'b1;
                    oled_init_mem_rgtpos_wr_en <= 1'b0;    
                    oled_init_mem_lftpos_wr_en <= 1'b1;        
                  end             
                  else if(oled_init_mem_botpos_wr_en == 1'b1)begin
                    oled_init_mem_wr_data      <= {8'd0,oled_init_mem_botpos_wr_data,8'd0,OLED_BOTPOS_REG_ADDR};             
                    oled_init_mem_wr_addr      <= oled_init_mem_botpos_addr;
                    oled_init_mem_wr_req       <= 1'b1;
                    oled_init_mem_botpos_wr_en <= 1'b0; 
                  end
                  else if(oled_init_mem_lftpos_wr_en == 1'b1)begin
//                    oled_init_mem_wr_data      <= {8'd0,oled_init_mem_rgtpos_wr_data,8'd0,OLED_RGTPOS_REG_ADDR};                    
                    oled_init_mem_wr_data      <= {8'd0,oled_init_mem_lftpos_wr_data[7:0],8'd0,OLED_LFTPOS_REG_ADDR};
                    oled_init_mem_wr_addr      <= oled_init_mem_lftpos_addr;
                    oled_init_mem_wr_req       <= 1'b1;
                    oled_init_mem_lftpos_wr_en <= 1'b0;     
                    oled_init_mem_lftpos_msb_wr_en <= 1'b1;       
                  end
                  else if(oled_init_mem_lftpos_msb_wr_en == 1'b1)begin
//                    oled_init_mem_wr_data      <= {8'd0,oled_init_mem_rgtpos_wr_data,8'd0,OLED_RGTPOS_REG_ADDR};                    
                    oled_init_mem_wr_data      <= {8'd0,7'd0,oled_init_mem_lftpos_wr_data[8],8'd0,OLED_LFTPOS_MSB_REG_ADDR};
                    oled_init_mem_wr_addr      <= oled_init_mem_lftpos_msb_addr;
                    oled_init_mem_wr_req       <= 1'b1;
                    oled_init_mem_lftpos_msb_wr_en <= 1'b0;          
                  end                  
               end
               else if((qspi_oled_init_wr_enable == 1'b1)||((qspi_oled_init_wr_enable_latch==1'b1) && (user_settings_init_done==1'b1))) begin
                   qspi_erase_4KB_enable <= 1'b1;            
                   qspi_addr             <= QSPI_ADDR_OLED_INIT_DATA ;     
                   number_of_erase_block <= 1;   
                   qspi_oled_init_wr_st  <= r_qspi_oled_init_page_erase_wait;                     
               end
               else begin
                   qspi_oled_init_wr_st <= r_qspi_oled_init_wr_idle;
               end    
            end      

            r_qspi_oled_init_wr_idle1: begin
                oled_init_mem_wr_req   <= 1'b0;
                qspi_oled_init_wr_st <= r_qspi_oled_init_wr_idle;   
            end
            
            r_qspi_oled_init_page_erase_wait:begin
                if(qspi_erase_4KB_enable == 1'b0)begin
                    dest_address_d       <= QSPI_ADDR_OLED_INIT_DATA ;     
                    data_trans_len_d     <= QSPI_OLED_INIT_DATA_BLOCK_SIZE ; 
                    qspi_oled_init_wr_st <= r_qspi_oled_init_page_wr_start ;
                end
                else begin
                    qspi_oled_init_wr_st <= r_qspi_oled_init_page_erase_wait;
                end
            end     
            
            r_qspi_oled_init_page_wr_start: begin
                if(page_wr_cnt == data_trans_len_d)begin
                    qspi_oled_init_wr_st     <= r_qspi_oled_init_wr_idle;
                    qspi_oled_init_wr_enable <= 1'b0;
                    qspi_oled_init_wr_enable_latch <= 1'b0;
                    page_wr_cnt              <= 0;
                end
                else begin             
                    qspi_page_wr_rq  <= 1'b1;
                    qspi_send_addr   <= dest_address_d;       
                    if(qspi_send_busy)begin
                        qspi_oled_init_wr_st <=  r_oled_init_rd1;
                        qspi_page_wr_rq      <= 1'b0;
                        page_wr_cnt          <= page_wr_cnt + 1;
                        dest_address_d       <= dest_address_d + 32'd256;
                    end 
                end    
            end

            r_qspi_oled_init_page_wr_done: begin
                if(!qspi_send_busy)begin
                    qspi_oled_init_wr_st <= r_qspi_oled_init_page_wr_start;
                end
            end 

            r_oled_init_rd1 : begin   
               if(read_sdram_data_rq)begin       
                 if(oled_init_rd_byte_cnt == 256)begin
                     oled_init_rd_byte_cnt <= 0;
                     qspi_oled_init_wr_st  <= r_qspi_oled_init_page_wr_done;
                     oled_init_mem_rd_req  <= 1'b0;
                 end
                 else begin
                     qspi_oled_init_wr_st   <= r_oled_init_rd2;
                     oled_init_mem_rd_addr  <= oled_init_mem_rd_addr_temp;
                     oled_init_mem_rd_req   <= 1'b1;
                     oled_init_rd_byte_cnt  <= oled_init_rd_byte_cnt + 2; 
                 end 
               end          
             end
            r_oled_init_rd2:begin
                oled_init_mem_rd_req   <= 1'b0;
                qspi_oled_init_wr_st   <= r_oled_init_rd3;
            end
            
            r_oled_init_rd3:begin
                oled_init_rd_data_temp     <= oled_init_mem_rd_data;
                oled_init_mem_rd_addr_temp <= oled_init_mem_rd_addr_temp +1;
                qspi_oled_init_wr_st       <= r_qspi_oled_init_wr;
            end
            
            r_qspi_oled_init_wr: begin 
                if(qspi_wr_cnt == 4)begin
                    qspi_wr_cnt          <= 0;
                    qspi_oled_init_wr_st <= r_oled_init_rd1;
                    qspi_wr_data_valid   <= 1'b0; 
                    qspi_wr_data         <= 0;     
                end
                else begin
                    qspi_wr_data           <= oled_init_rd_data_temp[7:0] ;//sdram_read_data[7:0];
                    oled_init_rd_data_temp <= {oled_init_rd_data_temp[7:0],oled_init_rd_data_temp[31:8]};
                    qspi_wr_data_valid     <= 1'b1; 
                    qspi_wr_cnt            <= qspi_wr_cnt +1;
                end  
            end
        endcase      

        case(st_oled_reinit)
            r_oled_reinit_idle : begin
                oled_reint_wait_cnt <= 0;
//                if(oled_reinit_en)begin
                if ((!standby_en) && standby_en_valid)begin  // oled reinit
                   st_oled_reinit            <= r_oled_reinit_wait;
//                   oled_power_off        <= 1'b0;
                   oled_reinit_start         <= 1'b1;
                   oled_standby_process_busy <= 1'b1;
                end
//                else if(adv_sleep_mode_en)begin
                else if (standby_en && standby_en_valid)begin // adv sleep mode enable
//                   st_oled_reinit        <= r_adv_sleep_mode_en_i2c_write;
                   st_oled_reinit            <= r_oled_reset;
                   oled_standby_process_busy <= 1'b1;
                   oled_reinit_start         <= 1'b0;
                end
                else begin
                   st_oled_reinit            <= r_oled_reinit_idle;
                   oled_reinit_start         <= 1'b0;
                   oled_standby_process_busy <= 1'b0;
                end 
            end 
            
            r_oled_reset : begin
                if(oled_vgn_bat_shutter_process_busy ==1'b0)begin
                    st_oled_reinit <= r_adv_sleep_mode_en_i2c_write;
                    oled_reset     <= 1'b1;
                end
            end
            
            r_oled_reinit_wait : begin
             if(oled_vgn_bat_shutter_process_busy ==1'b0)begin
                 oled_power_off            <= 1'b0;
                 if(tick_1ms)begin
                  oled_reint_wait_cnt        <= oled_reint_wait_cnt + 1;
                 end        
             end             
             if(oled_reint_wait_cnt == 250)begin
              st_oled_reinit        <= r_oled_reinit_rd_rq;
              oled_reset            <= 1'b0;
             end
             else begin 
              st_oled_reinit        <= r_oled_reinit_wait;
             end 
            end
            r_oled_reinit_rd_rq : begin     
                 if(OLED_REG_WR_CNT == OLED_REG_CNT)begin
                     st_oled_reinit             <= r_adv_sleep_mode_dis_i2c_write;
                     // oled_reinit_vgn_rd_en      <= 1'b1;
                     oled_init_mem_rd_addr      <= 0;
                     oled_init_mem_rd_addr_temp <= 0;
                     oled_init_mem_rd_req       <= 1'b0;
                     OLED_REG_WR_CNT            <= 0;
                 end
                 else begin
                     st_oled_reinit             <= r_oled_reinit_rd_wait;
                     oled_init_mem_rd_addr      <= oled_init_mem_rd_addr_temp;
                     oled_init_mem_rd_addr_temp <= oled_init_mem_rd_addr_temp +1;
                     oled_init_mem_rd_req       <= 1'b1;  
                     OLED_REG_WR_CNT            <= OLED_REG_WR_CNT + 1;       
                 end 
            end 
            r_oled_reinit_rd_wait : begin
                oled_init_mem_rd_req       <= 1'b0;
                st_oled_reinit             <= r_oled_reinit_i2c_write;
            end                   

            r_oled_reinit_i2c_write: begin
                av_i2c_address   <= {OLED_DEV_ADDR,oled_init_mem_rd_data[7:0]};
                av_i2c_writedata <= oled_init_mem_rd_data[23:16];
                av_i2c_write     <= 1'b1;
                if(av_i2c_waitrequest) begin 
                    av_i2c_write   <= 1'b0;
                    st_oled_reinit <= r_oled_reinit_i2c_write_wait;  
                end    
                else begin
                    st_oled_reinit <= r_oled_reinit_i2c_write;    
                end          
            end
            
            r_oled_reinit_i2c_write_wait: begin
//                oled_init_mem_wr_req       <= 1'b0;
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write   <= 1'b0;
                    st_oled_reinit <= r_oled_reinit_rd_rq;
                end
            end  

            r_adv_sleep_mode_dis_i2c_write: begin
                av_i2c_address   <= {ADV_DEV_ADDR,8'h00};
                av_i2c_writedata <= 8'h1E;
                av_i2c_write     <= 1'b1;
                if(av_i2c_waitrequest) begin 
                    av_i2c_write   <= 1'b0;
                    st_oled_reinit <= r_adv_sleep_mode_dis_i2c_write_wait;  
                end    
                else begin
                    st_oled_reinit <= r_adv_sleep_mode_dis_i2c_write;    
                end          
            end
            
            r_adv_sleep_mode_dis_i2c_write_wait: begin
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write   <= 1'b0;
                    st_oled_reinit <= r_oled_reinit_idle;
                    oled_reinit_vgn_rd_en      <= 1'b1;
                end
            end                     

            r_adv_sleep_mode_en_i2c_write: begin
                av_i2c_address   <= {ADV_DEV_ADDR,8'h00};
                av_i2c_writedata <= 8'h01;
                av_i2c_write     <= 1'b1;
                if(av_i2c_waitrequest) begin 
                    av_i2c_write   <= 1'b0;
                    st_oled_reinit <= r_adv_sleep_mode_en_i2c_write_wait;  
                end    
                else begin
                    st_oled_reinit <= r_adv_sleep_mode_en_i2c_write;    
                end          
            end
            
            r_adv_sleep_mode_en_i2c_write_wait: begin
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write   <= 1'b0;
                    st_oled_reinit <= r_oled_power_off;
                end
            end 

            r_oled_power_off : begin
                st_oled_reinit     <= r_oled_reinit_idle;
                oled_power_off     <= 1'b1;
            end             

        endcase 

        case(qspi_sensor_init_wr_st)
            r_qspi_sensor_init_page_wr_idle: begin
            
                  if(av_sensor_i2c_write)begin
                    if(av_sensor_i2c_address[15:0] == SENSOR_GFID_ADDR)begin
                        //sensor_init_gfid_store <=  {4'd0,av_spi_writedata[11:8],av_spi_writedata[7:0],12'd0 , av_spi_writedata[15:12]};
                        sensor_init_gfid_store    <= {8'd0,av_sensor_i2c_writedata[7:0],av_sensor_i2c_address[15:0]};
                        sensor_init_gfid_store_en <= 1'b1;
                    end
                    else if(av_sensor_i2c_address[15:0]== SENSOR_GSK_ADDR)begin
                        sensor_init_gsk_store    <= {8'd0,av_sensor_i2c_writedata[7:0],av_sensor_i2c_address[15:0]};
                        sensor_init_gsk_store_en <= 1'b1;
                    end 
                    else if(av_sensor_i2c_address[15:0]== SENSOR_GSK_ADDR1)begin
                        sensor_init_gsk_store1    <= {8'd0,av_sensor_i2c_writedata[7:0],av_sensor_i2c_address[15:0]};
                        sensor_init_gsk_store1_en <= 1'b1;
                    end    
                    else if(av_sensor_i2c_address[15:0]== SENSOR_INT_TIME_ADDR)begin
                        sensor_init_int_time_store    <= {8'd0,av_sensor_i2c_writedata[7:0],av_sensor_i2c_address[15:0]};
                        sensor_init_int_time_store_en <= 1'b1;
                    end
                    else if(av_sensor_i2c_address[15:0]== SENSOR_INT_TIME_ADDR1)begin
                        sensor_init_int_time_store1    <= {8'd0,av_sensor_i2c_writedata[7:0],av_sensor_i2c_address[15:0]};
                        sensor_init_int_time_store1_en <= 1'b1;
                    end
                    else if(av_sensor_i2c_address[15:0]== SENSOR_GAIN_ADDR)begin
                        sensor_init_gain_store    <= {8'd0,av_sensor_i2c_writedata[7:0],av_sensor_i2c_address[15:0]};
                        sensor_init_gain_store_en <= 1'b1;
                    end
                    
               end  
            
               if(qspi_sensor_init_wr_enable) begin
                    qspi_erase_4KB_enable  <= 1'b1;            
                    qspi_addr              <= QSPI_ADDR_SENSOR_INIT_DATA ;     
                    number_of_erase_block  <= 1;   
                    qspi_sensor_init_wr_st <= r_qspi_sensor_init_page_erase_wait;                     
                    update_sensor_init     <= 1'b1;
                end
                else begin
                    qspi_sensor_init_wr_st <= r_qspi_sensor_init_page_wr_idle;
                    update_sensor_init     <= 1'b0;
                end    
            end   
            
            r_qspi_sensor_init_page_erase_wait:begin
                if(qspi_erase_4KB_enable == 1'b0)begin
                    dest_address_d         <= QSPI_ADDR_SENSOR_INIT_DATA ;     
                    data_trans_len_d       <= QSPI_SENSOR_INIT_DATA_BLOCK_SIZE ; 
                    qspi_sensor_init_wr_st <= r_sensor_init_gfid_update ;
                end
                else begin
                    qspi_sensor_init_wr_st <= r_qspi_sensor_init_page_erase_wait;
                end
            end     
            

            r_sensor_init_gfid_update: begin
                 if(sensor_init_gfid_store_en)begin
                    if(sel_temp_range == 2'b11)begin
                        sensor_init_mem_wr_addr1 <= temp_range3_sensor_init_gfid_addr;
                    end
                    else if(sel_temp_range == 2'b10)begin
                        sensor_init_mem_wr_addr1 <= temp_range2_sensor_init_gfid_addr;
                    end
                    else if(sel_temp_range == 2'b01)begin
                        sensor_init_mem_wr_addr1 <= temp_range1_sensor_init_gfid_addr;
                    end
                    else begin
                        sensor_init_mem_wr_addr1 <= temp_range0_sensor_init_gfid_addr;
                    end
                    sensor_init_mem_wr_req1  <= 1'b1;
                    sensor_init_mem_wr_data1 <= sensor_init_gfid_store; 
                    sensor_init_gfid_store_en <= 1'b0;              
                end    
                qspi_sensor_init_wr_st   <= r_sensor_init_gsk_update;
            end
            
            r_sensor_init_gsk_update: begin
                if(sensor_init_gsk_store_en)begin
                    if(sel_temp_range == 2'b11)begin
                        sensor_init_mem_wr_addr1 <= temp_range3_sensor_init_gsk_addr;
                    end
                    else if(sel_temp_range == 2'b10)begin
                        sensor_init_mem_wr_addr1 <= temp_range2_sensor_init_gsk_addr;
                    end
                    else if(sel_temp_range == 2'b01)begin
                        sensor_init_mem_wr_addr1 <= temp_range1_sensor_init_gsk_addr;
                    end
                    else begin
                        sensor_init_mem_wr_addr1 <= temp_range0_sensor_init_gsk_addr;
                    end
                    sensor_init_mem_wr_req1  <= 1'b1;
                    sensor_init_mem_wr_data1 <= sensor_init_gsk_store;
                    sensor_init_gsk_store_en <= 1'b0;
                end    
                qspi_sensor_init_wr_st   <= r_sensor_init_gsk_update1;//r_sensor_init_int_time_update;
            end

            r_sensor_init_gsk_update1: begin
                if(sensor_init_gsk_store1_en)begin
                    if(sel_temp_range == 2'b11)begin
                        sensor_init_mem_wr_addr1 <= temp_range3_sensor_init_gsk_addr1;
                    end
                    else if(sel_temp_range == 2'b10)begin
                        sensor_init_mem_wr_addr1 <= temp_range2_sensor_init_gsk_addr1;
                    end
                    else if(sel_temp_range == 2'b01)begin
                        sensor_init_mem_wr_addr1 <= temp_range1_sensor_init_gsk_addr1;
                    end
                    else begin
                        sensor_init_mem_wr_addr1 <= temp_range0_sensor_init_gsk_addr1;
                    end
                    sensor_init_mem_wr_req1  <= 1'b1;
                    sensor_init_mem_wr_data1 <= sensor_init_gsk_store1;
                    sensor_init_gsk_store1_en <= 1'b0;
                end    
                qspi_sensor_init_wr_st   <= r_sensor_init_int_time_update;
            end

            r_sensor_init_int_time_update: begin
                if(sensor_init_int_time_store_en)begin
                    if(sel_temp_range == 2'b11)begin
                        sensor_init_mem_wr_addr1 <= temp_range3_sensor_init_int_time_addr;
                    end
                    else if(sel_temp_range == 2'b10)begin
                        sensor_init_mem_wr_addr1 <= temp_range2_sensor_init_int_time_addr;
                    end
                    else if(sel_temp_range == 2'b01)begin
                        sensor_init_mem_wr_addr1 <= temp_range1_sensor_init_int_time_addr;
                    end
                    else begin
                        sensor_init_mem_wr_addr1 <= temp_range0_sensor_init_int_time_addr;
                    end
                    sensor_init_mem_wr_req1  <= 1'b1;
                    sensor_init_mem_wr_data1 <= sensor_init_int_time_store;
                    sensor_init_int_time_store_en <= 1'b0;
                end    
                qspi_sensor_init_wr_st   <= r_sensor_init_int_time_update1;//r_sensor_init_gain_update;
            end

            r_sensor_init_int_time_update1: begin
                if(sensor_init_int_time_store1_en)begin
                    if(sel_temp_range == 2'b11)begin
                        sensor_init_mem_wr_addr1 <= temp_range3_sensor_init_int_time_addr1;
                    end
                    else if(sel_temp_range == 2'b10)begin
                        sensor_init_mem_wr_addr1 <= temp_range2_sensor_init_int_time_addr1;
                    end
                    else if(sel_temp_range == 2'b01)begin
                        sensor_init_mem_wr_addr1 <= temp_range1_sensor_init_int_time_addr1;
                    end
                    else begin
                        sensor_init_mem_wr_addr1 <= temp_range0_sensor_init_int_time_addr1;
                    end
                    sensor_init_mem_wr_req1  <= 1'b1;
                    sensor_init_mem_wr_data1 <= sensor_init_int_time_store1;
                    sensor_init_int_time_store1_en <= 1'b0;
                end    
                qspi_sensor_init_wr_st   <= r_sensor_init_gain_update;
            end

            r_sensor_init_gain_update: begin
                if(sensor_init_gain_store_en)begin
                    if(sel_temp_range == 2'b11)begin
                        sensor_init_mem_wr_addr1 <= temp_range3_sensor_init_gain_addr;
                    end
                    else if(sel_temp_range == 2'b10)begin
                        sensor_init_mem_wr_addr1 <= temp_range2_sensor_init_gain_addr;
                    end
                    else if(sel_temp_range == 2'b01)begin
                        sensor_init_mem_wr_addr1 <= temp_range1_sensor_init_gain_addr;
                    end
                    else begin
                        sensor_init_mem_wr_addr1 <= temp_range0_sensor_init_gain_addr;
                    end
                    sensor_init_mem_wr_req1  <= 1'b1;
                    sensor_init_mem_wr_data1 <= sensor_init_gain_store;
                    sensor_init_gain_store_en <= 1'b0;
                end   
                    
                qspi_sensor_init_wr_st   <= r_qspi_sensor_init_page_wr_start;
            end
            
            r_qspi_sensor_init_page_wr_start: begin
                sensor_init_mem_wr_req1  <= 1'b0;
                if(page_wr_cnt == data_trans_len_d)begin
                    qspi_sensor_init_wr_st     <= r_qspi_sensor_init_page_wr_idle;
                    qspi_sensor_init_wr_enable <= 1'b0;
                    page_wr_cnt                <= 0;
                    update_sensor_init         <= 1'b0;
                end
                else begin             
                    qspi_page_wr_rq <= 1'b1;
                    qspi_send_addr   <= dest_address_d;       
                    if(qspi_send_busy)begin
                        qspi_sensor_init_wr_st <=  r_sensor_init_rd1;
                        qspi_page_wr_rq <= 1'b0;
                        page_wr_cnt <= page_wr_cnt + 1;
                        dest_address_d <= dest_address_d + 32'd256;
                    end 
                end    
            end

            r_qspi_sensor_init_page_wr_done: begin
                if(!qspi_send_busy)begin
                    qspi_sensor_init_wr_st<= r_qspi_sensor_init_page_wr_start;
                end
            end 

            r_sensor_init_rd1 : begin   
               if(read_sdram_data_rq)begin       
                 if(sensor_init_rd_byte_cnt == 256)begin
                     sensor_init_rd_byte_cnt <= 0;
                     qspi_sensor_init_wr_st <= r_qspi_sensor_init_page_wr_done;//r_qspi_wr;//r_qspi_rd;//r_qspi_rd_init;//r_idle; 
                     sensor_init_mem_rd_req1  <= 1'b0;
                 end
                 else begin
                     qspi_sensor_init_wr_st   <= r_sensor_init_rd2;
                     sensor_init_mem_rd_addr1 <= sensor_init_mem_rd_addr_temp1;
                     sensor_init_mem_rd_req1  <= 1'b1;
                     sensor_init_rd_byte_cnt  <= sensor_init_rd_byte_cnt + 2; 
                 end 
               end          
             end
            r_sensor_init_rd2:begin
                sensor_init_mem_rd_req1       <= 1'b0;
                qspi_sensor_init_wr_st        <= r_sensor_init_rd3;
            end
            
            r_sensor_init_rd3:begin
                sensor_init_rd_data_temp      <= sensor_init_mem_rd_data1;
                sensor_init_mem_rd_addr_temp1 <= sensor_init_mem_rd_addr_temp1 +1;
                qspi_sensor_init_wr_st        <= r_qspi_sensor_init_wr;
            end
            
            r_qspi_sensor_init_wr: begin 
                if(qspi_wr_cnt == 4)begin
                    qspi_wr_cnt <= 0;
                    qspi_sensor_init_wr_st <= r_sensor_init_rd1;
                    qspi_wr_data_valid <= 1'b0; 
                    qspi_wr_data <= 0;     
                end
                else begin
                    qspi_wr_data             <= sensor_init_rd_data_temp[7:0] ;//sdram_read_data[7:0];
                    sensor_init_rd_data_temp <= {sensor_init_rd_data_temp[7:0],sensor_init_rd_data_temp[31:8]};
                    qspi_wr_data_valid       <= 1'b1; 
                    qspi_wr_cnt              <= qspi_wr_cnt +1;
                end  
            end
        endcase                     
              
        case(mark_bp_st)
        
            r_mark_bp_idle: begin
                if(mark_bp_en || unmark_bp_en || (OSD_MARK_BP && OSD_MARK_BP_VALID) || (OSD_UNMARK_BP & OSD_UNMARK_BP_VALID))begin 
                    if(((RETICLE_POS_X >= RETICLE_OFFSET_X) && (RETICLE_POS_X< RETICLE_OFFSET_X+VIDEO_XSIZE)) && ((RETICLE_POS_Y >= RETICLE_OFFSET_Y) && (RETICLE_POS_Y< RETICLE_OFFSET_Y+VIDEO_YSIZE)) )begin
                        latch_reticle_pos_x <= RETICLE_POS_X -  RETICLE_OFFSET_X;
                        latch_reticle_pos_y <= RETICLE_POS_Y -  RETICLE_OFFSET_Y;
                        mark_bp_st <= r_mark_bp_addr_offset_calc;
                        if(OSD_MARK_BP)begin
                          mark_bp_en <= 1'b1;
                        end
                        
                        if(OSD_UNMARK_BP)begin
                          unmark_bp_en <= 1'b1;
                        end
                    end
                    else begin
                        mark_bp_st <= r_mark_bp_idle;
                        latch_reticle_pos_x <= latch_reticle_pos_x;
                        latch_reticle_pos_y <= latch_reticle_pos_y;
                        if(mark_bp_en || OSD_MARK_BP)begin
                            mark_bp_en <= 1'b0;
                            mark_bp_error<= 1'b1;
                        end
                        else begin
                            unmark_bp_en <= 1'b0;
                            unmark_bp_error<= 1'b1;                        
                        end    
                    end
                end
                else begin
                    mark_bp_st <= r_mark_bp_idle;
                    latch_reticle_pos_x <= latch_reticle_pos_x;
                    latch_reticle_pos_y <= latch_reticle_pos_y;
                end
                gain_tb_sel_cnt <= 3'b0;
                gain_addr_offset <= 0;
            end
            
            r_mark_bp_addr_offset_calc: begin
                gain_addr_offset <= {latch_reticle_pos_x[PIX_BITS-1:1],1'b0} + latch_reticle_pos_y * VIDEO_XSIZE;
                mark_bp_st       <= r_mark_bp_addr_calc;
                gain_tb_sel_cnt  <= 3'b0;
            end
            
            r_mark_bp_addr_calc : begin
                if(gain_tb_sel_cnt == 0)begin
                    if(DMA_WRITE_FREE)begin
//                        qspi_init_cmd_done <= 1'b0;
                        gain_tb_sel_cnt  <= gain_tb_sel_cnt + 1;
                        mark_bp_st       <= r_mark_bp_addr_latch;
                        gain_tb_addr     <= ADDR_GAIN_BADPIX_A + {gain_addr_offset[30:0],1'b0};
                    end
                    else begin
                        mark_bp_st       <=  r_mark_bp_addr_calc;
                    end
                end
                else if(gain_tb_sel_cnt == 1)begin  
                    if(DMA_WRITE_FREE)begin
//                        qspi_init_cmd_done <= 1'b0; 
                        gain_tb_sel_cnt <= gain_tb_sel_cnt + 1;
                        mark_bp_st      <= r_mark_bp_addr_latch;
                        gain_tb_addr    <= ADDR_GAIN_BADPIX_B  + {gain_addr_offset[30:0],1'b0};
                    end
                    else begin
                        mark_bp_st       <=  r_mark_bp_addr_calc;
                    end
                end
                else begin
//                    qspi_init_cmd_done <= 1'b1;
                    gain_tb_sel_cnt <= 0;
                    mark_bp_st      <= r_mark_bp_idle;
                    mark_bp_en      <= 1'b0;
                    gain_tb_addr    <= 0;
                    unmark_bp_en    <= 1'b0;
                end
                
            end
            r_mark_bp_addr_latch :begin
                mark_bp_st       <= r_mark_bp_sdram_read;
                sdram_read_addr  <= gain_tb_addr; 
                sdram_write_addr <= gain_tb_addr;        
            end
            r_mark_bp_sdram_read : begin       
                av_rdsdram_address    <= sdram_read_addr;
                av_rdsdram_burstcount <= 1;
                av_rdsdram_read       <= 1'b1;
                burst_count           <= 1;
                mark_bp_st             <= r_mark_bp_sdram_read1; 
            end
            r_mark_bp_sdram_read1 : begin 
                if ((!av_rdsdram_waitrequest)) begin
                    av_rdsdram_read <= 1'b0;
                end
                if (av_rdsdram_readdatavalid) begin
                    burst_count     <= burst_count - 1;
                    sdram_read_data <= av_rdsdram_readdata;
                    if ((burst_count == 1)) begin
                        read_done  <= 1'b0;
                        mark_bp_st <= r_mark_bp_data;
                    end
                end
            end
            
            r_mark_bp_data : begin
                mark_bp_st       <= r_mark_bp_sdram_write1;
                if(mark_bp_en)begin
                    if(latch_reticle_pos_x[0]==1'b0)begin
                        sdram_write_data <= {sdram_read_data[31:16],1'b1,sdram_read_data[14:0]} ; 
                    end
                    else begin
                        sdram_write_data <= {1'b1,sdram_read_data[30:16],sdram_read_data[15:0]} ; 
                    end
                end
                else begin
                    if(latch_reticle_pos_x[0]==1'b0)begin
                        sdram_write_data <= {sdram_read_data[31:16],1'b0,sdram_read_data[14:0]} ; 
                    end
                    else begin
                        sdram_write_data <= {1'b0,sdram_read_data[30:16],sdram_read_data[15:0]} ; 
                    end
                end    
                
            end
                      
            r_mark_bp_sdram_write1: begin
                av_wrsdram_address    <= sdram_write_addr;  
                av_wrsdram_burstcount <= 1;
                av_wrsdram_write      <= 1'b1;
                av_wrsdram_writeburst <= 1'b1;
                av_wrsdram_writedata  <= sdram_write_data;//32'hAABBCCDD;
                burst_count           <= 1;
                mark_bp_st            <= r_mark_bp_sdram_write2;
            end
            r_mark_bp_sdram_write2: begin    
                av_wrsdram_write      <= 1'b1;
                if ((!av_wrsdram_waitrequest)) begin
                    av_wrsdram_writeburst <= 1'b0;
                    av_wrsdram_writedata  <= 0;//32'h11223344;
                    burst_count <= (burst_count - 1);
                    if ((burst_count == 1)) begin
                        av_wrsdram_write <= 1'b0;
                        mark_bp_st       <= r_mark_bp_addr_calc;
                    end
                end
            end

        endcase        

        case (st_oled_reg_update)
            oled_reg_update_idle :begin
                if(oled_init_done == 1'b1)begin
                    st_oled_reg_update      <= oled_reg_update_wait;
                end 
                else begin
                    st_oled_reg_update      <= oled_reg_update_idle;
                end
            end
            oled_reg_update_wait :begin
                 if(oled_vgn_bat_i2c_busy == 1'b0) begin
                      if(OLED_BRIGHTNESS_VALID_LATCH == 1'b1 )begin
                        oled_reg_data1 <= OLED_BRIGHTNESS;
                        oled_reg_addr1 <= OLED_BRIGHTNESS_REG_ADDR;
                        OLED_BRIGHTNESS_VALID_LATCH_DONE <= 1'b1;
                        st_oled_reg_update      <= oled_reg_i2c_write;
                      end
                      else if(OLED_CONTRAST_VALID_LATCH == 1'b1)begin  
                        oled_reg_data1 <= OLED_CONTRAST;
                        oled_reg_addr1 <= OLED_CONTRAST_REG_ADDR;
                        OLED_CONTRAST_VALID_LATCH_DONE <= 1'b1;
                        st_oled_reg_update      <= oled_reg_i2c_write;
                      end  
                      else if(OLED_IDRF_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_IDRF;
                        oled_reg_addr1 <= OLED_IDRF_REG_ADDR;
                        OLED_IDRF_VALID_LATCH_DONE <= 1'b1;
                        st_oled_reg_update      <= oled_reg_i2c_write;
                      end
                      else if(OLED_DIMCTL_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_DIMCTL;
                        oled_reg_addr1 <= OLED_DIMCTL_REG_ADDR;   
                        OLED_DIMCTL_VALID_LATCH_DONE <= 1'b1;  
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end
                      else if(OLED_IMG_FLIP_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_IMG_FLIP;
                        oled_reg_addr1 <= OLED_DISPMODE_REG_ADDR;   
                        OLED_IMG_FLIP_VALID_LATCH_DONE <= 1'b1;  
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end
                      else if(OLED_CATHODE_VOLTAGE_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_CATHODE_VOLTAGE;
                        oled_reg_addr1 <= OLED_CATHODE_VOLTAGE_REG_ADDR;   
                        OLED_CATHODE_VOLTAGE_VALID_LATCH_DONE <= 1'b1;  
                        oled_cathode_voltage_dev_sel <= 1'b1;
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end                        
                      else if(OLED_ROW_START_MSB_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_ROW_START_MSB;
                        oled_reg_addr1 <= OLED_ROW_START_MSB_REG_ADDR;   
                        OLED_ROW_START_MSB_VALID_LATCH_DONE <= 1'b1;  
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end 
                      else if(OLED_ROW_START_LSB_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_ROW_START_LSB;
                        oled_reg_addr1 <= OLED_ROW_START_LSB_REG_ADDR;   
                        OLED_ROW_START_LSB_VALID_LATCH_DONE <= 1'b1;  
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end 
                      else if(OLED_ROW_END_MSB_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_ROW_END_MSB;
                        oled_reg_addr1 <= OLED_ROW_END_MSB_REG_ADDR;   
                        OLED_ROW_END_MSB_VALID_LATCH_DONE <= 1'b1;  
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end                       
                       else if(OLED_ROW_END_LSB_VALID_LATCH == 1'b1)begin
                        oled_reg_data1 <= OLED_ROW_END_LSB;
                        oled_reg_addr1 <= OLED_ROW_END_LSB_REG_ADDR;   
                        OLED_ROW_END_LSB_VALID_LATCH_DONE <= 1'b1;  
                        st_oled_reg_update      <= oled_reg_i2c_write;          
                      end  
                      else if(OLED_POS_V_VALID_LATCH == 1'b1)begin
                        if(OLED_POS_V > OLED_POS_V_MAX_OFFSET)begin
                            oled_reg_data1          <= OLED_POS_V_MAX_OFFSET;
//                            OLED_POS_BOTPOS_WR_DATA <= 0;
                        end
                        else begin    
                            oled_reg_data1          <= OLED_POS_V;
//                            OLED_POS_BOTPOS_WR_DATA <= OLED_POS_V_MAX_OFFSET- OLED_POS_V;
                        end
                        OLED_POS_BOTPOS_WR_DATA     <= 0;
                        oled_reg_addr1              <= OLED_TOPPOS_REG_ADDR;  
                        OLED_POS_V_VALID_LATCH_DONE <= 1'b1;
                        OLED_POS_BOTPOS_WR_EN       <= 1'b1;
                        st_oled_reg_update          <= oled_reg_i2c_write;                                       
                      end
                      else if(OLED_POS_H_VALID_LATCH == 1'b1)begin
                        if(OLED_POS_H > OLED_POS_H_MAX_OFFSET)begin
                            oled_reg_data1          <= {7'd0,OLED_POS_H_MAX_OFFSET[8]};
//                            OLED_POS_RGTPOS_WR_DATA <= 0;
                        end
                        else begin    
                            oled_reg_data1          <= {7'd0,OLED_POS_H[8]};
//                            OLED_POS_RGTPOS_WR_DATA <= OLED_POS_H_MAX_OFFSET - OLED_POS_H;
                        end
                        if(OLED_POS_H <336)begin
                            OLED_POS_LFTPOS_WR_DATA    <= 336- OLED_POS_H;
                        end
                        else  begin
                            OLED_POS_LFTPOS_WR_DATA    <= 0;
                        end
                            
//                        OLED_POS_RGTPOS_WR_DATA    <= 0;
//                        oled_reg_addr1             <= OLED_LFTPOS_REG_ADDR; 
                        oled_reg_addr1             <= OLED_RGTPOS_MSB_REG_ADDR;
                        OLED_POS_H_VALID_LATCH_DONE<= 1'b1;
                        OLED_POS_RGTPOS_WR_EN      <= 1'b1;
//                        OLED_POS_RGTPOS_WR_EN      <= 1'b1;
                        st_oled_reg_update         <= oled_reg_i2c_write;                    
                      end
                      else if(OLED_POS_RGTPOS_WR_EN == 1'b1)begin
                        
                        if(OLED_POS_H > OLED_POS_H_MAX_OFFSET)begin
                            oled_reg_data1          <= OLED_POS_H_MAX_OFFSET[7:0];
//                            OLED_POS_RGTPOS_WR_DATA <= 0;
                        end
                        else begin    
                            oled_reg_data1          <= OLED_POS_H[7:0];
//                            OLED_POS_RGTPOS_WR_DATA <= OLED_POS_H_MAX_OFFSET - OLED_POS_H;
                        end
                        oled_reg_addr1        <= OLED_RGTPOS_REG_ADDR;  
                        OLED_POS_RGTPOS_WR_EN_LATCH_DONE <= 1'b1;
                        st_oled_reg_update      <= oled_reg_i2c_write;  
                        OLED_POS_LFTPOS_MSB_WR_EN      <= 1'b1;                 
                      end                      

                      else if(OLED_POS_BOTPOS_WR_EN == 1'b1)begin
                        oled_reg_data1        <= OLED_POS_BOTPOS_WR_DATA;
                        oled_reg_addr1        <= OLED_BOTPOS_REG_ADDR; 
                        OLED_POS_BOTPOS_WR_EN_LATCH_DONE <= 1'b1; 
                        st_oled_reg_update      <= oled_reg_i2c_write;                 
                      end
                      else if(OLED_POS_LFTPOS_MSB_WR_EN == 1'b1)begin
                        oled_reg_data1        <= {7'd0,OLED_POS_LFTPOS_WR_DATA[8]};
                        oled_reg_addr1        <= OLED_LFTPOS_MSB_REG_ADDR;  
                        OLED_POS_LFTPOS_MSB_WR_EN_LATCH_DONE <= 1'b1;
                        OLED_POS_LFTPOS_WR_EN  <= 1'b1;
                        st_oled_reg_update      <= oled_reg_i2c_write;                
                      end
                      else if(OLED_POS_LFTPOS_WR_EN == 1'b1)begin
                        oled_reg_data1        <= OLED_POS_LFTPOS_WR_DATA[7:0];
//                        oled_reg_addr1        <= OLED_RGTPOS_REG_ADDR; 
                        oled_reg_addr1        <= OLED_LFTPOS_REG_ADDR;  
                        OLED_POS_LFTPOS_WR_EN_LATCH_DONE <= 1'b1;                       
                        st_oled_reg_update      <= oled_reg_i2c_write;                   
                      end       
                      else begin
                        st_oled_reg_update <= oled_reg_update_wait;
                      end
                  end
                  else begin
                    st_oled_reg_update <= oled_reg_update_wait;
                  end     
            end  

            oled_reg_i2c_write: begin
                if(oled_cathode_voltage_dev_sel)begin
                   av_i2c_address   <= {OLED_CATHODE_VOLTAGE_DEV_ADDR,oled_reg_addr1};
                end
                else begin
                   av_i2c_address   <= {OLED_DEV_ADDR,oled_reg_addr1};
                end 
//                av_i2c_address   <= {OLED_DEV_ADDR,oled_reg_addr1};
                av_i2c_writedata <= oled_reg_data1;
                av_i2c_write     <= 1'b1;
                if(av_i2c_waitrequest) begin 
                    av_i2c_write          <= 1'b0;
                    st_oled_reg_update <= oled_reg_i2c_write_wait;  
                end    
                else begin
                    st_oled_reg_update <= oled_reg_i2c_write;    
                end          
            end
            
            oled_reg_i2c_write_wait: begin
//                oled_init_mem_wr_req       <= 1'b0;
                 oled_cathode_voltage_dev_sel <= 1'b0;
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write          <= 1'b0;
                    st_oled_reg_update <= oled_reg_i2c_write_done;
                end
            end
            
            oled_reg_i2c_write_done : begin
                if(OLED_POS_V_VALID_LATCH_DONE == 1'b1)begin
                    OLED_POS_V_VALID_LATCH_DONE <= 1'b0;
                    OLED_POS_V_VALID_LATCH      <= 1'b0;
                end        
                if(OLED_POS_H_VALID_LATCH_DONE == 1'b1 )begin
                    OLED_POS_H_VALID_LATCH_DONE <= 1'b0;
                    OLED_POS_H_VALID_LATCH      <= 1'b0;
                end  
                if(OLED_BRIGHTNESS_VALID_LATCH_DONE == 1'b1)begin
                    OLED_BRIGHTNESS_VALID_LATCH_DONE <= 1'b0;
                    OLED_BRIGHTNESS_VALID_LATCH      <= 1'b0;
                end  
                if(OLED_CONTRAST_VALID_LATCH_DONE == 1'b1)begin
                    OLED_CONTRAST_VALID_LATCH_DONE <= 1'b0;
                    OLED_CONTRAST_VALID_LATCH      <= 1'b0;
                end 
                if(OLED_IDRF_VALID_LATCH_DONE == 1'b1)begin
                    OLED_IDRF_VALID_LATCH_DONE <= 1'b0;
                    OLED_IDRF_VALID_LATCH      <= 1'b0;
                end                            
                if(OLED_DIMCTL_VALID_LATCH_DONE == 1'b1)begin
                    OLED_DIMCTL_VALID_LATCH_DONE  <= 1'b0;
                    OLED_DIMCTL_VALID_LATCH       <= 1'b0;
                end   
                if(OLED_IMG_FLIP_VALID_LATCH_DONE == 1'b1)begin
                    OLED_IMG_FLIP_VALID_LATCH_DONE  <= 1'b0;
                    OLED_IMG_FLIP_VALID_LATCH       <= 1'b0;
                end  
                if(OLED_CATHODE_VOLTAGE_VALID_LATCH_DONE == 1'b1)begin
                    OLED_CATHODE_VOLTAGE_VALID_LATCH_DONE  <= 1'b0;
                    OLED_CATHODE_VOLTAGE_VALID_LATCH       <= 1'b0;
                end                   
                if(OLED_ROW_START_MSB_VALID_LATCH_DONE == 1'b1)begin
                    OLED_ROW_START_MSB_VALID_LATCH_DONE  <= 1'b0;
                    OLED_ROW_START_MSB_VALID_LATCH       <= 1'b0;
                end                                               
                if(OLED_ROW_START_LSB_VALID_LATCH_DONE == 1'b1)begin
                    OLED_ROW_START_LSB_VALID_LATCH_DONE  <= 1'b0;
                    OLED_ROW_START_LSB_VALID_LATCH       <= 1'b0;
                end       
                if(OLED_ROW_END_MSB_VALID_LATCH_DONE == 1'b1)begin
                    OLED_ROW_END_MSB_VALID_LATCH_DONE  <= 1'b0;
                    OLED_ROW_END_MSB_VALID_LATCH       <= 1'b0;
                end          
                if(OLED_ROW_END_LSB_VALID_LATCH_DONE == 1'b1)begin
                    OLED_ROW_END_LSB_VALID_LATCH_DONE  <= 1'b0;
                    OLED_ROW_END_LSB_VALID_LATCH       <= 1'b0;
                end    
                if(OLED_POS_BOTPOS_WR_EN_LATCH_DONE == 1'b1)begin
                    OLED_POS_BOTPOS_WR_EN_LATCH_DONE <= 1'b0;
                    OLED_POS_BOTPOS_WR_EN            <= 1'b0;
                end 
                if(OLED_POS_LFTPOS_MSB_WR_EN_LATCH_DONE == 1'b1)begin
                    OLED_POS_LFTPOS_MSB_WR_EN_LATCH_DONE <= 1'b0;
                    OLED_POS_LFTPOS_MSB_WR_EN            <= 1'b0;
                end                   
                if(OLED_POS_LFTPOS_WR_EN_LATCH_DONE == 1'b1)begin
                    OLED_POS_LFTPOS_WR_EN_LATCH_DONE <= 1'b0;
                    OLED_POS_LFTPOS_WR_EN            <= 1'b0;
                end               
                if(OLED_POS_RGTPOS_WR_EN_LATCH_DONE == 1'b1)begin
                    OLED_POS_RGTPOS_WR_EN_LATCH_DONE <= 1'b0;
                    OLED_POS_RGTPOS_WR_EN            <= 1'b0;
                end 
                st_oled_reg_update <= oled_reg_update_wait;                    
            end
        endcase    

        case (st_oled_gamma_tb_calc)
            oled_gamma_tb_calc_idle :begin
                gl_gc_cnt <=0;
////                if((oled_gamma_coeff_mem_wr_done==1'b1) && (product_sel==1'b0))begin
//////                   st_oled_gamma_tb_calc  <= gl_read;
//////                end
//////                else begin
////////                   st_oled_gamma_tb_calc <= oled_gamma_tb_calc_idle;
//                    if(video_start == 1'b1)begin
//                        st_oled_gamma_tb_calc  <= gl_read;
////                        st_oled_gamma_tb_calc <= oled_reg_update_done;
////                        BT656_START                <= 1'b1;
//                    end    
//                    else begin 
//                        st_oled_gamma_tb_calc <= oled_gamma_tb_calc_idle;   
//                    end     
////                end   
                    if((oled_gamma_coeff_mem_wr_done==1'b1) && (product_sel==1'b0))begin
                        st_oled_gamma_tb_calc  <= gl_read;
//                        st_oled_gamma_tb_calc <= oled_reg_update_done;
//                        BT656_START                <= 1'b1;
                    end    
                    else begin 
                        st_oled_gamma_tb_calc <= oled_gamma_tb_calc_idle;   
                    end 
            end
            gl_read : begin
                oled_gamma_coeff_mem_rd_req  <= 1'b1;  
                oled_gamma_coeff_mem_rd_addr <= gl1_addr + gl_gc_cnt; 
                st_oled_gamma_tb_calc        <= gl_read_wait;  
            end
            gl_read_wait: begin
                st_oled_gamma_tb_calc        <= gl_write;   
                oled_gamma_coeff_mem_rd_req  <= 1'b0;          
            end
            gl_write: begin
                gl[gl_gc_cnt] <= oled_gamma_coeff_mem_rd_data[9:0];   
                if(gl_gc_cnt == 8)begin
                    st_oled_gamma_tb_calc  <= gc_read;
                    gl_gc_cnt <= 0;
//                    if(vgn_gc_sel == 1'b1)begin
//                    if(OLED_GAMMA_TABLE_SEL== 0 || OLED_GAMMA_TABLE_SEL== 1 || OLED_GAMMA_TABLE_SEL== 2)begin
//                        if(OLED_GAMMA_TABLE_SEL== 2)begin
//                            vgn_gamma_mem_rd_sel <= 2'd2;
//                        end
//                        else if(OLED_GAMMA_TABLE_SEL== 1)begin
//                            vgn_gamma_mem_rd_sel <= 2'd1;
//                        end    
//                        else if(OLED_GAMMA_TABLE_SEL== 0)begin
//                            vgn_gamma_mem_rd_sel <= 2'd0;
//                        end    
//                        else begin
//                            vgn_gamma_mem_rd_sel <= 2'd0;
//                        end 
//                        st_oled_gamma_tb_calc  <= oled_vgn_gc_coeff_calc;
//                        gl_gc_cnt              <= 8;                    
//                    end 
//                    else begin
//                        st_oled_gamma_tb_calc  <= gc_read;
//                        gl_gc_cnt <= 0;
//                    end                     
                end
                else begin
                    st_oled_gamma_tb_calc  <= gl_read;
                    gl_gc_cnt              <= gl_gc_cnt +1;
                end     
            end
            
            gc_read : begin
                oled_gamma_coeff_mem_rd_req  <= 1'b1;  
                if(OLED_GAMMA_TABLE_SEL== 0)begin
                    oled_gamma_coeff_mem_rd_addr <= gc0_addr+ gl_gc_cnt; 
                end
                else if(OLED_GAMMA_TABLE_SEL== 1)begin
                    oled_gamma_coeff_mem_rd_addr <= gc1_addr+ gl_gc_cnt;
                end 
                else if(OLED_GAMMA_TABLE_SEL== 2)begin
                    oled_gamma_coeff_mem_rd_addr <= gc2_addr+ gl_gc_cnt;
                end
                else if(OLED_GAMMA_TABLE_SEL== 3)begin
                    oled_gamma_coeff_mem_rd_addr <= gc3_addr+ gl_gc_cnt;
                end
                else if(OLED_GAMMA_TABLE_SEL== 4)begin
                    oled_gamma_coeff_mem_rd_addr <= gc4_addr+ gl_gc_cnt;
                end                                
                else if(OLED_GAMMA_TABLE_SEL== 5)begin
                    oled_gamma_coeff_mem_rd_addr <= gc5_addr+ gl_gc_cnt;
                end  
                else if(OLED_GAMMA_TABLE_SEL== 6)begin
                    oled_gamma_coeff_mem_rd_addr <= gc6_addr+ gl_gc_cnt;
                end
                else if(OLED_GAMMA_TABLE_SEL== 7)begin
                    oled_gamma_coeff_mem_rd_addr <= gc7_addr+ gl_gc_cnt;
                end                
                else begin
                    oled_gamma_coeff_mem_rd_addr <= gc7_addr+ gl_gc_cnt; 
                end                  
                st_oled_gamma_tb_calc  <= gc_read_wait;  
            end
            gc_read_wait: begin
                st_oled_gamma_tb_calc        <= gc_write;  
                oled_gamma_coeff_mem_rd_req  <= 1'b0;
            end
            gc_write: begin
                gc[gl_gc_cnt] <= oled_gamma_coeff_mem_rd_data[9:0];  
                gl_gc_cnt     <= gl_gc_cnt +1; 
                if(gl_gc_cnt == 8)begin
                    st_oled_gamma_tb_calc  <= gamma_tb_calc_start;
                    val_8_bit              <= 0;
                    gl_gc_cnt <= 0;
                end
                else begin
                    st_oled_gamma_tb_calc  <= gc_read;
                end   
            end

//            oled_vgn_gc_coeff_calc: begin
////                if(OLED_VGN_TEST[31]==1'b1)begin
////                    st_oled_gamma_tb_calc <= oled_gammaset_write;
////                end
////                else begin
////                    st_oled_gamma_tb_calc <= oled_vgn_gc_coeff_calc;
////                end 
//                st_oled_gamma_tb_calc <= oled_gammaset_write;          
//            end
                                            
//            oled_gammaset_write : begin
//                oled_reg_data              <= gammaset;//8'h07;
//                oled_reg_addr              <= OLED_GAMMASET_REG_ADDR;
//                st_oled_gamma_tb_calc      <= oled_gamma_tb_i2c_write;
//                st_next_oled_gamma_tb_calc <= oled_gammaset_wait;
//            end 

//            oled_gammaset_wait : begin
//                if(tick_1ms == 1'b1)begin
//                    if(vgn_settle_time_cnt >= MAX_VGN_SETTLE_TIME)begin
//                        vgn_settle_time_cnt <= 0;
//                        st_oled_gamma_tb_calc <= oled_vgn_adc_rd;
//                    end
//                    else begin
//                        vgn_settle_time_cnt <= vgn_settle_time_cnt + 1;
//                        st_oled_gamma_tb_calc <= oled_gammaset_wait;
//                    end
//                end
//                else begin
//                    st_oled_gamma_tb_calc <= oled_gammaset_wait;
//                end
                
//            end 
            
//            oled_vgn_adc_rd : begin
//                 if(!(OLED_POS_V_VALID_LATCH || OLED_POS_H_VALID_LATCH || OLED_BRIGHTNESS_VALID_LATCH || OLED_CONTRAST_VALID_LATCH ||  OLED_IDRF_VALID_LATCH || OLED_DIMCTL_VALID_LATCH || OLED_IMG_FLIP_VALID_LATCH || OLED_POS_RGTPOS_WR_EN || OLED_POS_BOTPOS_WR_EN))begin
//                    av_i2c_address    <= {OLED_VGN_ADC_DEV_ADDR,OLED_VGN_ADC_CONV_REG_ADDR};
//                    av_i2c_read       <= 1'b1;
//                    av_i2c_data_16_en <= 1'b1; 
//                    if(av_i2c_waitrequest) begin 
//                        av_i2c_read          <= 1'b0;
//                        av_i2c_data_16_en    <= 1'b0;
//                        st_oled_gamma_tb_calc<= oled_vgn_adc_rd_wait;  
//                    end    
//                    else begin
//                        st_oled_gamma_tb_calc <= oled_vgn_adc_rd;    
//                    end 
//                    oled_vgn_bat_i2c_busy <= 1'b1;  
//                 end    
//                 else begin
//                    st_oled_gamma_tb_calc <= oled_vgn_adc_rd;
//                    oled_vgn_bat_i2c_busy <= 1'b0; 
//                 end              
//            end 
//            oled_vgn_adc_rd_wait: begin 
//                if ((!av_i2c_waitrequest)) begin
//                    st_oled_gamma_tb_calc <= oled_vgn_cf_gamma_rd;
//                    vgn_adc_rd_data       <= {av_i2c_readdata[3:0],av_i2c_readdata[15:10]};
//                    oled_vgn_bat_i2c_busy <= 1'b0; 
//                end
//                else begin
//                    st_oled_gamma_tb_calc <= oled_vgn_adc_rd_wait;
//                end
//            end
//            oled_vgn_cf_gamma_rd: begin    
//                if(vgn_gamma_mem_rd_sel == 2'd2)begin            
//                    oled_vgn_gamma_mem3_rd_addr <= vgn_adc_rd_data;
//                    oled_vgn_gamma_mem3_rd_req  <= 1'b1;
//                    oled_cf_mem_rd_addr         <= {cf_reg_cnt[6:0],1'b0} + gl_gc_cnt;
//                end
//                else if(vgn_gamma_mem_rd_sel == 2'd1)begin
//                    oled_vgn_gamma_mem2_rd_addr <= vgn_adc_rd_data;
//                    oled_vgn_gamma_mem2_rd_req  <= 1'b1;           
//                    oled_cf_mem_rd_addr         <= cf_reg_cnt + gl_gc_cnt;     
//                end
//                else if(vgn_gamma_mem_rd_sel == 2'd0)begin
//                    oled_vgn_gamma_mem1_rd_addr <= vgn_adc_rd_data;
//                    oled_vgn_gamma_mem1_rd_req  <= 1'b1;    
//                    oled_cf_mem_rd_addr         <= {4'd0,gl_gc_cnt};
//                end
//                else begin
//                    oled_vgn_gamma_mem1_rd_addr <= vgn_adc_rd_data;
//                    oled_vgn_gamma_mem1_rd_req  <= 1'b1; 
//                    oled_cf_mem_rd_addr         <= {4'd0,gl_gc_cnt};
//                end
//                oled_cf_mem_rd_req         <= 1'b1;
//                st_oled_gamma_tb_calc      <= oled_vgn_cf_gamma_rd_wait;  
//            end
//            oled_vgn_cf_gamma_rd_wait: begin 
//                oled_vgn_gamma_mem1_rd_req <= 1'b0;
//                oled_vgn_gamma_mem2_rd_req <= 1'b0;
//                oled_vgn_gamma_mem3_rd_req <= 1'b0;
//                oled_cf_mem_rd_req         <= 1'b0;
//                st_oled_gamma_tb_calc      <= oled_vgn_cf_gamma_rd_done; 
//            end  
//            oled_vgn_cf_gamma_rd_done : begin                
//                if(gl_gc_cnt == 8)begin
//                   if(vgn_gamma_mem_rd_sel == 2'd2)begin
//                    max_vgn_data <= oled_vgn_gamma_mem3_rd_data;
//                   end
//                   else if(vgn_gamma_mem_rd_sel == 2'd1)begin
//                    max_vgn_data <= oled_vgn_gamma_mem2_rd_data;
//                   end
//                   else if(vgn_gamma_mem_rd_sel == 2'd0)begin
//                    max_vgn_data <= oled_vgn_gamma_mem1_rd_data;
//                   end                   
//                   else begin
//                    max_vgn_data <= oled_vgn_gamma_mem1_rd_data;
//                   end 
//                end
//                else begin
//                   max_vgn_data <= max_vgn_data;
//                end    
                
//                if(vgn_gamma_mem_rd_sel == 2'd2)begin
//                    vgn_data <= oled_vgn_gamma_mem3_rd_data;
//                end
//                else if(vgn_gamma_mem_rd_sel == 2'd1)begin
//                    vgn_data <= oled_vgn_gamma_mem2_rd_data;
//                end
//                else if(vgn_gamma_mem_rd_sel == 2'd0)begin
//                    vgn_data <= oled_vgn_gamma_mem1_rd_data;
//                end                   
//                else begin
//                    vgn_data <= oled_vgn_gamma_mem1_rd_data;
//                end                 
               
//                cf_data               <= oled_cf_mem_rd_data[9:0];
//                st_oled_gamma_tb_calc <= oled_vgn_gamma_div; 
//            end
//            oled_vgn_gamma_div : begin
//                vgn_start_div             <= 1'b1;
//                vgn_dvsr                  <= {12'd0,max_vgn_data};
//                vgn_dvnd                  <= {vgn_data,12'd0};   // multiply by 4096
//                st_oled_gamma_tb_calc     <= oled_vgn_gamma_div_done;
//            end
            
//            oled_vgn_gamma_div_done : begin
//                vgn_start_div             <= 1'b0;
//                if(vgn_done_tick==1'b1)begin
//                    vgn_gamma_div         <= vgn_quo[12:0];
//                    st_oled_gamma_tb_calc <= oled_vgn_gc_calc;
//                end 
//            end
//            oled_vgn_gc_calc : begin
//                vgn_gc_value_temp     <= vgn_gamma_div *cf_data;
//                st_oled_gamma_tb_calc <=  oled_vgn_gc_calc_done;
//            end

//            oled_vgn_gc_calc_done : begin
//                gc[0]             <= 1;
//                if(vgn_gc_value_temp[22:12]>1023)begin
////                    vgn_gc_value <= 1023;
//                    gc[gl_gc_cnt] <= 1023;
//                end
//                else begin
////                    vgn_gc_value <= vgn_gc_value_temp[21:12];
//                    gc[gl_gc_cnt] <= vgn_gc_value_temp[21:12];  // devide by 4096
//                end
//                if(gl_gc_cnt == 1)begin
//                    gl_gc_cnt             <= 0;
//                    st_oled_gamma_tb_calc <= gamma_tb_calc_start;
//                    gammaset              <= 8'h07;
//                end
//                else begin
//                    gl_gc_cnt             <= gl_gc_cnt -1;
//                    st_oled_gamma_tb_calc <= oled_gammaset_write ;
//                    gammaset              <= gammaset -1;
//                end 
//            end

            gamma_tb_calc_start : begin
                oled_gamma_table_mem_wr_req <= 1'b0;
                if(val_8_bit == 256)begin
                    st_oled_gamma_tb_calc  <= oled_gamma_tb_read; 
                    val_8_bit              <= 0;
                end
                else begin
                    st_oled_gamma_tb_calc  <= gamma_tb_calc_index_sel;
                end
            end    

            gamma_tb_calc_index_sel:begin
                st_oled_gamma_tb_calc  <= gamma_tb_calc_mul;
                if (val_8_bit <= gl[2])begin
                    index <= 1;
                end    
                else if ((val_8_bit > gl[2])&&(val_8_bit <= gl[3]))begin
                    index <= 2;
                end
                else if ((val_8_bit > gl[3])&&(val_8_bit <= gl[4]))begin
                    index <= 3;
                end
                else if ((val_8_bit > gl[4])&&(val_8_bit <= gl[5]))begin
                    index <= 4;
                end
                else if ((val_8_bit > gl[5])&&(val_8_bit <= gl[6]))begin
                    index <= 5;
                end    
                else if ((val_8_bit > gl[6])&&(val_8_bit <= gl[7]))begin
                    index <= 6;
                end
                else begin
                    index <=  7;
                end           
            end

            gamma_tb_calc_mul: begin
                st_oled_gamma_tb_calc  <= gamma_tb_calc_div_start;
                gl_gc_mul <= (gc[index+1] - gc[index]) * (val_8_bit - gl[index]);
                gl_diff   <= (gl[index+1] - gl[index]);        
            end
            
            gamma_tb_calc_div_start: begin
                dvnd      <= gl_gc_mul;  
                dvsr      <= gl_diff;
                start_div <= 1'b1;
                st_oled_gamma_tb_calc <= gamma_tb_calc_div_done;
            end
            
            gamma_tb_calc_div_done : begin
                start_div <= 1'b0;
                if(done_tick == 1'b1)begin
                    st_oled_gamma_tb_calc <= gamma_tb_mem_write;
                    if (val_8_bit == 0)begin
                        tmpval <= gc[0];
                    end
                    else begin
                        tmpval <= gc[index] + quo; 
                    end
                end
                else begin
                   st_oled_gamma_tb_calc <= gamma_tb_calc_div_done;
                end                  
            end           
            gamma_tb_mem_write : begin
                oled_gamma_table_mem_wr_addr <= val_8_bit[7:0]; 
                oled_gamma_table_mem_wr_data <= tmpval[9:0];
                oled_gamma_table_mem_wr_req  <= 1'b1;
                st_oled_gamma_tb_calc        <= gamma_tb_calc_start;            
                val_8_bit                    <= val_8_bit +1;
            end   
            
                       
            oled_gamma_tb_read:begin
                oled_gamma_table_mem_rd_addr      <= oled_gamma_table_mem_rd_addr_temp[7:0];
                oled_gamma_table_mem_rd_addr_temp <= oled_gamma_table_mem_rd_addr_temp +1;
                oled_gamma_table_mem_rd_req       <= 1'b1;
                st_oled_gamma_tb_calc             <= oled_gamma_tb_r_lut_addr_write ;              
            end
            
            oled_gamma_tb_r_lut_addr_write: begin
                oled_gamma_table_mem_rd_req <= 1'b0;
                oled_reg_data               <= oled_gamma_table_mem_rd_addr;
                oled_reg_addr               <= OLED_R_LUT_ADDR_REG_ADDR;
                st_oled_gamma_tb_calc       <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_r_lut_datah_write;
            end          
                    
            oled_gamma_tb_r_lut_datah_write: begin
                oled_reg_data          <= {6'd0,oled_gamma_table_mem_rd_data[9:8]};
                oled_reg_addr          <= OLED_R_LUT_DATAH_REG_ADDR;
                st_oled_gamma_tb_calc  <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_r_lut_datal_write;
            end

            oled_gamma_tb_r_lut_datal_write: begin
                oled_reg_data               <= oled_gamma_table_mem_rd_data[7:0];
                oled_reg_addr               <= OLED_R_LUT_DATAL_REG_ADDR;
                st_oled_gamma_tb_calc       <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_g_lut_addr_write;
            end 

            oled_gamma_tb_g_lut_addr_write: begin
                oled_gamma_table_mem_rd_req <= 1'b0;
                oled_reg_data               <= oled_gamma_table_mem_rd_addr;
                oled_reg_addr               <= OLED_G_LUT_ADDR_REG_ADDR;
                st_oled_gamma_tb_calc       <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_g_lut_datah_write;
            end          
                    
            oled_gamma_tb_g_lut_datah_write: begin
                oled_reg_data          <= {6'd0,oled_gamma_table_mem_rd_data[9:8]};
                oled_reg_addr          <= OLED_G_LUT_DATAH_REG_ADDR;
                st_oled_gamma_tb_calc  <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_g_lut_datal_write;
            end

            oled_gamma_tb_g_lut_datal_write: begin
                oled_reg_data               <= oled_gamma_table_mem_rd_data[7:0];
                oled_reg_addr               <= OLED_G_LUT_DATAL_REG_ADDR;
                st_oled_gamma_tb_calc       <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_b_lut_addr_write;
            end 

            oled_gamma_tb_b_lut_addr_write: begin
                oled_gamma_table_mem_rd_req <= 1'b0;
                oled_reg_data               <= oled_gamma_table_mem_rd_addr;
                oled_reg_addr               <= OLED_B_LUT_ADDR_REG_ADDR;
                st_oled_gamma_tb_calc       <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_b_lut_datah_write;
            end          
                    
            oled_gamma_tb_b_lut_datah_write: begin
                oled_reg_data          <= {6'd0,oled_gamma_table_mem_rd_data[9:8]};
                oled_reg_addr          <= OLED_B_LUT_DATAH_REG_ADDR;
                st_oled_gamma_tb_calc  <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc  <= oled_gamma_tb_b_lut_datal_write;
            end

            oled_gamma_tb_b_lut_datal_write: begin
                oled_reg_data               <= oled_gamma_table_mem_rd_data[7:0];
                oled_reg_addr               <= OLED_B_LUT_DATAL_REG_ADDR;
                st_oled_gamma_tb_calc       <= oled_gamma_tb_i2c_write;
                if(oled_gamma_table_mem_rd_addr_temp == 256)begin
                    st_next_oled_gamma_tb_calc <=  oled_lut_update1; 
                end
                else begin
                    st_next_oled_gamma_tb_calc  <= oled_gamma_tb_read;
                end
            end                         
            oled_gamma_tb_i2c_write: begin
                if(!(OLED_POS_V_VALID_LATCH || OLED_POS_H_VALID_LATCH || OLED_BRIGHTNESS_VALID_LATCH || OLED_CONTRAST_VALID_LATCH ||  OLED_IDRF_VALID_LATCH || OLED_DIMCTL_VALID_LATCH || OLED_IMG_FLIP_VALID_LATCH || OLED_CATHODE_VOLTAGE_VALID_LATCH|| OLED_ROW_START_MSB_VALID_LATCH || OLED_ROW_START_LSB_VALID_LATCH || OLED_ROW_END_MSB_VALID_LATCH || OLED_ROW_END_LSB_VALID_LATCH || OLED_POS_RGTPOS_WR_EN || OLED_POS_LFTPOS_WR_EN || OLED_POS_LFTPOS_MSB_WR_EN || OLED_POS_BOTPOS_WR_EN))begin
                    av_i2c_address   <= {OLED_DEV_ADDR,oled_reg_addr};
                    av_i2c_writedata <= oled_reg_data;
                    av_i2c_write     <= 1'b1;
                    if(av_i2c_waitrequest) begin 
                        av_i2c_write          <= 1'b0;
                        st_oled_gamma_tb_calc <= oled_gamma_tb_i2c_write_wait;  
                    end    
                    else begin
                        st_oled_gamma_tb_calc <= oled_gamma_tb_i2c_write;    
                    end   
                    oled_vgn_bat_i2c_busy <= 1'b1;
                end           
                else begin
                    st_oled_gamma_tb_calc <= oled_gamma_tb_i2c_write;  
                    oled_vgn_bat_i2c_busy <= 1'b0;  
                end    
            end
            
            oled_gamma_tb_i2c_write_wait: begin
//                oled_init_mem_wr_req       <= 1'b0;
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write          <= 1'b0;
                    st_oled_gamma_tb_calc <= st_next_oled_gamma_tb_calc;
                    oled_vgn_bat_i2c_busy <= 1'b0;
                end
            end

            oled_lut_update1 : begin
                oled_reg_data              <= 8'h07;//8'h1F;       // SELECT RGB UPDATE , UPDATE ENABLE 
                oled_reg_addr              <= OLED_LUT_UPDATE_REG_ADDR;
                st_oled_gamma_tb_calc      <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc <= oled_lut_update2;
                BT656_START                <= 1'b1;
            end

            oled_lut_update2 : begin // To check lut update done //READ LUT UPDATE REG
                if(!(OLED_POS_V_VALID_LATCH || OLED_POS_H_VALID_LATCH || OLED_BRIGHTNESS_VALID_LATCH || OLED_CONTRAST_VALID_LATCH ||  OLED_IDRF_VALID_LATCH || OLED_DIMCTL_VALID_LATCH || OLED_IMG_FLIP_VALID_LATCH || OLED_CATHODE_VOLTAGE_VALID_LATCH || OLED_ROW_START_MSB_VALID_LATCH || OLED_ROW_START_LSB_VALID_LATCH || OLED_ROW_END_MSB_VALID_LATCH || OLED_ROW_END_LSB_VALID_LATCH || OLED_POS_RGTPOS_WR_EN || OLED_POS_LFTPOS_WR_EN || OLED_POS_LFTPOS_MSB_WR_EN || OLED_POS_BOTPOS_WR_EN))begin
                    av_i2c_address   <= {OLED_DEV_ADDR,OLED_LUT_UPDATE_REG_ADDR};
    //                av_i2c_writedata <= oled_reg_data;
                    av_i2c_read      <= 1'b1;
                    if(av_i2c_waitrequest) begin 
                        av_i2c_read          <= 1'b0;
                        st_oled_gamma_tb_calc <= oled_lut_update3;  
                    end    
                    else begin
                        st_oled_gamma_tb_calc <= oled_lut_update2;    
                    end
                    oled_vgn_bat_i2c_busy <= 1'b1;   
                end
                else begin
                    st_oled_gamma_tb_calc <= oled_lut_update2;
                    oled_vgn_bat_i2c_busy <= 1'b0;  
                end         
            end    

            oled_lut_update3: begin 
                if ((!av_i2c_waitrequest)) begin
//                    if(av_i2c_readdata[3] == 1'b0)begin
//                    if(av_i2c_readdata[2:0] == 3'd0)begin
                    if((av_i2c_readdata[2:0] == 3'd0) || (sel_oled_analog_video_out == 1'b1))begin
                        st_oled_gamma_tb_calc <= oled_video_on;//oled_reg_update_done;   
                    end
                    else begin
                        st_oled_gamma_tb_calc <= oled_lut_update2;  
                    end
                    oled_vgn_bat_i2c_busy <= 1'b0;
                end
//                if (av_i2c_readdatavalid == 1'b1)begin
//                    if(av_i2c_readdata[3] == 1'b0)begin
//                        st_oled_gamma_tb_calc <= oled_reg_update_done;  
//                    end
//                    else begin
//                        st_oled_gamma_tb_calc <= oled_lut_update2;  
//                    end
//                end  
            end

            oled_video_on : begin
                oled_reg_data              <= 8'h00;// Disable oled test pattern, Enable oled video
                oled_reg_addr              <= OLED_TP_MODE_ADDR;
                st_oled_gamma_tb_calc      <= oled_gamma_tb_i2c_write;
                st_next_oled_gamma_tb_calc <= oled_reg_update_done;
                BT656_START                <= 1'b1;
            end
                     
            bat_param_rd : begin
                if(bat_adc_en == 1'b0)begin
                    bat_gauge_reg_addr         <= BAT_GUAGE_CONTROL_REG_ADDR;
                    st_oled_gamma_tb_calc      <= bat_i2c_rd;
                    st_next_oled_gamma_tb_calc <= bat_control_rd; 
                end
                else begin
                    bat_gauge_reg_addr         <= OLED_VGN_ADC_CONV_REG_ADDR;
                    st_oled_gamma_tb_calc      <= bat_i2c_rd;
                    st_next_oled_gamma_tb_calc <= oled_reg_update_done; 
                end
            end
            
            
            bat_control_rd : begin
                bat_control_reg_data       <= bat_gauge_reg_data;  
                bat_gauge_reg_addr         <= BAT_GUAGE_STATUS_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_status_rd; 
            end           
            bat_status_rd : begin
                bat_status_reg_data        <= bat_gauge_reg_data;  
                bat_gauge_reg_addr         <= BAT_GUAGE_VOLTAGEM_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_voltagem_rd; 
            end
            
            bat_voltagem_rd : begin
                bat_voltage_reg_data       <= {bat_gauge_reg_data,bat_voltage_reg_data[7:0]}; 
                bat_gauge_reg_addr         <= BAT_GUAGE_VOLTAGEL_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_voltagel_rd; 
            end
            
            bat_voltagel_rd : begin
                bat_voltage_reg_data       <= {bat_voltage_reg_data[15:8],bat_gauge_reg_data}; 
                bat_gauge_reg_addr         <= BAT_GUAGE_ACC_CHARGEM_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_acc_chargem_rd; 
            end
            
            bat_acc_chargem_rd : begin
                bat_acc_charge_reg_data   <= {bat_gauge_reg_data,bat_acc_charge_reg_data[7:0]}; 
                bat_gauge_reg_addr         <= BAT_GUAGE_ACC_CHARGEL_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_acc_chargel_rd; 
            end
                        
            bat_acc_chargel_rd : begin
                bat_acc_charge_reg_data   <= {bat_acc_charge_reg_data[15:8],bat_gauge_reg_data};   
                bat_gauge_reg_addr         <= BAT_GUAGE_TEMPM_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_tempm_rd; 
            end
            
            bat_tempm_rd : begin
                bat_temp_reg_data          <= {bat_gauge_reg_data, bat_temp_reg_data[7:0]};   
                bat_gauge_reg_addr         <= BAT_GUAGE_TEMPL_REG_ADDR;
                st_oled_gamma_tb_calc      <= bat_i2c_rd;
                st_next_oled_gamma_tb_calc <= bat_templ_rd; 
            end
            
            bat_templ_rd : begin
                bat_temp_reg_data          <= {bat_temp_reg_data[15:8],bat_gauge_reg_data}; 
                bat_gauge_reg_addr         <= BAT_GUAGE_TEMPL_REG_ADDR;
                st_oled_gamma_tb_calc      <= oled_reg_update_done;
                bat_param_rd_done          <= 1'b1;   
//                if(OLED_VGN_TEST[31]==1'b1)begin
//                    st_oled_gamma_tb_calc      <= oled_reg_update_done;
//                    bat_param_rd_done         <= 1'b1;   
//                end    
            end   
                       
            bat_i2c_rd : begin
                if(!(OLED_POS_V_VALID_LATCH || OLED_POS_H_VALID_LATCH || OLED_BRIGHTNESS_VALID_LATCH || OLED_CONTRAST_VALID_LATCH ||  OLED_IDRF_VALID_LATCH || OLED_DIMCTL_VALID_LATCH || OLED_IMG_FLIP_VALID_LATCH || OLED_CATHODE_VOLTAGE_VALID_LATCH || OLED_ROW_START_MSB_VALID_LATCH || OLED_ROW_START_LSB_VALID_LATCH || OLED_ROW_END_MSB_VALID_LATCH || OLED_ROW_END_LSB_VALID_LATCH || OLED_POS_RGTPOS_WR_EN || OLED_POS_LFTPOS_WR_EN || OLED_POS_LFTPOS_MSB_WR_EN || OLED_POS_BOTPOS_WR_EN))begin
                    if(bat_adc_en == 1'b1)begin
                        av_i2c_address   <= {BAT_ADC_DEV_ADDR,bat_gauge_reg_addr};
                        av_i2c_read      <= 1'b1;
                        av_i2c_data_16_en <= 1'b1;                     
                    end
                    else begin
                        av_i2c_address   <= {BAT_GAUGE_DEV_ADDR,bat_gauge_reg_addr};
                        av_i2c_read      <= 1'b1;  
                        av_i2c_data_16_en <= 1'b0;                   
                    end
                    if(av_i2c_waitrequest) begin 
                        av_i2c_read          <= 1'b0;
                        av_i2c_data_16_en    <= 1'b0; 
                        st_oled_gamma_tb_calc <= bat_i2c_rd_wait;  
                    end    
                    else begin
                        st_oled_gamma_tb_calc <= bat_i2c_rd;    
                    end   
                    oled_vgn_bat_i2c_busy <= 1'b1;
                end
                else begin
                    st_oled_gamma_tb_calc <= bat_i2c_rd;
                    oled_vgn_bat_i2c_busy <= 1'b0;
                end                    
            end
            bat_i2c_rd_wait: begin
               if ((!av_i2c_waitrequest)) begin
                    bat_gauge_reg_data    <= av_i2c_readdata; 
                    if(bat_adc_en == 1'b1)begin
                        bat_voltage_reg_data  <= {av_i2c_readdata[3:0],av_i2c_readdata[15:10]};
                    end;    
                    st_oled_gamma_tb_calc <= st_next_oled_gamma_tb_calc;
                    oled_vgn_bat_i2c_busy <= 1'b0;  
               end
               else begin
                    st_oled_gamma_tb_calc <= bat_i2c_rd_wait;
               end       
                battery_disp_start         <= 1'b1;           
            end


//            icm_param_rd : begin
//                icm_reg_addr               <= 8'h10;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_status_start_rd;                 
//            end            
            
//            icm_magneto_status_start_rd : begin
//                icm_reg_addr               <= 8'h12;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_x_msb_rd; 
//            end           
//            icm_magneto_x_msb_rd : begin
//                magneto_x_data             <= {icm_reg_data,magneto_x_data[7:0]}; 
//                icm_reg_addr               <= 8'h11;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_x_lsb_rd; 
//            end
            
//            icm_magneto_x_lsb_rd : begin
//                magneto_x_data             <= {magneto_x_data[15:8],icm_reg_data}; 
//                icm_reg_addr               <= 8'h14;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_y_msb_rd; 
//            end           

//            icm_magneto_y_msb_rd : begin
//                magneto_y_data             <= {icm_reg_data,magneto_y_data[7:0]}; 
//                icm_reg_addr               <= 8'h13;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_y_lsb_rd; 
//            end
            
//            icm_magneto_y_lsb_rd : begin
//                magneto_y_data             <= {magneto_y_data[15:8],icm_reg_data}; 
//                icm_reg_addr               <= 8'h16;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_z_msb_rd; 
//            end     

//            icm_magneto_z_msb_rd : begin
//                magneto_z_data             <= {icm_reg_data,magneto_z_data[7:0]}; 
//                icm_reg_addr               <= 8'h15;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= icm_magneto_z_lsb_rd; 
//            end
            
//            icm_magneto_z_lsb_rd : begin
//                magneto_z_data             <= {magneto_z_data[15:8],icm_reg_data}; 
//                icm_reg_addr               <= 8'h18;
//                st_oled_gamma_tb_calc      <= icm_i2c_rd;
//                st_next_oled_gamma_tb_calc <= oled_reg_update_done;
//            end     

            icm_param_rd : begin
                icm_reg_addr               <= 8'h2D;
                icm_i2c_dev_addr           <= ACCEL_DEV_ADDRESS;       
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_accel_x_msb_rd ;                 
            end    
            
            icm_accel_x_msb_rd : begin
                accel_x_data               <= {icm_reg_data,accel_x_data[7:0]}; 
                icm_reg_addr               <= 8'h2E;
                icm_i2c_dev_addr           <= ACCEL_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_accel_x_lsb_rd; 
            end
            
            icm_accel_x_lsb_rd : begin
                accel_x_data               <= {accel_x_data[15:8],icm_reg_data}; 
                icm_reg_addr               <= 8'h2F;
                icm_i2c_dev_addr           <= ACCEL_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_accel_y_msb_rd; 
            end           

            icm_accel_y_msb_rd : begin
                accel_y_data             <= {icm_reg_data,accel_y_data[7:0]}; 
                icm_reg_addr               <= 8'h30;
                icm_i2c_dev_addr           <= ACCEL_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_accel_y_lsb_rd; 
            end
            
            icm_accel_y_lsb_rd : begin
                accel_y_data               <= {accel_y_data[15:8],icm_reg_data}; 
                icm_reg_addr               <= 8'h31;
                icm_i2c_dev_addr           <= ACCEL_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_accel_z_msb_rd; 
            end     

            icm_accel_z_msb_rd : begin
                accel_z_data               <= {icm_reg_data,accel_z_data[7:0]}; 
                icm_reg_addr               <= 8'h32;
                icm_i2c_dev_addr           <= ACCEL_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_accel_z_lsb_rd; 
            end  
            
           icm_accel_z_lsb_rd : begin
                accel_z_data               <= {accel_z_data[15:8],icm_reg_data}; 
//                st_oled_gamma_tb_calc      <= icm_magneto_rd_wait;
//                st_next_oled_gamma_tb_calc <= icm_magneto_rd_wait; 
//                icm_magneto_rd_wait_cnt    <= 0;
                icm_reg_addr               <= 8'h10;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_status_start_rd;                
            end    
            icm_magneto_status_start_rd : begin
                icm_reg_addr               <= 8'h12;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_x_msb_rd; 
            end           
            
            icm_magneto_x_msb_rd : begin
                magneto_x_data             <= {icm_reg_data,magneto_x_data[7:0]}; 
                icm_reg_addr               <= 8'h11;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_x_lsb_rd; 
            end
            
            icm_magneto_x_lsb_rd : begin
                magneto_x_data             <= {magneto_x_data[15:8],icm_reg_data}; 
                icm_reg_addr               <= 8'h14;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_y_msb_rd; 
            end           

            icm_magneto_y_msb_rd : begin
                magneto_y_data             <= {icm_reg_data,magneto_y_data[7:0]}; 
                icm_reg_addr               <= 8'h13;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_y_lsb_rd; 
            end
            
            icm_magneto_y_lsb_rd : begin
                magneto_y_data             <= {magneto_y_data[15:8],icm_reg_data}; 
                icm_reg_addr               <= 8'h16;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_z_msb_rd; 
            end     

            icm_magneto_z_msb_rd : begin
                magneto_z_data             <= {icm_reg_data,magneto_z_data[7:0]}; 
                icm_reg_addr               <= 8'h15;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= icm_magneto_z_lsb_rd; 
            end
            
            icm_magneto_z_lsb_rd : begin
                magneto_z_data             <= {magneto_z_data[15:8],icm_reg_data}; 
                icm_reg_addr               <= 8'h18;
                icm_i2c_dev_addr           <= MAGNETO_DEV_ADDRESS;
                st_oled_gamma_tb_calc      <= icm_i2c_rd;
                st_next_oled_gamma_tb_calc <= oled_reg_update_done;      
            end  
                                                                
            icm_i2c_rd : begin
                if(!(OLED_POS_V_VALID_LATCH || OLED_POS_H_VALID_LATCH || OLED_BRIGHTNESS_VALID_LATCH || OLED_CONTRAST_VALID_LATCH ||  OLED_IDRF_VALID_LATCH || OLED_DIMCTL_VALID_LATCH || OLED_IMG_FLIP_VALID_LATCH || OLED_CATHODE_VOLTAGE_VALID_LATCH || OLED_ROW_START_MSB_VALID_LATCH || OLED_ROW_START_LSB_VALID_LATCH || OLED_ROW_END_MSB_VALID_LATCH || OLED_ROW_END_LSB_VALID_LATCH || OLED_POS_RGTPOS_WR_EN || OLED_POS_LFTPOS_WR_EN || OLED_POS_LFTPOS_MSB_WR_EN || OLED_POS_BOTPOS_WR_EN))begin
                    av_i2c_address   <= {icm_i2c_dev_addr,icm_reg_addr};
                    av_i2c_read      <= 1'b1;  
                    av_i2c_data_16_en <= 1'b0;      
                    
                    if(av_i2c_waitrequest) begin 
                        av_i2c_read          <= 1'b0;
                        av_i2c_data_16_en    <= 1'b0; 
                        st_oled_gamma_tb_calc <= icm_i2c_rd_wait;  
                    end    
                    else begin
                        st_oled_gamma_tb_calc <= icm_i2c_rd;    
                    end   
                    oled_vgn_bat_i2c_busy <= 1'b1;
                end
                else begin
                    st_oled_gamma_tb_calc <= icm_i2c_rd;
                    oled_vgn_bat_i2c_busy <= 1'b0;
                end                    
            end
            icm_i2c_rd_wait: begin
               if ((!av_i2c_waitrequest)) begin
                    icm_reg_data    <= av_i2c_readdata;   
                    st_oled_gamma_tb_calc <= st_next_oled_gamma_tb_calc;
                    oled_vgn_bat_i2c_busy <= 1'b0;  
               end
               else begin
                    st_oled_gamma_tb_calc <= icm_i2c_rd_wait;
               end                  
            end



            shutter_operation_wait : begin
                    if(shutter_i2c_write_again_wait_counter == 5) begin
                        st_oled_gamma_tb_calc <=shutter_close ;  
                        shutter_i2c_write_again_wait_counter <= 16'd0;
                    end
                    else begin
                        st_oled_gamma_tb_calc <= shutter_operation_wait ;  
                        if(tick_1ms) begin 
                            shutter_i2c_write_again_wait_counter <= shutter_i2c_write_again_wait_counter +1; 
                        end                
                    end  
            end 
                               
            shutter_close: begin
                if(!(OLED_POS_V_VALID_LATCH || OLED_POS_H_VALID_LATCH || OLED_BRIGHTNESS_VALID_LATCH || OLED_CONTRAST_VALID_LATCH ||  OLED_IDRF_VALID_LATCH || OLED_DIMCTL_VALID_LATCH || OLED_IMG_FLIP_VALID_LATCH || OLED_CATHODE_VOLTAGE_VALID_LATCH  || OLED_ROW_START_MSB_VALID_LATCH || OLED_ROW_START_LSB_VALID_LATCH || OLED_ROW_END_MSB_VALID_LATCH || OLED_ROW_END_LSB_VALID_LATCH || OLED_POS_RGTPOS_WR_EN || OLED_POS_LFTPOS_WR_EN || OLED_POS_LFTPOS_MSB_WR_EN || OLED_POS_BOTPOS_WR_EN))begin
                    av_i2c_address             <= {1'b0,SHUTTER_ADDR,SHUTTER_REG_ADDRESS};
                    av_i2c_writedata           <= {SHUTTER_OFF_DATA_MSB,SHUTTER_OFF_DATA_LSB};
                    av_i2c_write               <= 1'b1;
                    av_i2c_data_16_en          <= 1'b1;
                    st_oled_gamma_tb_calc      <= shutter_i2c_write;
                    st_next_oled_gamma_tb_calc <= nuc1pt_start_st;
                    oled_vgn_bat_i2c_busy      <= 1'b1; 
                end           
                else begin
                    st_oled_gamma_tb_calc <= shutter_close;  
                    oled_vgn_bat_i2c_busy <= 1'b0;  
                end 
            end    


            shutter_i2c_write: begin
                    if(av_i2c_waitrequest)begin
                        av_i2c_write          <= 1'b0;
                        av_i2c_data_16_en     <= 1'b0;
                        st_oled_gamma_tb_calc <= shutter_i2c_write_wait;
                    end
                    else begin
                        av_i2c_write          <= 1'b1;
                        st_oled_gamma_tb_calc <= shutter_i2c_write;
                    end
            end
            
            shutter_i2c_write_wait :begin
                if(!av_i2c_waitrequest)begin
                    av_i2c_write          <= 1'b0;
                    if(i2c_ack_error)begin
                        st_oled_gamma_tb_calc <= shutter_i2c_write_again ;
                    end
                    else begin  
                        st_oled_gamma_tb_calc <= st_next_oled_gamma_tb_calc ;
                    end
                end
                else begin
                    st_oled_gamma_tb_calc <= shutter_i2c_write_wait;
                end    
            end
            
            shutter_i2c_write_again : begin
//                    if(shutter_i2c_write_again_wait_counter == 10000) begin
                    if(shutter_i2c_write_again_wait_counter == 5) begin
                        av_i2c_write          <= 1'b1;
                        av_i2c_data_16_en     <= 1'b1;
                        st_oled_gamma_tb_calc <=shutter_i2c_write ;  
                        shutter_i2c_write_again_wait_counter <= 16'd0;
                    end
                    else begin
                        st_oled_gamma_tb_calc <= shutter_i2c_write_again ;  
                        if(tick_1ms) begin 
                            shutter_i2c_write_again_wait_counter <= shutter_i2c_write_again_wait_counter +1; 
                        end                
                    end   
                              
            end
            nuc1pt_start_st : begin

                if(nuc1pt_start_time_cnt == 60) begin
                    nuc1pt_start          <= 1'b1;
                    st_oled_gamma_tb_calc <= nuc1pt_wait_st;
                    nuc1pt_start_time_cnt <= 0;                   
                end
                else begin
                    if(tick_1ms) begin 
                        nuc1pt_start_time_cnt <= nuc1pt_start_time_cnt +1; 
                    end 
                end 
            end    
            
            nuc1pt_wait_st : begin
                nuc1pt_start <= 1'b0;
                if(nuc1pt_done)begin
                    st_oled_gamma_tb_calc <= shutter_open;
                end
                else begin                
                    st_oled_gamma_tb_calc <= nuc1pt_wait_st;
                end    
            end    

            shutter_open: begin
                    av_i2c_address             <= {1'b0,SHUTTER_ADDR,SHUTTER_REG_ADDRESS};
                    av_i2c_writedata           <= {SHUTTER_ON_DATA_MSB,SHUTTER_ON_DATA_LSB};
                    av_i2c_write               <= 1'b1;
                    av_i2c_data_16_en          <= 1'b1; 
                    st_oled_gamma_tb_calc      <= shutter_i2c_write;
                    st_next_oled_gamma_tb_calc <= nuc1pt_done_st;
            end   

            nuc1pt_done_st : begin
                st_oled_gamma_tb_calc <= oled_reg_update_done;
                oled_vgn_bat_i2c_busy <= 1'b0;
                av_i2c_data_16_en     <= 1'b0;
                control_sdram_write_start_stop    <= 1'b0; 
            end
                        
            oled_reg_update_done : begin
                oled_gamma_table_mem_rd_addr_temp <= 0;
                oled_gamma_table_mem_rd_addr      <= 0;  
                OLED_GAMMA_TABLE_SEL_D            <= OLED_GAMMA_TABLE_SEL; 
//                vgn_gc_sel <= OLED_VGN_TEST[0];
//                bat_param_rd_en                   <= OLED_VGN_TEST[0];
                oled_vgn_bat_i2c_busy             <= 1'b0;
//                if(((OLED_GAMMA_TABLE_SEL_D != OLED_GAMMA_TABLE_SEL) || (vgn_rd_en_latch == 1'b1) || (oled_reinit_vgn_rd_en == 1'b1)) &&(oled_standby_process_busy == 1'b0 && oled_power_off == 1'b0) && (product_sel == 1'b0))begin
                if(((OLED_GAMMA_TABLE_SEL_D != OLED_GAMMA_TABLE_SEL)|| (oled_reinit_vgn_rd_en == 1'b1)) &&(oled_standby_process_busy == 1'b0 && oled_power_off == 1'b0) && (product_sel == 1'b0))begin
                    st_oled_gamma_tb_calc <= gl_read;
                    vgn_rd_en_latch       <= 1'b0;
                    oled_reinit_vgn_rd_en <= 1'b0;
                    oled_vgn_bat_shutter_process_busy <= 1'b1;
                end
                else if((shutter_enable_latch == 1'b1 && DMA_WRITE_FREE == 1'b1 && video_start == 1'b1)&&(oled_standby_process_busy == 1'b0))begin
                    st_oled_gamma_tb_calc     <= shutter_operation_wait;//shutter_close;    
                    shutter_enable_latch      <= 1'b0;
                    oled_vgn_bat_shutter_process_busy <= 1'b1;
                    control_sdram_write_start_stop    <= 1'b1;
                end  
                else if(((bat_param_rd_en_latch==1'b1) || bat_param_initial_rd_done!=1'b1) && (oled_standby_process_busy == 1'b0) && (product_sel == 1'b0))begin
                    st_oled_gamma_tb_calc     <= bat_param_rd;
                    bat_param_rd_done         <= 1'b0;
                    bat_param_initial_rd_done <= 1'b1;
                    bat_param_rd_en_latch     <= 1'b0;
                    oled_vgn_bat_shutter_process_busy <= 1'b1;
                end
                else if(((icm_param_rd_en_latch==1'b1)) && (oled_standby_process_busy == 1'b0) && (product_sel == 1'b0))begin
                    st_oled_gamma_tb_calc     <= icm_param_rd;
                    icm_param_rd_done         <= 1'b0;
                    icm_param_rd_en_latch     <= 1'b0;
                    oled_vgn_bat_shutter_process_busy <= 1'b1;
                end 
                else begin
                    st_oled_gamma_tb_calc <= oled_reg_update_done;
                    oled_vgn_bat_shutter_process_busy <= 1'b0;
                end
            end      
        endcase        
        
//        case (st_oled_vgn_gc_coeff_calc)
//            oled_vgn_gc_coeff_calc_idle :begin
//                if(OLED_VGN_TEST[31]==1'b1)begin
//                    st_oled_vgn_gc_coeff_calc <= oled_cf_read;
//                end
//                else begin
//                    st_oled_vgn_gc_coeff_calc <= oled_vgn_gc_coeff_calc_idle;
//                end    
//            end
//            oled_cf_read: begin
//                oled_cf_mem_rd_addr       <= {4'd0,OLED_VGN_TEST[15:12]};//oled_cf_mem_rd_addr_temp;
//                oled_cf_mem_rd_addr_temp  <= oled_cf_mem_rd_addr_temp +1;
//                oled_cf_mem_rd_req        <= 1'b1;
//                st_oled_vgn_gc_coeff_calc <= oled_cf_read_wait;
//            end 
//            oled_cf_read_wait: begin
//                oled_cf_mem_rd_req        <= 1'b0;
//                st_oled_vgn_gc_coeff_calc <= oled_max_vgn_gamma_rd;
//            end
//            oled_max_vgn_gamma_rd: begin 
//                cf_data                    <= oled_cf_mem_rd_data[9:0];
//                oled_vgn_gamma_mem_rd_addr <= OLED_VGN_TEST[25:16];
//                oled_vgn_gamma_mem_rd_req  <= 1'b1;
//                st_oled_vgn_gc_coeff_calc  <= oled_max_vgn_gamma_rd_wait;  
//            end
//            oled_max_vgn_gamma_rd_wait: begin
//                oled_vgn_gamma_mem_rd_req  <= 1'b0;
//                st_oled_vgn_gc_coeff_calc  <= oled_vgn_gamma_rd;
//            end             

//            oled_vgn_gamma_rd: begin 
//                max_vgn                    <= oled_vgn_gamma_mem_rd_data;
//                oled_vgn_gamma_mem_rd_addr <= OLED_VGN_TEST[9:0];
//                oled_vgn_gamma_mem_rd_req  <= 1'b1;
//                st_oled_vgn_gc_coeff_calc  <= oled_vgn_gamma_rd_wait;  
//            end
//            oled_vgn_gamma_rd_wait: begin 
//                oled_vgn_gamma_mem_rd_req  <= 1'b0;
//                st_oled_vgn_gc_coeff_calc  <= oled_vgn_gamma_div; 
//            end  
            
//            oled_vgn_gamma_div : begin
//                vgn_start_div             <= 1'b1;
//                vgn_dvsr                  <= {12'd0,max_vgn};
//                vgn_dvnd                  <= {oled_vgn_gamma_mem_rd_data,12'd0};
//                st_oled_vgn_gc_coeff_calc <= oled_vgn_gamma_div_done;
//            end
            
//            oled_vgn_gamma_div_done : begin
//                vgn_start_div             <= 1'b0;
//                if(vgn_done_tick==1'b1)begin
//                    vgn_gamma_div <= vgn_quo[12:0];
//                    st_oled_vgn_gc_coeff_calc <= oled_vgn_gc_calc;
//                end 
//            end
//            oled_vgn_gc_calc : begin
//                vgn_gc_value_temp <= vgn_gamma_div *cf_data;
//                st_oled_vgn_gc_coeff_calc <=  oled_vgn_gc_calc_done;
//            end

//            oled_vgn_gc_calc_done : begin
//                if(vgn_gc_value_temp[22:12]>1023)begin
//                    vgn_gc_value <= 1023;
//                end
//                else begin
//                    vgn_gc_value <= vgn_gc_value_temp[21:12];
//                end
//                if(OLED_VGN_TEST[31]==1'b0)begin
//                  st_oled_vgn_gc_coeff_calc <= oled_vgn_gc_coeff_calc_idle;
//                end
//                else begin
//                  st_oled_vgn_gc_coeff_calc <=  oled_vgn_gc_calc_done;
//                end
//            end
            
            
//        endcase



        pal_ntsc_sel_d        <= pal_ntsc_sel;
        
        case (st_adv_init)
            r_adv_init_idle : begin
                adv_init_mem_rd_addr_temp <= 0;
                adv_pal_init_mem_rd_req   <= 1'b0;
                adv_ntsc_init_mem_rd_req  <= 1'b0;
                ADV_REG_WR_CNT            <= 0;  
                if(adv_init_done == 1'b1)begin
                    st_adv_init <= r_adv_init_wait;      
                end
                else begin
                    st_adv_init <= r_adv_init_idle;      
                end
            end
            
            r_adv_init_wait : begin
                adv_init_mem_rd_addr_temp <= 0;
                adv_pal_init_mem_rd_req   <= 1'b0;
                adv_ntsc_init_mem_rd_req  <= 1'b0;
                ADV_REG_WR_CNT            <= 0;                  
                if(pal_ntsc_sel_pos_edge==1'b1 || pal_ntsc_sel_neg_edge==1'b1)begin
                    st_adv_init <= r_adv_init_rd;   
                end
                else begin
                    st_adv_init <= r_adv_init_wait;
                end 
            end
            
            r_adv_init_rd : begin   
               if(ADV_REG_WR_CNT == ADV_REG_CNT)begin
                    adv_init_mem_rd_addr_temp <= 0;
                    adv_pal_init_mem_rd_req   <= 1'b0;
                    adv_ntsc_init_mem_rd_req  <= 1'b0;
                    ADV_REG_WR_CNT            <= 0;
                    st_adv_init               <= r_adv_init_wait;//r_adv_init_idle;
               end
               else begin  
                    if(pal_ntsc_sel == 1'b1)begin  
                        adv_pal_init_mem_rd_addr      <= adv_init_mem_rd_addr_temp;
                        adv_pal_init_mem_rd_req       <= 1'b1;
                     end
                     else begin
                        adv_ntsc_init_mem_rd_addr      <= adv_init_mem_rd_addr_temp;
                        adv_ntsc_init_mem_rd_req       <= 1'b1;                     
                     end
                     adv_init_mem_rd_addr_temp <= adv_init_mem_rd_addr_temp +1;
                     st_adv_init               <= r_adv_init_rd_wait;
               end          
             end
            
            r_adv_init_rd_wait:begin
                adv_pal_init_mem_rd_req    <= 1'b0;
                adv_ntsc_init_mem_rd_req    <= 1'b0;
                st_adv_init            <= r_adv_init_wr_i2c;
            end
            
            r_adv_init_wr_i2c: begin
                    if(pal_ntsc_sel == 1'b1)begin
                        av_i2c_address   <= {ADV_DEV_ADDR,adv_pal_init_mem_rd_data[7: 0]};
                        av_i2c_writedata <= adv_pal_init_mem_rd_data[23:16];
                    end
                    else begin
                        av_i2c_address   <= {ADV_DEV_ADDR,adv_ntsc_init_mem_rd_data[7: 0]};
                        av_i2c_writedata <= adv_ntsc_init_mem_rd_data[23:16];                    
                    end
                    av_i2c_write <= 1'b1;                    
                    if(av_i2c_waitrequest) begin 
                        av_i2c_write      <= 1'b0;
                        av_i2c_data_16_en <= 1'b0;
                        ADV_REG_WR_CNT    <= ADV_REG_WR_CNT +1;
                        st_adv_init       <= r_adv_init_wr_i2c_wait;  
                    end    
                    else begin
                        st_adv_init <= r_adv_init_wr_i2c;    
                    end          
            end
            
            r_adv_init_wr_i2c_wait: begin
                if ((!av_i2c_waitrequest)) begin
                    av_i2c_write <= 1'b0;
                    st_adv_init  <= r_adv_init_rd;
                end
            end                      
        endcase          

        
        if ((timeout_count == 10000)) begin
            timeout_count <= 0;
            //st <= r_send_failure;
        end
        else begin
            if (tick_1ms) begin
                timeout_count <= (timeout_count + 1);
            end
        end

                                               
    end
end

 

//////////////////////////////////////////////////////////////////////////////////////
always @(crc_calculated) begin: REGS_MASTER_CRC_CALC1
    integer i;
    for (i=0; i<8; i=i+1) begin
        crc_a[i] = (!crc_calculated[i]);
    end
end



assign crc_b = (crc_a + 1);


always @(posedge clk) begin: REGS_MASTER_DPRAM_ASYM_1_PORTA_WRITE
    reg [2-1:0] lsbaddrA;
    integer i;
    lsbaddrA = 2'h0;
    if (1'b0) begin
        if (we_db) begin
            for (i=0; i<4; i=i+1) begin
                lsbaddrA = i[2-1:0];
                dpram_asym_1_mem[{addrA_db, lsbaddrA}] <= diA_db[i*8 +: 8];
            end
        end
    end
    else begin
        if (we_db) begin
            dpram_asym_1_mem[addrA_db] <= diA_db;
        end
    end
end


always @(posedge clk) begin: REGS_MASTER_DPRAM_ASYM_1_RAMREAD
    reg [2-1:0] lsbaddrB;
    integer i;
    lsbaddrB = 2'h0;
    if (1'b0) begin
        dpram_asym_1_readB <= dpram_asym_1_mem[addrB_db];
    end
    else begin
        for (i=0; i<4; i=i+1) begin
            lsbaddrB = i[2-1:0];
            dpram_asym_1_readB[i*8 +:8] <= dpram_asym_1_mem[{addrB_db, lsbaddrB}];
        end
    end
end



assign doB_db = dpram_asym_1_readB;


always @(posedge clk) begin: REGS_MASTER_DPRAM_ASYM_2_PORTA_WRITE
    reg [2-1:0] lsbaddrA;
    integer i;
    lsbaddrA = 2'h0;
    if (1'b1) begin
        if (we_rdb) begin
            for (i=0; i<4; i=i+1) begin
                lsbaddrA = i[2-1:0];
                dpram_asym_2_mem[{addrA_rdb, lsbaddrA}] <= diA_rdb[i*8 +:8];
            end
        end
    end
    else begin
        if (we_rdb) begin
            dpram_asym_2_mem[addrA_rdb] <= diA_rdb;
        end
    end
end


always @(posedge clk) begin: REGS_MASTER_DPRAM_ASYM_2_RAMREAD
    reg [2-1:0] lsbaddrB;
    integer i;
    lsbaddrB = 2'h0;
    if (1'b1) begin
        dpram_asym_2_readB <= dpram_asym_2_mem[addrB_rdb];
    end
    else begin
        for (i=0; i<4; i=i+1) begin
            lsbaddrB = i[2-1:0];
            dpram_asym_2_readB[i*8 +:8] <= dpram_asym_2_mem[{addrB_rdb, lsbaddrB}];
        end
    end
end



assign doB_rdb = dpram_asym_2_readB;



assign trigger_edge = (trigger && (!trigger_reg));


//always @(posedge clk) begin: REGS_MASTER_DATA_ASSIGN
//    if (((st == 5'b00100) || (st == 5'b00101))) begin
//        av_wrsdram_writedata = doB_db;
//    end
//end
// wire [127:0] probe0;
// assign probe0 = {
//                  qspi_state,
//                  qspi_state_temp,
////                  c_cmd,
//                  qspi_init_cmd_done,
//                  sensor_trigger,
//                  qspi_sensor_init_wr_st,
//                  qspi_sdram_trans_st,
//                  qspi_temperature_wr_st,
//                  qspi_temperature_wr_enable,
//                  qspi_erase_enable,
//                  qspi_erase_64KB_enable,
//                  qspi_erase_32KB_enable,
//                  qspi_erase_4KB_enable,
//                  qspi_sdram_trans_enable,
//                  st,
//                  rd_qspi_wr_sdram_enable,
//                  ch_img_rd_qspi_wr_sdram_en,
//                  DMA_WRITE_FREE,
//                  av_spi_write,
//                  SENSOR_st,
//                  SENSOR_st_temp,
////                  DELAY_CNT,
////                  tick_1us,
//                  qspi_init_cmd_done,
//                  init_done,
//                  sensor_init_mem_rd_addr,
//                  sensor_init_mem_rd_req,
//                  update_gfid_gsk,
//                  clk,
//                  rst,      
//                  sensor_init_write_data_valid,
//                  sensor_init_mem_write_cnt,
////                  sensor_init_mem_wr_req,  
////                  sensor_trigger,
////                  SNSR_FPGA_NRST_SPI_CS, 
////                  SNSR_FPGA_I2C2_SCL_SPI_SCK,
////                  SNSR_FPGA_I2C2_SDA_SPI_SDO, 
//                  video_start,    
//                  BT656_START, 
//                  RETICLE_WR_EN,
////                  time_cnt,
//                  time_cnt_Start,
//                  OSD_SAVE_BP,
//                  qspi_reticle_transfer_rq_ack,
//                  qspi_reticle_transfer_rq,
//                  qspi_reticle_transfer_done,
//                  PAL_nNTSC_SEL_DONE,
//                  PAL_nNTSC,
//                  av_i2c_readdatavalid,
//                  av_i2c_readdata,
//                  av_i2c_read,
//                  st_oled_gamma_tb_calc,
//                  st_next_oled_gamma_tb_calc,
//                  av_i2c_waitrequest,
//                  av_i2c_address,
//                  av_i2c_writedata,
//                  av_i2c_write,
//                  6'd0

//                  };
// ila_0 ila2 (
//  .clk(clk), // input wire clk
//  .probe0(probe0) // input wire [127:0] probe0
// );


//wire [127:0] probe1;
// assign probe1 ={
////        st_oled_vgn_gc_coeff_calc,
//        st_oled_gamma_tb_calc,
//        st_next_oled_gamma_tb_calc,
////        OLED_VGN_TEST, 
////        oled_cf_mem_rd_addr,
//        oled_cf_mem_rd_req,
//        cf_data,
////        oled_cf_mem_rd_data,
////        oled_vgn_gamma_mem1_rd_req,
////        oled_vgn_gamma_mem1_rd_addr,
////        oled_vgn_gamma_mem2_rd_req,
////        oled_vgn_gamma_mem2_rd_addr,
////        oled_vgn_gamma_mem3_rd_req,
////        oled_vgn_gamma_mem3_rd_addr,
//        bat_gauge_reg_addr,
//        bat_gauge_reg_data,
//        bat_voltage_reg_data,
//        bat_param_rd_en,
//        bat_param_rd_done, 
////        vgn_gamma_mem_rd_sel,
//        vgn_rd_en_latch,
//        vgn_rd_en,
////        vgn_gamma_mem_wr_sel,        
////        oled_vgn_gamma_mem_rd_data,
//        max_vgn_data,
////        vgn_dvnd,
////        vgn_dvsr,
//        vgn_start_div,
//        vgn_done_tick,
//        vgn_gamma_div,
//        vgn_gc_value_temp,
////        vgn_gc_value,
//        vgn_adc_rd_data,bat_param_initial_rd_done};
////        vgn_quo};

// ila_0 ila_vgn (
//  .clk(clk), // input wire clk
//  .probe0(probe1) // input wire [127:0] probe0
// );
//wire [255:0] probe1;
////////// assign probe1 = {qspi_init_cmd_done,qspi_mem_rd_rq,qspi_rx_rd_fifo_full,qspi_rx_rd_fifo_clr,qspi_rx_rd_fifo_empty,qspi_send_rd_size,qspi_rx_wr_data_word,qspi_rx_rd_fifo_data,c_cmd,src_address,sdram_send_adddr};
////////assign probe1 = {SNSR_FPGA_I2C2_SCL_SPI_SCK,SNSR_FPGA_I2C2_SDA_SPI_SDO,SNSR_FPGA_NRST_SPI_CS,sensor_trigger,SENSOR_st,sensor_spi_writedata,sensor_init_mem_rd_data_d,c_cmd , sensor_init_mem_write_cnt, sensor_init_mem_wr_req,sensor_init_mem_wr_addr,sensor_init_mem_rd_addr,qspi_init_cmd_done,sensor_init_write_data,sensor_init_write_data_valid,st};
 
////// assign probe1 = {DMA_WRITE_FREE,qspi_busy,qspi_init_cmd_done,qspi_mem_rd_rq,qspi_sdram_trans_st,sdram_write_byte_cnt,qspi_send_busy,
//////                  av_wrsdram_waitrequest,qspi_state,//qspi_rd_cnt,
//////                  temp_qspi_read_cnt,ch_img_sum,//data_trans_len_d,src_address_d,//qspi_temperature_wr_enable,
//////                  qspi_temperature_wr_st,
//////                  ch_img_rd_qspi_wr_sdram_en,
//////                  qspi_trigger};
//// assign probe1 =   {dest_address_d,
////                    //src_address_d,
////                    sensor_init_mem_wr_data1,
////                    qspi_sensor_init_wr_st,
////                    sensor_init_mem_rd_req1,
////                    sensor_init_mem_wr_req1,
////                    update_sensor_init,
////                    low_high_sel,
////                    sensor_init_mem_wr_addr1,
////                    sensor_init_rd_byte_cnt,
                    
////                    //qspi_addr, 
////                    qspi_trans_len,
////                    qspi_erase_start_addr,
////                    //qspi_erase_end_addr,
////                    number_of_erase_block,
////                    st,
////                    qspi_sdram_trans_st,
////                    qspi_erase_64KB_enable,
////                    qspi_erase_32KB_enable,
////                    qspi_erase_4KB_enable,
////                    qspi_busy,
////                    qspi_sdram_trans_st_next, 
////                    qspi_state,
////                    qspi_init_cmd_done,
////                    temperature_wr_rq,
////                    qspi_temperature_wr_enable,
////                    //qspi_temperature_wr_enable_d,
////                    cmd,
////                    qspi_erase_enable ,
////                    av_spi_writedata,
////                    av_spi_write,
////                    av_spi_address                                
////                   };
//// ila_0 regs_master_ila (
////    .clk(clk), // input wire clk
////    .probe0(probe1) // input wire [127:0] probe0
//// );

//wire [127:0] probe0;
//assign probe0 ={
//    qspi_reticle_transfer_rq,
//    qspi_reticle_transfer_rq_ack,
//    qspi_reticle_transfer_done,
//    qspi_oled_init_wr_st,
//    qspi_busy,
////    switch_to_factory_settings_en_d, 
//    save_user_settings_en,          
//    qspi_user_settings_trans_en,    
//    qspi_sdram_trans_enable,  
//    qspi_send_busy,
//    st,
//    qspi_sdram_trans_st,
//    qspi_state,
//    qspi_erase_enable,
//    qspi_addr,
//    sdram_addr,
//    qspi_oled_init_wr_enable,
//    qspi_oled_init_wr_enable_latch,
//    qspi_erase_4KB_enable,
//    qspi_trans_len[28:0]
    
////    qspi_trans_len    
//    };

// ila_0 regs_master_ila2 (
//  .clk(clk), // input wire clk
//  .probe0(probe0) // input wire [127:0] probe0
// );

                
//wire [127:0] probe1;

//// assign probe1 =   {dest_address_d,
////                    src_address_d,  
////                    data_trans_len_d,
////                    qspi_oled_init_wr_enable,
////                    qspi_oled_init_wr_enable_latch,
////                    qspi_erase_4KB_enable,        
//////                    sensor_init_mem_wr_data1,
////                    //qspi_sensor_init_wr_st,
////                    qspi_send_busy,
////                    save_user_settings_en,
////                    qspi_reticle_transfer_rq,
////                    qspi_reticle_transfer_rq_ack,
////                    qspi_reticle_transfer_done,
////                    load_factory_settings_en,
////                    load_user_settings_en,
////                    switch_to_factory_settings_en,
////                    //sensor_init_mem_rd_req1,
////                    //sensor_init_mem_wr_req1,
////                    //update_sensor_init,
//////                    low_high_sel,
////                    //sensor_init_mem_wr_addr1,
////                    //sensor_init_rd_byte_cnt,
                    
////                    //qspi_addr, 
//////                    qspi_trans_len,
//////                    page_wr_cnt,
////                    //qspi_erase_start_addr,
////                    //qspi_erase_end_addr,
////                    number_of_erase_block
//////                    st,
//////                    qspi_sdram_trans_st,
//////                    qspi_erase_64KB_enable,
//////                    qspi_page_wr_rq,
////                    //qspi_erase_32KB_enable,
//////                    qspi_erase_4KB_enable,
//////                    qspi_busy,
//////                    qspi_sdram_trans_st_next, 
//////                    qspi_state,
//////                    qspi_init_cmd_done,
//////                    temperature_wr_rq,
//////                    qspi_temperature_wr_enable,
////                    //qspi_temperature_wr_enable_d,
////                    //cmd,
//////                    qspi_erase_enable ,
//////                    qspi_send_addr,
////                    //av_spi_writedata,
//////                    qspi_sdram_trans_enable,
////                    //av_spi_write,
////                    //av_spi_address 
//////                    sdram_read_byte_cnt,
//////                    qspi_wr_data_valid, 
//////                    qspi_wr_cnt,
//////                    temp_qspi_write_cnt
                                                  
////                   };
//assign probe1={ 7'd0,
//adv_pal_init_mem_wr_req,       
//adv_pal_init_mem_rd_req,   
//adv_ntsc_init_mem_wr_req,       
//adv_ntsc_init_mem_rd_req,      
////adv_init_mem_wr_addr,      
////adv_init_mem_wr_addr_temp, 
////adv_init_mem_wr_data,      
//adv_pal_init_mem_rd_data,      
//adv_pal_init_mem_rd_addr,   
////adv_ntsc_init_mem_rd_data,      
//adv_ntsc_init_mem_rd_addr,    
//adv_init_mem_rd_addr_temp,               
////ADV_REG_CNT,               
//ADV_REG_WR_CNT, 
//pal_ntsc_sel,           
//pal_ntsc_sel_d,            
//pal_ntsc_sel_pos_edge,     
//pal_ntsc_sel_neg_edge,     
//adv_init_done,
//st_adv_init,             
//av_i2c_address,
//av_i2c_read,
////av_i2c_readdata,
//av_i2c_readdatavalid,
//av_i2c_write,
//av_i2c_writedata,
//av_i2c_waitrequest,
//av_i2c_data_16_en
//};

// ila_0 regs_master_ila (
//  .clk(clk), // input wire clk
//  .probe0(probe1) // input wire [127:0] probe0
// );

wire [127:0] probe1;

//assign probe1 =  {8'd00,
//                  sensor_init_mem_rd_addr_temp,
//                  av_sensor_i2c_writedata,
//                  av_sensor_i2c_address,
//                  av_sensor_i2c_write,
//                  av_sensor_write,
////                  av_sensor_address,
//                  av_sensor_i2c_read,
////                  av_sensor_readdatavalid,
////                  av_sensor_readdata,
////                  av_sensor_writedata,
////                  av_sensor_waitrequest,
//                  SENSOR_st,
//                  sensor_init_data_len,
//                  sensor_init_mem_rd_addr,
                  
//                  sensor_init_mem_rd_data,
//                  sensor_init_mem_rd_req,   
//                  update_sensor_param,
//                  init_done
//                  } ;

assign probe1 =  {tick_1ms,
                  uart_data_timeout_error,
                  st,
                  recv_cnt,
                  header,
                  crc_error,
                  footer_error,
                  cmd_error,
                  devid_error,
                  devno_error,
                  packt_seq1,
                  packt_seq2,
                  dev_id,
                  dev_no,
                  data_length,
                  cmd_type,
                  cmd,
                  crc,
                  av_uart_waitrequest,
                  av_uart_readdatavalid,
                  av_uart_read,
                  read_done,
                  datavalid,
                  trigger_edge,
                  send_cnt
                  
                  
                  } ;
                                
                    
    
 TOII_TUVE_ila regs_master_ila (
  .clk(clk), // input wire clk
  .probe0(probe1) // input wire [127:0] probe0
 );
          
          
       
          
          
          



//reg [(42*8)-1:0]temp_data;

 

Qspi_Rd_Wr_Controller_Module i_Qspi_Rd_Wr_Controller_Module(
    .clk(clk), //input             
    .reset(rst), // input   
    .clk_27mhz(clk_27mhz), //input             
    .reset_27mhz(rst_27mhz), // input 
//    .wait_done(wait_done),
//    .restart_en(restart_en),  
//    .reset_en  (reset_en),
    //.Start_QSPI_Module(1'b1), // input  
    .STARTUPE2_clk_stop(STARTUPE2_clk_stop),// input
    .qspi_init_done(qspi_init_done), ///output reg   
    .trigger(qspi_trigger), //input       
    .busy(qspi_busy), //output       
    .cmd(qspi_cmd),    //input      [7:0]  
    .input_valid(qspi_input_valid), //input            
    .address(qspi_address),  //input      [31:0] 
    .data_in(qspi_data_in),  //input      [7:0]  
    .input_data_valid(qspi_input_data_valid), // Only for Page Write give data_valid input             
    .rd_size(qspi_rd_size),    //input      [8:0]  
    .read_data_out(qspi_read_data_out),  //output reg [7:0]  
    .read_data_out_valid(qspi_read_data_out_valid), //output reg        
    .wr_enable_error(qspi_wr_enable_error),   //output reg       
    .wr_vecr_error(qspi_wr_vecr_error), //output reg        
    .wr_disable_error(qspi_wr_disable_error), //output reg        
    .FPGA_SPI_DQ0(FPGA_SPI_DQ0), ///inout 
    .FPGA_SPI_DQ1(FPGA_SPI_DQ1), //inout 
    .FPGA_SPI_DQ2(FPGA_SPI_DQ2), // inout 
    .FPGA_SPI_DQ3(FPGA_SPI_DQ3), //inout 
    .FPGA_SPI_CS(FPGA_SPI_CS)   //inout
               
    );




always @(posedge clk or posedge rst) begin
        if(rst) begin
            qspi_trigger         <= 0;
            qspi_state           <= qspi_idle_st;
            qspi_state_temp      <= qspi_idle_st;
            qspi_read_data       <= 0;
            qspi_read_data_valid <= 1'b0;
            qspi_address         <= 0;
            qspi_input_valid     <= 0;
            qspi_cmd             <= 0;
            qspi_data_in         <= 0;
            qspi_rd_size         <= 0;
            qspi_wr_data_cnt     <= 0;
            read_sdram_data_rq   <= 0;
            qspi_rx_rd_fifo_clr  <= 1'b1;
            qspi_rx_wr_wrreq_sig <= 1'b0;
            qspi_reg_wr_cmd      <= 0;
            qspi_reg_wr_data     <= 0;
            qspi_sector_erase_addr <= 0;
            qspi_write_addr      <= 0;
            qspi_read_addr       <= 0;
            qspi_mem_rd_cmd      <= 0;
            qspi_reg_wr_cmd      <= 0;
            qspi_reg_wr_data     <= 0;        
            qspi_sector_erase_cmd <= 0;
            //temp_data             <= 336'h88776655_44332211_DDCCBBAA_EEDD_00010100_00C00000_03ff0000_E000_00010100_00D00000_03ff0000_E000;   
            //qspi_page_wr_rq <= 0; 
            //qspi_sector_erase_rq <= 0;  
            qspi_send_busy       <= 1'b1;
            STARTUPE2_clk_stop   <= 1'b0;    
            qspi_rx_wr_data_word <= 0;
            qspi_input_data_valid <= 0;
        end else begin        
            case(qspi_state)
                qspi_idle_st: begin
                  if(qspi_init_done)begin
                    if(!qspi_busy)begin
                        qspi_state          <= qspi_wait_st;
                        qspi_state_temp     <= qspi_wait_st;
                        STARTUPE2_clk_stop  <= 1'b1;
                        //qspi_sector_erase_rq <= 1'b1;
                    end    
                    qspi_address        <= 0;
                    qspi_input_valid    <= 0;
                    qspi_cmd            <= 0;
                    qspi_data_in        <= 0;
                    qspi_rd_size        <= 0;
                    qspi_rx_rd_fifo_clr <= 1'b0;  
                  end 
                end 
                
                qspi_wait_st: begin
                    if(qspi_sector_erase_rq)begin
                        if(!qspi_busy)begin
                            qspi_state             <= qspi_wren_st;
                            qspi_state_temp        <= qspi_sector_erase_st;
                            qspi_sector_erase_addr <= qspi_send_addr;//32'h04000000;
                            qspi_sector_erase_cmd  <= qspi_send_sector_erase_cmd;//`CMD_SE_64KB;
                            //qspi_sector_erase_rq   <= 1'b0;
                            qspi_send_busy         <= 1'b1;
                            STARTUPE2_clk_stop     <= 1'b0;
                        end
                    end 
                    else if(qspi_reg_wr_rq)begin
                        if(!qspi_busy)begin
                            qspi_state             <= qspi_wren_st;
                            qspi_state_temp        <= qspi_reg_wr_cmd_st;
                            qspi_reg_wr_cmd        <= `CMD_WRVECR;
                            qspi_reg_wr_data       <= 8'b011_11_111;
                            qspi_send_busy         <= 1'b1;
                            STARTUPE2_clk_stop     <= 1'b0;
                         end
                    end
                    else if(qspi_page_wr_rq)begin
                        if(!qspi_busy)begin
                            qspi_state          <= qspi_wren_st;
                            qspi_state_temp     <= qspi_page_wr_cmd_st;
                            qspi_write_addr     <= qspi_send_addr;//32'h04000000;
                            //qspi_page_wr_rq     <= 1'b0;
                            qspi_send_busy      <= 1'b1;
                            STARTUPE2_clk_stop  <= 1'b0;
                        end
                    end
                    else if(qspi_mem_rd_rq)begin
                        if(!qspi_busy)begin
                            qspi_state          <= qspi_mem_rd_cmd_st;
                            qspi_state_temp     <= qspi_wait_st;
                            qspi_read_addr      <= qspi_send_addr;
                            qspi_rd_size        <= qspi_send_rd_size;
                            qspi_mem_rd_cmd     <= qspi_send_cmd;
                            qspi_rx_rd_fifo_clr <= 1'b1;
                            qspi_send_busy      <= 1'b1;
                            STARTUPE2_clk_stop  <= 1'b0;
                        end                
                    end
                    else begin
                        if(qspi_trigger)begin
                            qspi_trigger <= 0;
                        end
                        else if(!qspi_busy)begin
                            qspi_input_valid    <= 0;
                            qspi_state          <= qspi_wait_st;
                            qspi_state_temp     <= qspi_wait_st;
                            qspi_send_busy      <= 1'b0;
                            STARTUPE2_clk_stop  <= 1'b1;
                       end     
                    end            
                end
                
                     
                qspi_wren_st: begin
                    if(qspi_trigger)begin
                        qspi_trigger <= 0;
                    end    
                    else if(!qspi_busy) begin
                        qspi_cmd         <= `CMD_WREN;//`CMD_MIORDID;//`CMD_RDVECR;//`CMD_RDID;//`CMD_MIORDID;//`CMD_READ;
                        qspi_address     <= 0;
                        qspi_input_valid <= 1;
                        qspi_data_in     <= 0;
                        qspi_rd_size     <= 0;
                        qspi_trigger     <= 1;      
                        qspi_state       <= qspi_rdsr_cmd_st; 
                        //qspi_state_temp  <= qspi_rdsr_data;   
                    end  
                end 
               qspi_rdsr_cmd_st: begin
                   if(qspi_trigger)begin
                       qspi_trigger <= 0;
                   end
                   else if(!qspi_busy) begin
                       qspi_cmd         <= `CMD_RDSR;//`CMD_MIORDID;//`CMD_RDVECR;//`CMD_RDID;//`CMD_MIORDID;//`CMD_READ;
                       qspi_address     <= 0;
                       qspi_input_valid <= 1;
                       qspi_data_in     <= 0;
                       qspi_rd_size     <= 1;
                       qspi_trigger     <= 1;      
                       qspi_state       <= qspi_rdsr_data_st;    
                   end  
                end
                
                qspi_rdsr_data_st:begin
                    if (qspi_trigger)begin
                        qspi_trigger <= 0;
                    end    
                    else if(qspi_busy) begin
                       qspi_input_valid     <= 0;
                       if(qspi_read_data_out_valid)begin
                         qspi_read_data <= qspi_read_data_out[7:0];
                         qspi_read_data_valid <= 1'b1;
                         if(qspi_read_data_out[1]==1'b1)begin
                             qspi_state       <= qspi_state_temp;
                             qspi_wr_en_error <= 1'b0;               
                         end
                         else begin
                             qspi_wr_en_error <= 1'b1;
                             qspi_state       <= qspi_error_st;
                             qspi_state_temp  <= qspi_error_st;
                         end    
                       end  
                     end
                 end
                
               qspi_sector_erase_st: begin
                    if(qspi_trigger)begin
                        qspi_trigger <= 0;
                    end    
                    else if(!qspi_busy) begin
                        qspi_cmd         <= qspi_sector_erase_cmd ; //`CMD_WRVECR;//`CMD_MIORDID;//`CMD_RDVECR;//`CMD_RDID;//`CMD_MIORDID;//`CMD_READ;
                        qspi_address     <= qspi_sector_erase_addr;//32'h03000000;
                        qspi_input_valid <= 1;
                        qspi_data_in     <= 0;
                        qspi_rd_size     <= 0;
                        qspi_trigger     <= 1;      
                        qspi_state       <= qspi_wait_st; 
                        qspi_state_temp  <= qspi_wait_st; 
                        //qspi_page_wr_rq  <= 1'b1; 
                    end  
                end 
                qspi_reg_wr_cmd_st: begin
                    if(qspi_trigger)begin
                        qspi_trigger <= 0;
                    end    
                    else if(!qspi_busy) begin
                        qspi_cmd         <= qspi_reg_wr_cmd; //`CMD_WRVECR;//`CMD_MIORDID;//`CMD_RDVECR;//`CMD_RDID;//`CMD_MIORDID;//`CMD_READ;
                        qspi_address     <= 0;
                        qspi_input_valid <= 1;
                        qspi_data_in     <= qspi_reg_wr_data;
                        qspi_rd_size     <= 0;
                        qspi_trigger     <= 1;      
                        qspi_state       <= qspi_wait_st; 
                        qspi_state_temp  <= qspi_wait_st;
                    end  
                end                     
                  
                qspi_page_wr_cmd_st: begin
                     if(qspi_trigger)begin
                         qspi_trigger <= 0;
                     end
                     else if(!qspi_busy) begin
                             qspi_cmd         <= `CMD_PP;//`CMD_MIORDID;//`CMD_RDVECR;//`CMD_RDID;//`CMD_READ;
                             qspi_address     <= qspi_write_addr;//32'h03000000;
                             qspi_input_valid <= 1;
                             qspi_data_in     <= 0;
                             qspi_rd_size     <= 0;
                             qspi_trigger     <= 1;  
                             qspi_state       <= qspi_page_wr_data_st;
                             qspi_wr_data_cnt <= 0;      
                     end
                 end
                qspi_page_wr_data_st:begin
                    if(qspi_trigger)begin
                       qspi_trigger <= 0;
                    end 
                    else if(qspi_busy) begin
                        read_sdram_data_rq <= 1'b1;               
                        if(qspi_wr_data_cnt == qspi_block_wr_size)begin
                            qspi_input_data_valid <= 0;
                            qspi_data_in          <= 0;
                        end 
                        else begin
                            qspi_state <= qspi_state;
                            if(qspi_wr_data_valid)begin       
                                 qspi_wr_data_cnt      <= qspi_wr_data_cnt + 1;
                                 qspi_input_data_valid <= 1;
                                 qspi_data_in          <= qspi_wr_data;
                            end
                            else begin
                                 qspi_wr_data_cnt      <= qspi_wr_data_cnt;
                                 qspi_input_data_valid <= 0;
                                 qspi_data_in          <= 0;   
                            end
                        end                 
                    
     /*                  read_sdram_data_rq <= 1'b1;
                       if(qspi_write_data_valid)begin
                           if(qspi_wr_data_cnt == 255)begin
                               qspi_state <= qspi_state + 1;
                           end 
                           else begin
                               qspi_state <= qspi_state;
                           end       
                           qspi_wr_data_cnt      <= qspi_wr_data_cnt + 1;
                           qspi_input_data_valid <= 1;
                           qspi_data_in          <= qspi_write_data;
                       end 
                       else begin
                               qspi_input_data_valid <= 0;
                               qspi_data_in          <= 0;             
                       end*/
    
    /*                    if(qspi_wr_data_cnt == qspi_block_wr_size)begin
                            qspi_state            <= qspi_wait_st;//qspi_mem_rd_cmd;
                            qspi_input_data_valid <= 0;
                            qspi_wr_data_cnt      <= 0;
                            qspi_data_in          <= 0;
                        end        
                        else begin 
                            qspi_wr_data_cnt      <= qspi_wr_data_cnt + 1;
                            qspi_input_data_valid <= 1;
                            qspi_data_in          <= temp_data[7:0] ;//qspi_wr_data_cnt[7:0];//temp_data;//qspi_wr_data_cnt ;
                            temp_data             <= {temp_data[7:0],temp_data[(42*8)-1 : 8]};
                            //temp_data             <= temp_data -1;
                        end     */  
                    end 
                    else begin
                        read_sdram_data_rq <= 1'b0;
                        if(qspi_wr_data_cnt == qspi_block_wr_size)begin
                            qspi_state         <= qspi_wait_st;
                            qspi_wr_data_cnt   <= 0;
                        end
                    end 
                       
                
                end 
                
                qspi_mem_rd_cmd_st: begin
                    if(qspi_trigger)begin
                        qspi_trigger          <= 0;
                        qspi_input_data_valid <= 0;
                        qspi_wr_data_cnt      <= 0;
                        qspi_data_in          <= 0;
                    end
                    else if(!qspi_busy) begin
                        //if(Start_QSPI_Module)begin
                            qspi_cmd         <= qspi_mem_rd_cmd;//`CMD_MIORDID;//`CMD_RDVECR;//`CMD_RDID;//`CMD_READ;
                            qspi_address     <= qspi_read_addr;//qspi_read_addr;//32'h03000000;
                            qspi_input_valid <= 1;
                            qspi_data_in     <= 0;
                            qspi_rd_size     <= qspi_rd_size;//256;//qspi_rd_size;//256;
                            qspi_trigger     <= 1;      
                            qspi_state       <= qspi_mem_rd_data_st; 
                            qspi_rx_rd_fifo_clr <= 1'b0;   
                        //end    
                    end
                end  
                
                qspi_mem_rd_data_st: begin  // Read Data
                        if (qspi_trigger)begin
                            qspi_trigger <= 0;
                        end    
                        else if(qspi_busy) begin
                            qspi_input_valid     <= 0;
                            qspi_read_data       <= qspi_read_data_out;
                            qspi_read_data_valid <= qspi_read_data_out_valid;  
                            qspi_rx_wr_wrreq_sig <= qspi_read_data_out_valid;
                            if(qspi_read_data_out_valid)begin
                                qspi_rx_wr_data_word <= qspi_read_data_out;
                            end                                
                        end
                        else begin
                            qspi_state           <= qspi_wait_st;
                            
                            qspi_read_data       <= 8'd0;
                            qspi_read_data_valid <= 1'b0;  
                            qspi_cmd             <= 0;
                            qspi_data_in         <= 0;
                            qspi_rd_size         <= 0;
                            qspi_rx_wr_wrreq_sig <= 1'b0; 
                            qspi_rx_wr_data_word <= 8'd0; 
                        end
                end 
                                   
//               qspi_rd_wr_done_st: begin
//                    qspi_trigger         <= 0;
//                    qspi_read_data       <= 8'd0;
//                    qspi_read_data_valid <= 1'b0;
//                    qspi_address         <= 0;
//                    qspi_input_valid     <= 0;
//                    qspi_cmd             <= 0;
//                    qspi_data_in         <= 0;
//                    qspi_rd_size         <= 0;
//                    qspi_state           <= qspi_state;
//                    qspi_state_temp      <= qspi_state_temp;
//                end
                
                qspi_error_st: begin
                    qspi_trigger <= 0;
                    qspi_read_data  <= 8'd0;
                    qspi_read_data_valid <= 1'b0;
                    qspi_address     <= 0;
                    qspi_input_valid <= 0;
                    qspi_cmd         <= 0;
                    qspi_data_in     <= 0;
                    qspi_rd_size     <= 0;
                
                end
                
                
                default:
                    qspi_state <= qspi_state;
            endcase
        end
    end





 FIFO_GENERIC_SC #
    (
            .FIFO_DEPTH (8),            //    -- 2**FIFO_DEPTH = Number of Words in FIFO
            .FIFO_WIDTH (8),            //    -- FIFO Words Number of Bits
            .AEMPTY_LEVEL(0),
            .AFULL_LEVEL (20)
          )
          RX_RD_DATA_FIFO(
            .CLK        (clk),
            .RST        (rst),
            .CLR        (qspi_rx_rd_fifo_clr),
            .WRREQ      (qspi_rx_wr_wrreq_sig),
            .WRDATA     (qspi_rx_wr_data_word),
            .RDREQ      (qspi_rx_rd_fifo_rq),
            .RDDATA     (qspi_rx_rd_fifo_data),
            .EMPTY      (qspi_rx_rd_fifo_empty),
            .FULL       (qspi_rx_rd_fifo_full),
            .USEDW      (qspi_rx_rfbufffilled),
            .AFULL      (qspi_rx_rd_fifo_almostfull),
            .AEMPTY     ()
          );  


assign user_settings_mem_wr_addr_mux    = user_settings_mux_sel ? user_settings_mem_wr_addr :  user_settings_mem_wr_addr1 ;
assign user_settings_mem_wr_req_mux     = user_settings_mux_sel ? user_settings_mem_wr_req  :  user_settings_mem_wr_req1  ;
assign user_settings_mem_wr_data_mux    = user_settings_mux_sel ? user_settings_mem_wr_data :  user_settings_mem_wr_data1;
assign user_settings_mem_rd_addr_mux    = user_settings_mux_sel ? user_settings_mem_rd_addr :  user_settings_mem_rd_addr1 ;
assign user_settings_mem_rd_req_mux     = user_settings_mux_sel ? user_settings_mem_rd_req  :  user_settings_mem_rd_req1  ;
assign user_settings_mem_rd_data1       = user_settings_mux_sel ? 32'd0: user_settings_mem_rd_data_mux;
assign user_settings_mem_rd_data        = user_settings_mux_sel ? user_settings_mem_rd_data_mux  : 32'd0 ;


//DPRAM_GENERIC_DC1 #(.ADDR_WIDTH (8),                                                         
//                    .DATA_WIDTH (32))                                                        
//USER_SETTINGS_MEMORY(                                                                          
//     .A_CLK(clk),                                                                            
//     .A_ADDR(user_settings_mem_wr_addr_mux),//input  [7:0]                                     
//     .A_WRREQ(user_settings_mem_wr_req_mux),                                                   
//     .A_WRDATA(user_settings_mem_wr_data_mux),  //input  [31:0]                                
//     .A_RDREQ(),  //input                                                                 
//     .A_RDDATA(), //output [31:0]                                                            
//     .B_CLK(clk), //input                                                                    
//     .B_ADDR(user_settings_mem_rd_addr_mux), //input  [7:0]                                    
//     .B_WRREQ(), //input                                                                     
//     .B_WRDATA(), //input  [31:0]                                                            
//     .B_RDREQ(user_settings_mem_rd_req_mux), //input                                           
//     .B_RDDATA(user_settings_mem_rd_data_mux) //output [31:0]                                  
//     );  

   xpm_memory_sdpram #(
      .ADDR_WIDTH_A(8),               // DECIMAL
      .ADDR_WIDTH_B(8),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(32),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(8192),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(32),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(32),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   USER_SETTINGS_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(user_settings_mem_rd_data_mux),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(user_settings_mem_wr_addr_mux),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(user_settings_mem_rd_addr_mux),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(user_settings_mem_wr_data_mux),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(user_settings_mem_wr_req_mux),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(user_settings_mem_rd_req_mux),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(user_settings_mem_wr_req_mux)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.

   );


  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(6),               // DECIMAL
      .ADDR_WIDTH_B(6),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(32),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2048),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(32),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(32),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   ADV_PAL_INIT_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(adv_pal_init_mem_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(adv_pal_init_mem_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(adv_pal_init_mem_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(adv_pal_init_mem_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(adv_pal_init_mem_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(adv_pal_init_mem_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(adv_pal_init_mem_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.

   );


  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(6),               // DECIMAL
      .ADDR_WIDTH_B(6),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(32),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2048),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(32),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(32),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   ADV_NTSC_INIT_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(adv_ntsc_init_mem_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(adv_ntsc_init_mem_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(adv_ntsc_init_mem_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(adv_ntsc_init_mem_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(adv_ntsc_init_mem_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(adv_ntsc_init_mem_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(adv_ntsc_init_mem_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.

   );








  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(6),               // DECIMAL
      .ADDR_WIDTH_B(6),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(32),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2048),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(32),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(32),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_INIT_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_init_mem_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_init_mem_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_init_mem_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_init_mem_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_init_mem_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_init_mem_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_init_mem_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.

   );



  div#(
  .W    (18),
  .CBIT (5)
  )
 i_gamma_div(

  .clk  (clk),
  .reset(rst),
  .start(start_div) ,
  .dvsr (dvsr), 
  .dvnd (dvnd),
  .done_tick(done_tick),
  .quo(quo), 
  .rmd ()
  );




  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(8),               // DECIMAL
      .ADDR_WIDTH_B(8),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(10),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2560),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(10),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(10),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_GAMMA_TABLE_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_gamma_table_mem_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_gamma_table_mem_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_gamma_table_mem_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_gamma_table_mem_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_gamma_table_mem_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_gamma_table_mem_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_gamma_table_mem_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.
   );







  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(7),               // DECIMAL
      .ADDR_WIDTH_B(7),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(16),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2048),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(16),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(16),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_GAMMA_COEFF_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_gamma_coeff_mem_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_gamma_coeff_mem_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_gamma_coeff_mem_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_gamma_coeff_mem_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_gamma_coeff_mem_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_gamma_coeff_mem_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_gamma_coeff_mem_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.
   );


 xpm_memory_sdpram #(
      .ADDR_WIDTH_A(7),               // DECIMAL
      .ADDR_WIDTH_B(7),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(16),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2048),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(16),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(16),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_CF_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_cf_mem_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_cf_mem_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_cf_mem_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_cf_mem_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_cf_mem_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_cf_mem_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_cf_mem_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.
   );



  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(10),               // DECIMAL
      .ADDR_WIDTH_B(10),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(20),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(20480),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(20),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(20),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_VGN_GAMMA_MEMORY1 (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_vgn_gamma_mem1_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_vgn_gamma_mem1_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_vgn_gamma_mem1_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_vgn_gamma_mem1_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_vgn_gamma_mem1_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_vgn_gamma_mem1_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_vgn_gamma_mem1_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.
   );


  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(10),               // DECIMAL
      .ADDR_WIDTH_B(10),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(20),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(20480),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(20),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(20),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_VGN_GAMMA_MEMORY2 (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_vgn_gamma_mem2_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_vgn_gamma_mem2_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_vgn_gamma_mem2_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_vgn_gamma_mem2_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_vgn_gamma_mem2_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_vgn_gamma_mem2_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_vgn_gamma_mem2_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.
   );


  xpm_memory_sdpram #(
      .ADDR_WIDTH_A(10),               // DECIMAL
      .ADDR_WIDTH_B(10),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(20),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(20480),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(20),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(20),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   OLED_VGN_GAMMA_MEMORY3 (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(oled_vgn_gamma_mem3_rd_data),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(oled_vgn_gamma_mem3_wr_addr),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(oled_vgn_gamma_mem3_rd_addr),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(oled_vgn_gamma_mem3_wr_data),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(oled_vgn_gamma_mem3_wr_req),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(oled_vgn_gamma_mem3_rd_req),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(oled_vgn_gamma_mem3_wr_req)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.
   );

 

div#(
  .W    (32),
  .CBIT (6)
  )
 i_vgn_div(

  .clk  (clk),
  .reset(rst),
  .start(vgn_start_div) ,
  .dvsr (vgn_dvsr), 
  .dvnd (vgn_dvnd),
  .done_tick(vgn_done_tick),
  .quo(vgn_quo), 
  .rmd ()
  );





always@(posedge clk or posedge rst)begin
    if (rst)begin
        sensor_init_mem_wr_addr <= 0;
        sensor_init_mem_wr_addr_temp <= 0;
        sensor_init_write_data_temp <= 0;
        sensor_init_mem_write_en <= 0;
        sensor_init_mem_wr_data  <= 0;
        sensor_init_mem_wr_req  <= 1'b0;
        sensor_init_mem_write_cnt <= 0;
//        sensor_init_rd_data_done <= 0;
    end
    else begin
        if(sensor_init_write_data_valid)begin
            sensor_init_write_data_temp <= {sensor_init_write_data ,sensor_init_write_data_temp [31:8]};
            //sensor_init_mem_write_en <= !sensor_init_mem_write_en;
            if(sensor_init_mem_write_cnt == 3)begin
                sensor_init_mem_wr_data <= {sensor_init_write_data ,sensor_init_write_data_temp [31:8]};
                sensor_init_mem_wr_req  <= 1'b1;
                sensor_init_mem_wr_addr <= sensor_init_mem_wr_addr_temp;
                sensor_init_mem_wr_addr_temp <= sensor_init_mem_wr_addr_temp + 1;
                sensor_init_mem_write_cnt <= 0;
            end
            else begin 
                sensor_init_mem_wr_addr_temp <= sensor_init_mem_wr_addr_temp ;
                sensor_init_mem_wr_addr      <= sensor_init_mem_wr_addr;
                sensor_init_mem_wr_req       <= 1'b0;
                sensor_init_mem_write_cnt    <= sensor_init_mem_write_cnt + 1;
            end     
        end
        else begin
            sensor_init_mem_wr_req  <= 1'b0;
        end 
    end
end


assign sensor_init_mem_wr_addr_mux    = update_sensor_init ? sensor_init_mem_wr_addr1 : sensor_init_mem_wr_addr ;
assign sensor_init_mem_wr_req_mux     = update_sensor_init ? sensor_init_mem_wr_req1  : sensor_init_mem_wr_req  ;
assign sensor_init_mem_wr_data_mux    = update_sensor_init ? sensor_init_mem_wr_data1 : sensor_init_mem_wr_data ;
assign sensor_init_mem_rd_addr_mux    = update_sensor_init ? sensor_init_mem_rd_addr1 : sensor_init_mem_rd_addr ;
assign sensor_init_mem_rd_req_mux     = update_sensor_init ? sensor_init_mem_rd_req1  : sensor_init_mem_rd_req  ;
assign sensor_init_mem_rd_data1       = update_sensor_init ? sensor_init_mem_rd_data_mux  : 32'd0 ;
assign sensor_init_mem_rd_data        = update_sensor_init ? 32'd0: sensor_init_mem_rd_data_mux;

//DPRAM_GENERIC_DC1 #(.ADDR_WIDTH (6),  
//                    .DATA_WIDTH (32))
//SENSOR_INIT_MEMORY(
//     .A_CLK(clk),
//     .A_ADDR(sensor_init_mem_wr_addr_mux),//input  [5:0]
//     .A_WRREQ(sensor_init_mem_wr_req_mux), 
//     .A_WRDATA(sensor_init_mem_wr_data_mux),  //input  [31:0]
//     .A_RDREQ(),    // input        
//     .A_RDDATA(), //output [31:0]
//     .B_CLK(clk), //input         
//     .B_ADDR(sensor_init_mem_rd_addr_mux), //input  [5:0]  
//     .B_WRREQ(), //input       
//     .B_WRDATA(), //input  [31:0] 
//     .B_RDREQ(sensor_init_mem_rd_req_mux), //input        
//     .B_RDDATA(sensor_init_mem_rd_data_mux) //output [31:0]
//     );

   xpm_memory_sdpram #(
      .ADDR_WIDTH_A(6),               // DECIMAL
      .ADDR_WIDTH_B(6),               // DECIMAL
      .AUTO_SLEEP_TIME(0),            // DECIMAL
      .BYTE_WRITE_WIDTH_A(32),        // DECIMAL
      .CLOCKING_MODE("common_clock"), // String
      .ECC_MODE("no_ecc"),            // String
      .MEMORY_INIT_FILE("none"),      // String
      .MEMORY_INIT_PARAM("0"),        // String
      .MEMORY_OPTIMIZATION("true"),   // String
      .MEMORY_PRIMITIVE("auto"),      // String
      .MEMORY_SIZE(2048),             // DECIMAL
      .MESSAGE_CONTROL(0),            // DECIMAL
      .READ_DATA_WIDTH_B(32),         // DECIMAL
      .READ_LATENCY_B(1),             // DECIMAL
      .READ_RESET_VALUE_B("0"),       // String
      .RST_MODE_A("SYNC"),            // String
      .RST_MODE_B("SYNC"),            // String
      .USE_EMBEDDED_CONSTRAINT(0),    // DECIMAL
      .USE_MEM_INIT(1),               // DECIMAL
      .WAKEUP_TIME("disable_sleep"),  // String
      .WRITE_DATA_WIDTH_A(32),        // DECIMAL
      .WRITE_MODE_B("no_change")      // String
   )
   SENSOR_INIT_MEMORY (
      .dbiterrb(),             // 1-bit output: Status signal to indicate double bit error occurrence
                                       // on the data output of port B.

      .doutb(sensor_init_mem_rd_data_mux),                   // READ_DATA_WIDTH_B-bit output: Data output for port B read operations.
      .sbiterrb(),             // 1-bit output: Status signal to indicate single bit error occurrence
                                       // on the data output of port B.

      .addra(sensor_init_mem_wr_addr_mux),                   // ADDR_WIDTH_A-bit input: Address for port A write operations.
      .addrb(sensor_init_mem_rd_addr_mux),                   // ADDR_WIDTH_B-bit input: Address for port B read operations.
      .clka(clk),                     // 1-bit input: Clock signal for port A. Also clocks port B when
                                       // parameter CLOCKING_MODE is "common_clock".

      .clkb(clk),                     // 1-bit input: Clock signal for port B when parameter CLOCKING_MODE is
                                       // "independent_clock". Unused when parameter CLOCKING_MODE is
                                       // "common_clock".

      .dina(sensor_init_mem_wr_data_mux),                     // WRITE_DATA_WIDTH_A-bit input: Data input for port A write operations.
      .ena(sensor_init_mem_wr_req_mux),                       // 1-bit input: Memory enable signal for port A. Must be high on clock
                                       // cycles when write operations are initiated. Pipelined internally.

      .enb(sensor_init_mem_rd_req_mux),                       // 1-bit input: Memory enable signal for port B. Must be high on clock
                                       // cycles when read operations are initiated. Pipelined internally.

      .injectdbiterra(1'b0), // 1-bit input: Controls double bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .injectsbiterra(1'b0), // 1-bit input: Controls single bit error injection on input data when
                                       // ECC enabled (Error injection capability is not available in
                                       // "decode_only" mode).

      .regceb(1'b0),                 // 1-bit input: Clock Enable for the last register stage on the output
                                       // data path.

      .rstb(rst),                     // 1-bit input: Reset signal for the final port B output register stage.
                                       // Synchronously resets output port doutb to the value specified by
                                       // parameter READ_RESET_VALUE_B.

      .sleep(1'b0),                   // 1-bit input: sleep signal to enable the dynamic power saving feature.
      .wea(sensor_init_mem_wr_req_mux)                        // WRITE_DATA_WIDTH_A-bit input: Write enable vector for port A input
                                       // data port dina. 1 bit wide when word-wide writes are used. In
                                       // byte-wide write configurations, each bit controls the writing one
                                       // byte of dina to address addra. For example, to synchronously write
                                       // only bits [15-8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be
                                       // 4'b0010.

   );

//assign SPI_WriteData = (init_done)? av_spi_writedata : sensor_spi_writedata;
//assign SPI_ADDRESS   = (init_done)? av_spi_address   : sensor_spi_address;
//assign SPI_WriteEN   = (init_done)? av_spi_write     : sensor_spi_write;

//assign av_spi_waitrequest     = (init_done)? SPI_WaitReq :1'b0;
//assign sensor_spi_waitrequest = (init_done)? 1'b0: SPI_WaitReq;


assign SENSOR_I2C_SLAVE_ADDRESS_m = (init_done)? av_sensor_i2c_address[24-1:16]:SENSOR_I2C_SLAVE_ADDRESS;
assign SENSOR_I2C_REG_ADDRESS_m = (init_done)? av_sensor_i2c_address[16-1:0]:SENSOR_I2C_REG_ADDRESS;
assign SENSOR_I2C_WriteEN_m = (init_done)? av_sensor_i2c_write:SENSOR_I2C_WriteEN;
assign SENSOR_I2C_ReadEN_m = (init_done)? av_sensor_i2c_read:SENSOR_I2C_ReadEN;
assign SENSOR_I2C_WriteData_m = (init_done)? av_sensor_i2c_writedata:SENSOR_I2C_WriteData;
assign av_sensor_i2c_readdata = SENSOR_I2C_ReadData_m;
assign SENSOR_I2C_ReadData = SENSOR_I2C_ReadData_m;
assign av_sensor_i2c_readdatavalid = (init_done)? SENSOR_I2C_ReadDAV_m:1'b0;
assign SENSOR_I2C_ReadDAV = (init_done)? 1'b0: SENSOR_I2C_ReadDAV_m;
assign av_sensor_i2c_waitrequest = (init_done)? SENSOR_I2C_Busy_m:1'b0;
assign SENSOR_I2C_Busy = (init_done)? 1'b0: SENSOR_I2C_Busy_m;

 
/////////////////////////  Sensor SPI Init /////////////////////////////////////////////////////////



always@(posedge clk or posedge rst)begin
    if(rst)begin
            SENSOR_st                 <= SENSOR_idle;
            SENSOR_st_temp            <= SENSOR_idle;
            init_done                 <= 1'b0;
            sensor_init_mem_rd_addr   <= 0;
            sensor_init_mem_rd_addr_temp <= 0;
            sensor_init_mem_rd_req   <= 0;
            DELAY_CNT <= 0;
//            video_start          <= 1'b0;
//            av_sensor_writedata1 <= 0;
//            av_sensor_address1   <= 0;
//            av_sensor_write1     <= 0;  
            SNSR_FPGA_NRST_SPI_CS     <= 1'b0;
			SENSOR_I2C_REG_ADDRESS    <= 16'h00;
			SENSOR_I2C_WriteData      <= 8'h00;
			SENSOR_I2C_WriteEN        <= 1'b0;
			SENSOR_I2C_ReadEN         <= 1'b0;
			SENSOR_I2C_SLAVE_ADDRESS  <= SENSOR_I2C_PHYS_ADDR;            
            update_sensor_param_latch <= 1'b0;  
            sensor_power_on_init_done <= 1'b0;       
    end
    else begin
        case(SENSOR_st) 
            
            SENSOR_idle :begin
                init_done  <= 1'b0;
                SNSR_FPGA_NRST_SPI_CS     <= 1'b1;
                if (DELAY_CNT == 0) begin
                  DELAY_CNT      <= DELAY_CNT;
                  if(sensor_init_rd_done)begin
//                    SNSR_FPGA_NRST_SPI_CS     <= 1'b1;
                    SENSOR_st      <= SENSOR_st_wait;//SENSOR_st0;
                    SENSOR_st_temp <= SENSOR_st_wait; 
                  end
                  else begin
                    SENSOR_st      <= SENSOR_idle;
                    SENSOR_st_temp <= SENSOR_idle;
                  end                                  
//                  if(qspi_init_cmd_done)begin
//                    SENSOR_st      <= SENSOR_st_wait;//SENSOR_st0;
//                    SENSOR_st_temp <= SENSOR_st_wait; 
//                  end
//                  else begin
//                    SENSOR_st      <= SENSOR_idle;
//                    SENSOR_st_temp <= SENSOR_idle;
//                  end
                end  
                else if (tick_1ms == 1'b1)begin
                  DELAY_CNT <= DELAY_CNT + 1;  
                end 
                  //sensor_trigger <= 1'b1;
            end

            SENSOR_st_wait :begin
               //if((sensor_init_mem_wr_addr - 2) == sensor_init_mem_rd_addr)begin
//               if(((sensor_init_data_len-1) - 8) == sensor_init_mem_rd_addr)begin
//               if(((sensor_init_data_len-1) - 12) == sensor_init_mem_rd_addr)begin // For area0 = 24 area1= 20 area2 = 16,area 3 =12, area4 =8 ,area5=4, area6 =0
               if(((sensor_init_data_len-1) - 6) == sensor_init_mem_rd_addr)begin // For area0 = 24 area1= 20 area2 = 16,area 3 =12, area4 =8 ,area5=4, area6 =0
                   SENSOR_st      <= SENSOR_st_end;
                   SENSOR_st_temp <= SENSOR_st_update;
               end
               else begin
                   SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                   SENSOR_st_temp               <= SENSOR_st_temp; 
                   sensor_init_mem_rd_addr      <= sensor_init_mem_rd_addr_temp;
                   sensor_init_mem_rd_req       <= 1'b1;
               end
            end    
            SENSOR_st_mem_rd_wait : begin
               SENSOR_st      <= SENSOR_st_wr;
               SENSOR_st_temp <= SENSOR_st_temp;    
               sensor_init_mem_rd_req       <= 1'b0;
               sensor_init_mem_rd_addr_temp <= sensor_init_mem_rd_addr_temp + 1;    
            end
 
            SENSOR_st_wr: begin
//               av_sensor_writedata1 <= {16'd0,sensor_init_mem_rd_data[31:16]};
//               av_sensor_address1   <= {28'd0,sensor_init_mem_rd_data[3:0]};
////               sensor_spi_writedata <= {12'd0,sensor_init_mem_rd_data[7:0],sensor_init_mem_rd_data[27:16]};
////               sensor_init_mem_rd_data_d <= sensor_init_mem_rd_data;
////               sensor_spi_address   <= 4;
//               av_sensor_write1     <= 1'b1;
//               SENSOR_st        <= SENSOR_st_wr1;
               if(SENSOR_I2C_Busy)begin
                    SENSOR_st                <= SENSOR_st_wr1;  
                    SENSOR_I2C_WriteEN       <= 1'b0;
                    SENSOR_I2C_ReadEN        <= 1'b0;                
               end
               else begin
                   SENSOR_I2C_REG_ADDRESS   <= sensor_init_mem_rd_data[15:0]; 
                   SENSOR_I2C_WriteData     <= sensor_init_mem_rd_data[23:16];
                   SENSOR_I2C_WriteEN       <= 1'b1;
                   SENSOR_I2C_ReadEN        <= 1'b0;
                   SENSOR_st                <= SENSOR_st_wr;
               end
            end
            
           SENSOR_st_wr1: begin
//                if ((!av_sensor_waitrequest_r)) begin
//                    av_sensor_write1     <= 1'b0;
//                    SENSOR_st    <= SENSOR_st_temp;
//                end
                if(SENSOR_I2C_Busy==1'b0)begin
                    SENSOR_st                <= SENSOR_st_temp;   
                    SENSOR_I2C_WriteEN       <= 1'b0;
                    SENSOR_I2C_ReadEN        <= 1'b0;                
                end  
            end
            
            SENSOR_st_end :begin 
//                  init_done      <= 1'b1;
//                  av_sensor_write1   <= 1'b0;
//                  SENSOR_st      <= SENSOR_st_temp;  
//                  //video_start    <= 1'b1;
//                  //sensor_trigger <= 1'b0;
                  init_done      <= 1'b1;
                  SENSOR_I2C_WriteEN       <= 1'b0;
                  SENSOR_I2C_ReadEN        <= 1'b0;                   
//                  sensor_spi_write   <= 1'b0;
                  SENSOR_st      <= SENSOR_st_temp;  
//                  video_start    <= 1'b1;
                  //sensor_trigger <= 1'b0;                    
             end
             
             SENSOR_st_update: begin
                  sensor_power_on_init_done <= 1'b1;
                  if(update_sensor_param_latch)begin
                       SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                       SENSOR_st_temp               <= SENSOR_st_update1;
                       sensor_init_mem_rd_addr      <= new_sensor_param_start_addr;
                       sensor_init_mem_rd_req       <= 1'b1;
                       init_done                    <= 1'b0;
                       update_sensor_param_latch    <= 1'b0;
                  end
                  else begin
                       SENSOR_st                    <= SENSOR_st_update;
                       init_done                    <= 1'b1;
                  end
             end
              
             SENSOR_st_update1 :begin
                   SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                   SENSOR_st_temp               <= SENSOR_st_update2;
                   sensor_init_mem_rd_addr      <= new_sensor_param_start_addr +1;
                   sensor_init_mem_rd_req       <= 1'b1;
                   init_done                    <= 1'b0;        
             end
             SENSOR_st_update2 :begin
                   SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                   SENSOR_st_temp               <= SENSOR_st_update3;
                   sensor_init_mem_rd_addr      <= new_sensor_param_start_addr +2;
                   sensor_init_mem_rd_req       <= 1'b1;
                   init_done                    <= 1'b0;        
             end
             SENSOR_st_update3 :begin
                   SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                   SENSOR_st_temp               <= SENSOR_st_update4;
                   sensor_init_mem_rd_addr      <= new_sensor_param_start_addr +3;
                   sensor_init_mem_rd_req       <= 1'b1;
                   init_done                    <= 1'b0;        
             end
             SENSOR_st_update4 :begin
                   SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                   SENSOR_st_temp               <= SENSOR_st_update5;
                   sensor_init_mem_rd_addr      <= new_sensor_param_start_addr +4;
                   sensor_init_mem_rd_req       <= 1'b1;
                   init_done                    <= 1'b0;        
             end
             SENSOR_st_update5 :begin
                   SENSOR_st                    <= SENSOR_st_mem_rd_wait;
                   SENSOR_st_temp               <= SENSOR_st_update;
                   sensor_init_mem_rd_addr      <= new_sensor_param_start_addr +5;
                   sensor_init_mem_rd_req       <= 1'b1;
                   init_done                    <= 1'b0;        
             end

             
//             SENSOR_st_update2 :begin
//                  SENSOR_st                    <= SENSOR_st_mem_rd_wait;
//                  SENSOR_st_temp               <= SENSOR_st_update;
//                  sensor_init_mem_rd_addr      <= new_gfid_gsk_start_addr +1;
//                  sensor_init_mem_rd_req       <= 1'b1;
//                  init_done                    <= 1'b0;
            
//              end               
              default :begin
                   SENSOR_st <= SENSOR_idle;
              end
        endcase 
        
        if(update_sensor_param)begin
            update_sensor_param_latch <= 1'b1;
        end
        
       end
end

SENSOR_I2C_MASTER
 #(
    .input_clk(SYS_FREQ),// : INTEGER := 110_000_000; --input clock speed from user logic in Hz
    .bus_clk(I2C_FREQ) //  : INTEGER := 100_000);   --speed the i2c bus (scl) will run at in Hz
    )
u_SENSOR_I2C_MASTER(
    .clk(clk),//       : IN     STD_LOGIC;                    --system clock
    .reset_n(rst),//   : IN     STD_LOGIC;                    --active low reset
    .ena(1'b1),//       : IN     STD_LOGIC;                  --latch in command
    .addr(SENSOR_I2C_SLAVE_ADDRESS_m),//      : IN     STD_LOGIC_VECTOR(6 DOWNTO 0); --address of target slave
	.reg_addr(SENSOR_I2C_REG_ADDRESS_m),//  : IN     STD_LOGIC_VECTOR(7 DOWNTO 0); --address of target register in slave
    .read_en(SENSOR_I2C_ReadEN_m),//   : IN     STD_LOGIC;                    --'1' is read
	.write_en(SENSOR_I2C_WriteEN_m),//  : IN     STD_LOGIC;                    --'1' is write
    .data_wr(SENSOR_I2C_WriteData_m),//   : IN     STD_LOGIC_VECTOR(15 DOWNTO 0); --data to write to slave
    .busy(SENSOR_I2C_Busy_m),//      : OUT    STD_LOGIC:='0';                    --indicates transaction in progress
    .data_rd(SENSOR_I2C_ReadData_m),//   : OUT    STD_LOGIC_VECTOR(15 DOWNTO 0); --data read from slave
	.read_valid(SENSOR_I2C_ReadDAV_m),//: OUT    STD_LOGIC;
    .ack_error(SENSOR_ack_error),// : BUFFER STD_LOGIC:='0';                    --flag if improper acknowledge from slave
    .sda(SNSR_FPGA_I2C2_SDA_SPI_SDO),//       : INOUT  STD_LOGIC;                    --serial data output of i2c bus
    .scl(SNSR_FPGA_I2C2_SCL_SPI_SCK),//       : INOUT  STD_LOGIC;
    .reg_16_bit_en(1'b1), // 16 bit reg address
    .state_o(SENSOR_state_o)
    );

(* mark_debug = "true" *)wire [31:0] sdram_fifo_din = {doB_db[8-1:0],doB_db[16-1:8],doB_db[24-1:16],doB_db[32-1:24]};

(* mark_debug = "true" *)wire sdram_fifo_wr_en = fifo_wr_en[1];


// assign sdram_fifo_rd_en = (cmd==SET_SDRAM_DATA)?(!sdram_fifo_empty && !av_wrsdram_waitrequest):1'b0;

always @(*) begin : proc_sdram_fifo_rd_en
    sdram_fifo_rd_en = 1'b0;
    if(cmd==SET_SDRAM_DATA) begin 
        if(!sdram_fifo_empty && !av_wrsdram_waitrequest) begin 
            if(st==r_take_action3 && burst_count>1) begin 
               sdram_fifo_rd_en = 1'b1; 
            end 
            else if(st==r_take_action2) begin 
                sdram_fifo_rd_en = 1'b1; 
            end   
            else begin 
                sdram_fifo_rd_en = 1'b0;
            end
        end
        else begin 
            sdram_fifo_rd_en = 1'b0;
        end
    end
end



xpm_fifo_sync #(
  .DOUT_RESET_VALUE("0"),    // String
  .ECC_MODE("no_ecc"),       // String
  .FIFO_MEMORY_TYPE("auto"), // String
  .FIFO_READ_LATENCY(0),     // DECIMAL
  .FIFO_WRITE_DEPTH(32),   // DECIMAL
  .FULL_RESET_VALUE(0),      // DECIMAL
  .PROG_EMPTY_THRESH(10),    // DECIMAL
  .PROG_FULL_THRESH(26),     // DECIMAL
  .RD_DATA_COUNT_WIDTH(6),   // DECIMAL
  .READ_DATA_WIDTH(32),      // DECIMAL
  .READ_MODE("fwft"),         // String
  .USE_ADV_FEATURES("0707"), // String
  .WAKEUP_TIME(0),           // DECIMAL
  .WRITE_DATA_WIDTH(32),     // DECIMAL
  .WR_DATA_COUNT_WIDTH(6)    // DECIMAL
)
xpm_fifo_sync_inst (
  .almost_empty(),
  .almost_full(),
  .data_valid(),
  .dbiterr(),
  .dout(sdram_fifo_dout),
  .empty(sdram_fifo_empty),
  .full(sdram_fifo_full),
  .overflow(),
  .prog_empty(sdram_fifo_prog_empty),
  .prog_full(sdram_fifo_prog_full),
  .rd_data_count(sdram_fifo_rd_data_count),
  .rd_rst_busy(sdram_fifo_rd_rst_busy),
  .sbiterr(),
  .underflow(),
  .wr_ack(),
  .wr_data_count(sdram_fifo_wr_data_count),
  .wr_rst_busy(sdram_fifo_wr_rst_busy),
  .din(sdram_fifo_din),
  .injectdbiterr(1'b0),
  .injectsbiterr(1'b0),
  .rd_en(sdram_fifo_rd_en),
  .rst(rst),
  .sleep(1'b0),
  .wr_clk(clk),
  .wr_en(sdram_fifo_wr_en)
);



coarse_map_update_gpio #(
    .C_C(2),
    .C_F(2)
)
coarse_map_update_gpio_inst (
    .clk(clk),
    .rst(rst),

    .trigger_co(trigger_co),
    .busy_co(busy_co),
    .done_co(done_co),

    .tick_1ms(tick_1ms),

    .snap_done(snap_done_gpio),
    .snap_trigger(snap_trigger_gpio),
    .snap_mode(snap_mode_gpio),
    .snap_channel(snap_channel_gpio),
    .snap_image_numbers(snap_image_numbers_gpio),

    .av_fpga_address(av_fpga_address_gpio),
    .av_fpga_read(av_fpga_read_gpio),
    .av_fpga_readdata(av_fpga_readdata_gpio),
    .av_fpga_readdatavalid(av_fpga_readdatavalid_gpio),
    .av_fpga_write(av_fpga_write_gpio),
    .av_fpga_writedata(av_fpga_writedata_gpio),
    .av_fpga_waitrequest(av_fpga_waitrequest_gpio),


    .av_sensor_write(av_sensor_write_gpio),
    .av_sensor_writedata(av_sensor_writedata_gpio),
    .av_sensor_address(av_sensor_address_gpio)

    );

`ifdef  ILA_SDRAM

wire [127:0] probe0;
TOII_TUVE_ila ila_snap(
    .CLK(clk),
    .PROBE0(probe0)
);

//assign probe0 = {15'd0, sdram_fifo_rd_en, sdram_fifo_wr_en, sdram_fifo_empty, sdram_fifo_full, sdram_fifo_din, sdram_fifo_dout, //68
//                     av_wrsdram_writedata, av_wrsdram_write, av_wrsdram_waitrequest, addrB_db, fifo_wr_en, sdram_fifo_rst_busy}; //5+32+7+1 =45
assign probe0 = {6'd0, 
                 av_i2c_address, 
                 oled_reinit_en,
                 oled_reinit_vgn_rd_en,
                 oled_reinit_start,
                 st_oled_reinit,
                 oled_reint_wait_cnt,
//                 OLED_REG_WR_CNT,
                 OLED_REG_CNT,
                 oled_init_mem_rd_addr,
//                 oled_init_mem_rd_addr_temp,
                 oled_init_mem_rd_req,
                 oled_init_mem_rd_data,
                 oled_init_mem_wr_addr,
//                 oled_init_mem_wr_addr_temp,
//                 oled_init_mem_wr_req,
//                 oled_init_mem_wr_data,                 
                 av_i2c_writedata,
                 av_i2c_waitrequest,
                 av_i2c_write}; //5+32+7+1 =45


`endif
      

endmodule