-- File: row_filter_new.vhd
-- Generated by MyHDL 1.0dev
-- Date: Sat Mar 24 14:09:54 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;
Library xpm;
use xpm.vcomponents.all;

entity row_filter_new is
    generic (
        WINDOW : positive:=11;
        HALFWINDOW: positive:=5;
        BITWIDTH : positive:= 14;
        VIDEO_XSIZE: positive:=640;
        VIDEO_YSIZE:positive:=480;
        PIX_BITS : positive:=10;
        LIN_BITS : positive:=9;
        NUM_DIV: positive := 16
        );
    port (
        clk: in std_logic;
        rst: in std_logic;
        clk_100 : in std_logic;
        enable: in std_logic;
        threshold_mult: in std_logic_vector(7 downto 0);
        video_i_v: in std_logic;
        video_i_h: in std_logic;
        video_i_dav: in std_logic;
        video_i_data: in std_logic_vector(BITWIDTH-1 downto 0);
        video_i_eoi: in std_logic;
        video_i_bad: in std_logic;
        video_o_v: out std_logic;
        video_o_h: out std_logic;
        video_o_dav: out std_logic;
        video_o_data: out std_logic_vector(BITWIDTH-1 downto 0);
        video_o_bad: out std_logic;
        video_o_eoi: out std_logic
    );
end entity row_filter_new;


architecture MyHDL of row_filter_new is
    ----------------------------------------------------------------
--The following function calculates ceil(log2(x))
function ceil_log2(input:positive) return integer is
  variable temp,log:integer;
  begin
    temp:=input;
      log:=0;
      while (temp /= 0) loop
        temp:=temp/2;
        log:=log+1;
      end loop;
   return log;
end function ceil_log2;

COMPONENT TOII_TUVE_ila

PORT (
    clk : IN STD_LOGIC;



    probe0 : IN STD_LOGIC_VECTOR(195 DOWNTO 0)
);
END COMPONENT;

constant FIFO_DEPTH: positive:= 5;
constant DIFF_FIFO_WIDTH: positive := BITWIDTH+1;
constant SOBEL_FIFO_WIDTH: positive := BITWIDTH+1;
constant BUFFER_WIDTH: positive := DIFF_FIFO_WIDTH + LIN_BITS;
constant CBIT : positive:= ceil_log2(BUFFER_WIDTH);

signal c_nc_signal1: unsigned(9 downto 0);
signal nc_signal1: unsigned(23 downto 0);
signal sobel_fifo_afull: std_logic;
signal sobel_fifo_aempty: std_logic;
signal sobel_fifo_full: std_logic;
signal diff_fifo_afull: std_logic;
signal diff_fifo_aempty: std_logic;
signal diff_fifo_full: std_logic;
signal ycnt: unsigned(LIN_BITS-1 downto 0);
signal xcnt: unsigned(PIX_BITS-1 downto 0);
--signal wrreq: std_logic;
signal wrreq: std_logic_vector(0 downto 0);
signal wrdata: unsigned(BUFFER_WIDTH-1 downto 0);
signal wraddr: unsigned(PIX_BITS-1 downto 0);
signal video_data_out: signed (BUFFER_WIDTH-1 downto 0);
signal stop_read: std_logic;
signal sobel_fifo_wr: std_logic;
signal sobel_fifo_usedw: std_logic_vector(FIFO_DEPTH-1 downto 0);
signal sobel_fifo_rd: std_logic;
signal sobel_fifo_out: std_logic_vector(SOBEL_FIFO_WIDTH-1 downto 0);
signal sobel_fifo_in: unsigned(SOBEL_FIFO_WIDTH-1 downto 0);
signal sobel_fifo_empty: std_logic;
signal sobel_fifo_clr: std_logic;
signal rdreq: std_logic;
signal rddata: std_logic_vector(BUFFER_WIDTH-1 downto 0);
signal rdaddr: unsigned(PIX_BITS-1 downto 0);
signal r_wrreq_d: std_logic;
signal r_wrdata_d: unsigned(BUFFER_WIDTH-1 downto 0);
signal pingpong: std_logic;
signal enable_d: std_logic;
signal diff_fifo_wr: std_logic;
signal diff_fifo_usedw: std_logic_vector(FIFO_DEPTH-1 downto 0);
signal diff_fifo_rd: std_logic;
signal diff_fifo_out: std_logic_vector(DIFF_FIFO_WIDTH-1 downto 0);
signal diff_fifo_in: unsigned(DIFF_FIFO_WIDTH-1 downto 0);
signal diff_fifo_empty: std_logic;
signal diff_fifo_clr: std_logic;
signal dav_o: std_logic;
signal c_wrreq: std_logic_vector(0 downto 0);
signal c_wrdata: unsigned(LIN_BITS downto 0);
signal c_wraddr: unsigned(PIX_BITS-1 downto 0);
signal c_rdreq: std_logic;
signal c_rddata: std_logic_vector(LIN_BITS downto 0);
signal c_rdaddr: unsigned(PIX_BITS-1 downto 0);
signal mean_out: std_logic_vector(15 downto 0);
signal video_sobel_eoi: std_logic;
signal video_sobel_data2: std_logic_vector(BITWIDTH-1 downto 0);
signal video_sobel_v: std_logic;
signal video_box_eoi: std_logic;
signal video_box_data: std_logic_vector(BITWIDTH-1 downto 0);
signal video_box_v: std_logic;
signal video_sobel_h: std_logic;
signal video_sobel_dav: std_logic;
signal video_sobel_data: std_logic;
signal video_box_h: std_logic;
signal video_box_diff: std_logic_vector (BITWIDTH downto 0);
signal video_box_dav: std_logic;

type t_enum_t_fsm_1 is (
    IDLE,
    START,
    CLEARBUFFER,
    READ1
);
signal fsm: t_enum_t_fsm_1;
signal clear_buffer: std_logic;
type t_array_wrdata_d is array(0 to 4-1) of signed (BUFFER_WIDTH-1 downto 0);

signal wrdata_d: t_array_wrdata_d;
type t_array_video_dav is array(0 to 5-1) of std_logic;
signal video_dav: t_array_video_dav;
type t_array_video_bad is array(0 to 5-1) of std_logic;
signal video_bad: t_array_video_bad;
type t_array_video_data is array(0 to 5-1) of signed (BITWIDTH downto 0);
signal video_data: t_array_video_data;
type t_array_start_d is array(0 to 4-1) of std_logic;
signal start_d: t_array_start_d;
type t_array_st_cnt is array(0 to 4-1) of unsigned(7 downto 0);
signal st_cnt: t_array_st_cnt;
type t_array_st is array(0 to NUM_DIV-1) of std_logic;
signal st: t_array_st;
type t_array_sobel_d is array(0 to 4-1) of std_logic;
signal sobel_d: t_array_sobel_d;
type t_array_rddata_d is array(0 to 4-1) of signed (BUFFER_WIDTH-1 downto 0);
signal rddata_d: t_array_rddata_d;
type t_array_r_wrreq is array(0 to 2-1) of std_logic_vector(0 downto 0);
signal r_wrreq: t_array_r_wrreq;
type t_array_r_wrdata is array(0 to 2-1) of unsigned(BUFFER_WIDTH-1 downto 0);
signal r_wrdata: t_array_r_wrdata;
type t_array_r_wraddr is array(0 to 2-1) of unsigned(PIX_BITS-1 downto 0);
signal r_wraddr: t_array_r_wraddr;
type t_array_r_rdreq is array(0 to 2-1) of std_logic;
signal r_rdreq: t_array_r_rdreq;
type t_array_r_rddata is array(0 to 2-1) of std_logic_vector(BUFFER_WIDTH-1 downto 0);
signal r_rddata: t_array_r_rddata;
type t_array_r_rdaddr is array(0 to 2-1) of unsigned(PIX_BITS-1 downto 0);
signal r_rdaddr: t_array_r_rdaddr;
type t_array_quotient is array(0 to NUM_DIV-1) of std_logic_vector(BUFFER_WIDTH-1 downto 0);
signal quotient: t_array_quotient;
type t_array_q_negative is array(0 to NUM_DIV-1) of std_logic;
signal q_negative: t_array_q_negative;
type t_array_dn is array(0 to NUM_DIV-1) of std_logic;
signal dn: t_array_dn;
type t_array_divisor is array(0 to NUM_DIV-1) of unsigned(BUFFER_WIDTH-1 downto 0);
signal divisor: t_array_divisor;
type t_array_dividend is array(0 to NUM_DIV-1) of unsigned(BUFFER_WIDTH-1 downto 0);
signal dividend: t_array_dividend;
type t_array_diff_d is array(0 to 4-1) of signed (14 downto 0);
signal diff_d: t_array_diff_d;
type t_array_dav_d is array(0 to 4-1) of std_logic;
signal dav_d: t_array_dav_d;
type t_array_c_wrdata_d is array(0 to 4-1) of unsigned(LIN_BITS downto 0);
signal c_wrdata_d: t_array_c_wrdata_d;
type t_array_c_rddata_d is array(0 to 4-1) of unsigned(LIN_BITS downto 0);
signal c_rddata_d: t_array_c_rddata_d;
signal start_algo: std_logic;
signal video_o_datai : std_logic_vector(video_o_data'range);
signal video_o_davi: std_logic;
signal video_o_badi: std_logic;
signal select_channel: std_logic_vector(1 downto 0);
signal threshold_mult_w: std_logic_vector(threshold_mult'range);

signal video_i_data1 : std_logic_vector(BITWIDTH-1 downto 0);
signal video_i_data_prev : std_logic_vector(BITWIDTH-1 downto 0);
------------------------------------------------------------------------
--debug signals
signal probe0: std_logic_vector(195 downto 0);

ATTRIBUTE MARK_DEBUG : string;
ATTRIBUTE MARK_DEBUG of video_data: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of st: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of dn: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of clear_buffer: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of stop_read: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of diff_fifo_empty: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of diff_fifo_full: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of sobel_fifo_empty: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of sobel_fifo_full: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_dav: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of xcnt: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of pingpong: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of ycnt: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of mean_out: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of st_cnt: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of start_d: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of enable_d: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_v: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_h: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_dav: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_eoi: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_i_data: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_data_out: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_o_data: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of r_rddata: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of rddata: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of c_rddata: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of r_wrdata_d: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of r_wraddr: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of r_wrreq_d: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of sobel_d: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_sobel_data: SIGNAL IS "TRUE";
ATTRIBUTE MARK_DEBUG of video_sobel_data2: SIGNAL IS "TRUE";


begin

video_i_data1 <= video_i_data_prev when video_i_bad = '1' else video_i_data;

process (clk, rst)
begin
    if (rst = '1') then
        video_i_data_prev <= (others=>'0');
    elsif rising_edge(clk)then    
     if (video_i_bad = '0' and video_i_dav = '1') then
        video_i_data_prev <= video_i_data;
     end if;
    end if;
end process;




box_filter_inst: entity work.box_filter
generic map(
    WINDOW          => WINDOW,
    HW              => HALFWINDOW,
    BITWIDTH        => BITWIDTH,
    VIDEO_XSIZE     => VIDEO_XSIZE,
    VIDEO_YSIZE     => VIDEO_YSIZE,
    PIX_BITS        => PIX_BITS,
    LIN_BITS        => LIN_BITS
        )
port map(
    clk             => clk            ,
    rst             => rst            ,
    clk_100         => clk_100        ,
    enable          => '1'            ,
    video_i_v       => video_i_v      ,
    video_i_h       => video_i_h      ,
    video_i_dav     => video_i_dav    ,
    video_i_data    => video_i_data1  ,--video_i_data   ,
    video_i_eoi     => video_i_eoi    ,
    video_o_v       => video_box_v    ,
    video_o_h       => video_box_h    ,
    video_o_dav     => video_box_dav  ,
    video_o_data    => video_box_data ,
    video_o_diff    => video_box_diff ,
    video_o_eoi     => video_box_eoi  
    );

threshold_mult_w <= "00" & threshold_mult(5 downto 0);

sobel_filter_inst: entity work.sobel_filter 
generic map(
        WINDOW => 3,
        BITWIDTH => BITWIDTH,
        VIDEO_XSIZE => VIDEO_XSIZE,
        VIDEO_YSIZE => VIDEO_YSIZE,
        PIX_BITS =>PIX_BITS,
        LIN_BITS => LIN_BITS
        )
    port map(
        clk             => clk                  ,
        rst             => rst                  ,
        clk_100         => clk_100              ,
        threshold_mult  => threshold_mult_w     ,    
        video_i_v       => video_i_v            ,
        video_i_h       => video_i_h            ,
        video_i_dav     => video_i_dav          ,
        video_i_data    => video_i_data1        ,--video_i_data         ,
        video_i_eoi     => video_i_eoi          ,
        video_o_v       => video_sobel_v        ,
        video_o_h       => video_sobel_h        ,
        video_o_dav     => video_sobel_dav      ,
        video_o_data    => video_sobel_data     ,
        video_o_data2   => video_sobel_data2    ,
        video_o_eoi     => video_sobel_eoi      ,
        mean_out        => mean_out             
    );

diff_fifo : entity WORK.FIFO_GENERIC_SC
---------------------------------------------
  Generic map(
    FIFO_DEPTH => FIFO_DEPTH,                  -- +1 to accomodate maximum 2 lines
    FIFO_WIDTH => DIFF_FIFO_WIDTH,
    USE_EAB    => true,
    SHOW_AHEAD => true
  )
  Port map(
    CLK    => clk                   ,
    RST    => rst                   ,
    CLR    => diff_fifo_clr         ,
    WRREQ  => diff_fifo_wr          ,
    WRDATA => std_logic_vector(diff_fifo_in)          ,
    FULL   => diff_fifo_full        ,
    USEDW  => diff_fifo_usedw       ,
    EMPTY  => diff_fifo_empty       ,
    RDREQ  => diff_fifo_rd          ,
    RDDATA => diff_fifo_out
  );

sobel_fifo : entity WORK.FIFO_GENERIC_SC
---------------------------------------------
  Generic map(
    FIFO_DEPTH => FIFO_DEPTH,                  -- +1 to accomodate maximum 2 lines
    FIFO_WIDTH => SOBEL_FIFO_WIDTH,
    USE_EAB    => true,
    SHOW_AHEAD => true
  )
  Port map(
    CLK    => clk                   ,
    RST    => rst                   ,
    CLR    => sobel_fifo_clr         ,
    WRREQ  => sobel_fifo_wr          ,
    WRDATA => std_logic_vector(sobel_fifo_in)          ,
    FULL   => sobel_fifo_full        ,
    USEDW  => sobel_fifo_usedw       ,
    EMPTY  => sobel_fifo_empty       ,
    RDREQ  => sobel_fifo_rd          ,
    RDDATA => sobel_fifo_out
  );


diff_fifo_clr <= video_box_h;
diff_fifo_in <= unsigned(video_box_diff(DIFF_FIFO_WIDTH-1 downto 0));
diff_fifo_wr <= video_box_dav;
sobel_fifo_clr <= video_sobel_h;
sobel_fifo_in <= unsigned(video_sobel_data & video_sobel_data2);
sobel_fifo_wr <= video_sobel_dav;

sum_buffer : xpm_memory_sdpram
  generic map (

    -- Common module generics
    MEMORY_SIZE             => (2**PIX_BITS)*BUFFER_WIDTH,           --positive integer
    MEMORY_PRIMITIVE        => "block",         --string; "auto", "distributed", "block" or "ultra" ;
    CLOCKING_MODE           => "common_clock", --string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE        => "none",         --string; "none" or "<filename>.mem" 
    MEMORY_INIT_PARAM       => "",             --string;
    USE_MEM_INIT            => 1,              --integer; 0,1
    WAKEUP_TIME             => "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL         => 0,              --integer; 0,1
    ECC_MODE                => "no_ecc",       --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME         => 0,              --Do not Change
    USE_EMBEDDED_CONSTRAINT => 0,              --integer: 0,1
    MEMORY_OPTIMIZATION     => "true",          --string; "true", "false" 

    -- Port A module generics
    WRITE_DATA_WIDTH_A      => BUFFER_WIDTH,             --positive integer
    BYTE_WRITE_WIDTH_A      => BUFFER_WIDTH,             --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A            => PIX_BITS,              --positive integer

    -- Port B module generics
    READ_DATA_WIDTH_B       => BUFFER_WIDTH,             --positive integer
    ADDR_WIDTH_B            => PIX_BITS,              --positive integer
    READ_RESET_VALUE_B      => "0",            --string
    READ_LATENCY_B          => 2,              --non-negative integer
    WRITE_MODE_B            => "no_change"     --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep                   => '0',

    -- Port A module ports
    clka                    => clk,
    ena                     => '1',
    wea                     => wrreq,
    addra                   => std_logic_vector(wraddr),
    dina                    => std_logic_vector(wrdata),
    injectsbiterra          => '0',
    injectdbiterra          => '0',

    -- Port B module ports
    clkb                    => clk,
    rstb                    => rst,
    enb                     => rdreq,
    regceb                  => '1',
    addrb                   => std_logic_vector(rdaddr),
    doutb                   => rddata,
    sbiterrb                => open,
    dbiterrb                => open
  );


--sum_buffer : entity WORK.DPRAM_GENERIC_DC
---------------------------------------
--  Generic map(
--    ADDR_WIDTH  =>     PIX_BITS,
--    DATA_WIDTH  =>     BUFFER_WIDTH,
--    RAM_STYLE   =>     "block",
--    BYPASS_RW   =>     true,
--    SIMPLE_DP   =>     true,
--    SINGLE_CLK  =>     true,
--    OUTPUT_REG  =>     true
--  )
--  Port map(
--    A_CLK       => clk,
--    A_ADDR      => std_logic_vector(wraddr),
--    A_WRREQ     => wrreq,
--    A_WRDATA    => std_logic_vector(wrdata),
--    A_RDREQ     => '0',
--    A_RDDATA    => open,
--    B_CLK       => clk,
--    B_ADDR      => std_logic_vector(rdaddr),
--    B_WRREQ     => '0',
--    B_WRDATA    => (others => '0'),
--    B_RDREQ     => rdreq,
--    B_RDDATA    => rddata
--  );

col_sum_buffer : xpm_memory_sdpram
  generic map (

    -- Common module generics
    MEMORY_SIZE             => (2**PIX_BITS)*(LIN_BITS+1),           --positive integer
    MEMORY_PRIMITIVE        => "block",         --string; "auto", "distributed", "block" or "ultra" ;
    CLOCKING_MODE           => "common_clock", --string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE        => "none",         --string; "none" or "<filename>.mem" 
    MEMORY_INIT_PARAM       => "",             --string;
    USE_MEM_INIT            => 1,              --integer; 0,1
    WAKEUP_TIME             => "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL         => 0,              --integer; 0,1
    ECC_MODE                => "no_ecc",       --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME         => 0,              --Do not Change
    USE_EMBEDDED_CONSTRAINT => 0,              --integer: 0,1
    MEMORY_OPTIMIZATION     => "true",          --string; "true", "false" 

    -- Port A module generics
    WRITE_DATA_WIDTH_A      => LIN_BITS+1,             --positive integer
    BYTE_WRITE_WIDTH_A      => LIN_BITS+1,             --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A            => PIX_BITS,              --positive integer

    -- Port B module generics
    READ_DATA_WIDTH_B       => LIN_BITS+1,             --positive integer
    ADDR_WIDTH_B            => PIX_BITS,              --positive integer
    READ_RESET_VALUE_B      => "0",            --string
    READ_LATENCY_B          => 2,              --non-negative integer
    WRITE_MODE_B            => "no_change"     --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep                   => '0',

    -- Port A module ports
    clka                    => clk,
    ena                     => '1',
    wea                     => c_wrreq,
    addra                   => std_logic_vector(c_wraddr),
    dina                    => std_logic_vector(c_wrdata),
    injectsbiterra          => '0',
    injectdbiterra          => '0',

    -- Port B module ports
    clkb                    => clk,
    rstb                    => rst,
    enb                     => c_rdreq,
    regceb                  => '1',
    addrb                   => std_logic_vector(c_rdaddr),
    doutb                   => c_rddata,
    sbiterrb                => open,
    dbiterrb                => open
  );


--col_sum_buffer : entity WORK.DPRAM_GENERIC_DC
---------------------------------------
--  Generic map(
--    ADDR_WIDTH  =>     PIX_BITS,
--    DATA_WIDTH  =>     LIN_BITS+1,
--    RAM_STYLE   =>     "block",
--    BYPASS_RW   =>     true,
--    SIMPLE_DP   =>     true,
--    SINGLE_CLK  =>     true,
--    OUTPUT_REG  =>     true
--  )
--  Port map(
--    A_CLK       => clk,
--    A_ADDR      => std_logic_vector(c_wraddr),
--    A_WRREQ     => c_wrreq,
--    A_WRDATA    => std_logic_vector(c_wrdata),
--    A_RDREQ     => '0',
--    A_RDDATA    => open,
--    B_CLK       => clk,
--    B_ADDR      => std_logic_vector(c_rdaddr),
--    B_WRREQ     => '0',
--    B_WRDATA    => (others => '0'),
--    B_RDREQ     => c_rdreq,
--    B_RDDATA    => c_rddata
--  );
row_buffer_0 : xpm_memory_sdpram
  generic map (

    -- Common module generics
    MEMORY_SIZE             => (2**PIX_BITS)*BUFFER_WIDTH,           --positive integer
    MEMORY_PRIMITIVE        => "block",         --string; "auto", "distributed", "block" or "ultra" ;
    CLOCKING_MODE           => "common_clock", --string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE        => "none",         --string; "none" or "<filename>.mem" 
    MEMORY_INIT_PARAM       => "",             --string;
    USE_MEM_INIT            => 1,              --integer; 0,1
    WAKEUP_TIME             => "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL         => 0,              --integer; 0,1
    ECC_MODE                => "no_ecc",       --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME         => 0,              --Do not Change
    USE_EMBEDDED_CONSTRAINT => 0,              --integer: 0,1
    MEMORY_OPTIMIZATION     => "true",          --string; "true", "false" 

    -- Port A module generics
    WRITE_DATA_WIDTH_A      => BUFFER_WIDTH,             --positive integer
    BYTE_WRITE_WIDTH_A      => BUFFER_WIDTH,             --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A            => PIX_BITS,              --positive integer

    -- Port B module generics
    READ_DATA_WIDTH_B       => BUFFER_WIDTH,             --positive integer
    ADDR_WIDTH_B            => PIX_BITS,              --positive integer
    READ_RESET_VALUE_B      => "0",            --string
    READ_LATENCY_B          => 2,              --non-negative integer
    WRITE_MODE_B            => "no_change"     --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep                   => '0',

    -- Port A module ports
    clka                    => clk,
    ena                     => '1',
    wea                     => r_wrreq(0),
    addra                   => std_logic_vector(r_wraddr(0)),
    dina                    => std_logic_vector(r_wrdata(0)),
    injectsbiterra          => '0',
    injectdbiterra          => '0',

    -- Port B module ports
    clkb                    => clk,
    rstb                    => rst,
    enb                     => r_rdreq(0),
    regceb                  => '1',
    addrb                   => std_logic_vector(r_rdaddr(0)),
    doutb                   => r_rddata(0),
    sbiterrb                => open,
    dbiterrb                => open
  );

--row_buffer_0 : entity WORK.DPRAM_GENERIC_DC
---------------------------------------
--  Generic map(
--    ADDR_WIDTH  =>     PIX_BITS,
--    DATA_WIDTH  =>     BUFFER_WIDTH,
--    RAM_STYLE   =>     "block",
--    BYPASS_RW   =>     true,
--    SIMPLE_DP   =>     true,
--    SINGLE_CLK  =>     true,
--    OUTPUT_REG  =>     true
--  )
--  Port map(
--    A_CLK       => clk,
--    A_ADDR      => std_logic_vector(r_wraddr(0)),
--    A_WRREQ     => r_wrreq(0),
--    A_WRDATA    => std_logic_vector(r_wrdata(0)),
--    A_RDREQ     => '0',
--    A_RDDATA    => open,
--    B_CLK       => clk,
--    B_ADDR      => std_logic_vector(r_rdaddr(0)),
--    B_WRREQ     => '0',
--    B_WRDATA    => (others => '0'),
--    B_RDREQ     => r_rdreq(0),
--    B_RDDATA    => r_rddata(0)
--  );
row_buffer_1 : xpm_memory_sdpram
  generic map (

    -- Common module generics
    MEMORY_SIZE             => (2**PIX_BITS)*BUFFER_WIDTH,           --positive integer
    MEMORY_PRIMITIVE        => "block",         --string; "auto", "distributed", "block" or "ultra" ;
    CLOCKING_MODE           => "common_clock", --string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE        => "none",         --string; "none" or "<filename>.mem" 
    MEMORY_INIT_PARAM       => "",             --string;
    USE_MEM_INIT            => 1,              --integer; 0,1
    WAKEUP_TIME             => "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL         => 0,              --integer; 0,1
    ECC_MODE                => "no_ecc",       --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME         => 0,              --Do not Change
    USE_EMBEDDED_CONSTRAINT => 0,              --integer: 0,1
    MEMORY_OPTIMIZATION     => "true",          --string; "true", "false" 

    -- Port A module generics
    WRITE_DATA_WIDTH_A      => BUFFER_WIDTH,             --positive integer
    BYTE_WRITE_WIDTH_A      => BUFFER_WIDTH,             --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A            => PIX_BITS,              --positive integer

    -- Port B module generics
    READ_DATA_WIDTH_B       => BUFFER_WIDTH,             --positive integer
    ADDR_WIDTH_B            => PIX_BITS,              --positive integer
    READ_RESET_VALUE_B      => "0",            --string
    READ_LATENCY_B          => 2,              --non-negative integer
    WRITE_MODE_B            => "no_change"     --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep                   => '0',

    -- Port A module ports
    clka                    => clk,
    ena                     => '1',
    wea                     => r_wrreq(1),
    addra                   => std_logic_vector(r_wraddr(1)),
    dina                    => std_logic_vector(r_wrdata(1)),
    injectsbiterra          => '0',
    injectdbiterra          => '0',

    -- Port B module ports
    clkb                    => clk,
    rstb                    => rst,
    enb                     => r_rdreq(1),
    regceb                  => '1',
    addrb                   => std_logic_vector(r_rdaddr(1)),
    doutb                   => r_rddata(1),
    sbiterrb                => open,
    dbiterrb                => open
  );
--row_buffer_1 : entity WORK.DPRAM_GENERIC_DC
---------------------------------------
--  Generic map(
--    ADDR_WIDTH  =>     PIX_BITS,
--    DATA_WIDTH  =>     BUFFER_WIDTH,
--    RAM_STYLE   =>     "block",
--    BYPASS_RW   =>     true,
--    SIMPLE_DP   =>     true,
--    SINGLE_CLK  =>     true,
--    OUTPUT_REG  =>     true
--  )
--  Port map(
--    A_CLK       => clk,
--    A_ADDR      => std_logic_vector(r_wraddr(1)),
--    A_WRREQ     => r_wrreq(1),
--    A_WRDATA    => std_logic_vector(r_wrdata(1)),
--    A_RDREQ     => '0',
--    A_RDDATA    => open,
--    B_CLK       => clk,
--    B_ADDR      => std_logic_vector(r_rdaddr(1)),
--    B_WRREQ     => '0',
--    B_WRDATA    => (others => '0'),
--    B_RDREQ     => r_rdreq(1),
--    B_RDDATA    => r_rddata(1)
--  );


GEN_DIV: 
for i in 0 to NUM_DIV-1 generate
  div_inst : entity work.div 
  generic map(
       W => BUFFER_WIDTH,
       CBIT => CBIT  
      )
  port map(
    clk         => clk,
    reset       => rst,
    start       => st(i),
    dvsr        => std_logic_vector(divisor(i)),
    dvnd        => std_logic_vector(dividend(i)),
    done_tick   => dn(i),
    quo         => quotient(i),
    rmd         => open
    );
end generate;-- GEN_DIV;

row_filter_new_SEQ_LOGIC: process (clk, rst) is
begin
    if (rst = '1') then
        stop_read <= '0';
        for i in 0 to NUM_DIV-1 loop
            dividend(i) <= to_unsigned(0, BUFFER_WIDTH);
            divisor(i)  <= to_unsigned(0, BUFFER_WIDTH);
            q_negative(i) <= '0';
            st(i) <= '0';
        end loop;
        rdaddr <= to_unsigned(2**PIX_BITS - 1, PIX_BITS);
        clear_buffer <= '0';
        diff_fifo_rd <= '0';
        fsm <= IDLE;
        pingpong <= '1';
        ycnt <= to_unsigned(2**LIN_BITS - 1, LIN_BITS);
        dav_o <= '0';
        c_rdaddr <= to_unsigned(2**PIX_BITS - 1, PIX_BITS);
        r_wraddr(0) <= to_unsigned(2**PIX_BITS - 1, PIX_BITS);
        r_wraddr(1) <= to_unsigned(2**PIX_BITS - 1, PIX_BITS);
        wraddr <= to_unsigned(2**PIX_BITS - 1, PIX_BITS);
        sobel_fifo_rd <= '0';
        xcnt <= to_unsigned(0, PIX_BITS);
        st_cnt(0) <= to_unsigned(255, 8);
        st_cnt(1) <= to_unsigned(255, 8);
        st_cnt(2) <= to_unsigned(255, 8);
        st_cnt(3) <= to_unsigned(255, 8);
        c_wraddr <= to_unsigned(2**PIX_BITS -1, PIX_BITS);
        start_d(0) <= '0';
        start_d(1) <= '0';
        start_d(2) <= '0';
        start_d(3) <= '0';
        start_algo <= '0';
    elsif rising_edge(clk) then
        if bool(video_i_v) then
            ycnt <= to_unsigned((2 ** LIN_BITS) - 1, LIN_BITS);
        end if;
        if bool(video_i_h) then
            ycnt <= (ycnt + 1);
        end if;
        diff_fifo_rd <= '0';
        sobel_fifo_rd <= '0';
        dav_o <= '0';
        for i in 0 to NUM_DIV-1 loop
            st(i) <= '0';
        end loop;
        if (((diff_fifo_empty /= '1') and (sobel_fifo_empty /= '1') and (unsigned(diff_fifo_usedw) >= 3) and (unsigned(sobel_fifo_usedw) >= 3))
         or (((diff_fifo_empty /= '1') and (sobel_fifo_empty /= '1') and (unsigned(diff_fifo_usedw) > 0) and (unsigned(sobel_fifo_usedw) > 0)) 
            and (signed(resize(xcnt, 11)) > (VIDEO_XSIZE - 2)) and (diff_fifo_rd = '0'))) then
            xcnt <= (xcnt + 1);
            diff_fifo_rd <= '1';
            sobel_fifo_rd <= '1';
            if (signed(resize(ycnt, LIN_BITS+1)) < (VIDEO_YSIZE - 5)) then
                rdaddr <= (rdaddr + 1);
                c_rdaddr <= (c_rdaddr + 1);
                dav_o <= '1';
            end if;
        end if;
        if (xcnt = VIDEO_XSIZE) then
            if (signed(resize(ycnt, LIN_BITS+1)) < (VIDEO_YSIZE - 5)) then
                rdaddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                c_rdaddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
            end if;
            xcnt <= to_unsigned(0, PIX_BITS);
        end if;
        case fsm is
            when IDLE =>
                if bool(video_i_v and enable) then
                    pingpong <= stdl((not bool(pingpong)));
                    fsm <= START;
                end if;
            when START =>
                --rdaddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                --c_rdaddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                --r_wraddr(to_integer(pingpong)) <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                --wraddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                --c_wraddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                stop_read <= '0';
                start_algo <= '0';
                if (unsigned(ycnt) = (VIDEO_YSIZE - 5)) then
                    fsm <= READ1;
                end if;
            when READ1 =>
                if (not bool(stop_read)) then
                    start_algo <= '1';
                    st_cnt(0) <= (st_cnt(0) + 1);
                    start_d(0) <= '1';
                    rdaddr <= (rdaddr + 1);
                    c_rdaddr <= (c_rdaddr + 1);
                    if (((unsigned(st_cnt(0))) = (NUM_DIV - 1)) or (unsigned(rdaddr) = (VIDEO_XSIZE - 1) and start_algo='1')) then
                        rdaddr <= rdaddr;
                        c_rdaddr <= c_rdaddr;
                        stop_read <= '1';
                        start_d(0) <= '0';
                    end if;
                end if;
                for i in 0 to 3-1 loop
                    st_cnt((i + 1)) <= st_cnt(i);
                    start_d((i + 1)) <= start_d(i);
                end loop;
                for i in 0 to NUM_DIV-1 loop
                    if (i = unsigned(st_cnt(2))) then
                        st(i) <= start_d(2);
                    else
                        st(i) <= '0';
                    end if;
                end loop;
                if (rddata((rddata'length - 1)) = '1') then
                    for i in 0 to NUM_DIV-1 loop
                        if (i = unsigned(st_cnt(2))) then
                            q_negative(i) <= '1';
                        end if;
                        dividend(i) <= unsigned(0 - signed(rddata));
                    end loop;
                else
                    for i in 0 to NUM_DIV-1 loop
                        if (i = signed(resize(st_cnt(2), 9))) then
                            q_negative(i) <= '0';
                        end if;
                        dividend(i) <= unsigned(signed(rddata));
                    end loop;
                end if;
                if (((VIDEO_YSIZE - 5) - signed(resize(unsigned(c_rddata), LIN_BITS+2))) = 0) then
                    for i in 0 to NUM_DIV-1 loop
                        divisor(i) <= to_unsigned(1, BUFFER_WIDTH);
                    end loop;
                else
                    for i in 0 to NUM_DIV-1 loop
                        divisor(i) <= unsigned((VIDEO_YSIZE - 5) - signed(resize(unsigned(c_rddata), BUFFER_WIDTH)));
                    end loop;
                end if;
                for i in 0 to NUM_DIV-1 loop
                    if (dn(i) = '1') then
                        q_negative(i) <= '0';
                        r_wraddr(to_integer(pingpong)) <= (r_wraddr(to_integer(pingpong)) + 1);
                    end if;
                end loop;
                if (signed(resize(r_wraddr(to_integer(pingpong)), PIX_BITS+1)) = (VIDEO_XSIZE - 1) and unsigned(rdaddr) = (VIDEO_XSIZE - 1) and start_algo='1') then
                    start_algo <= '0';
                    stop_read <= '0';
                    for i in 0 to 4-1 loop
                        start_d(i) <= '0';
                    end loop;
                    st_cnt(0) <= to_unsigned((2 ** 8) - 1, 8);
                    rdaddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                    c_rdaddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                    r_wraddr(to_integer(pingpong)) <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                    wraddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                    c_wraddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
                    fsm <= CLEARBUFFER;
                end if;
                if (dn((NUM_DIV - 1)) = '1') then
                    stop_read <= '0';
                    st_cnt(0) <= to_unsigned((2 ** 8) - 1, 8);
                end if;

            when CLEARBUFFER => -- CLEARBUFFER
                wraddr <= (wraddr + 1);
                c_wraddr <= (c_wraddr + 1);
                clear_buffer <= '1';
                if (signed(resize(wraddr, PIX_BITS+1)) = (VIDEO_XSIZE - 1)) then
                    clear_buffer <= '0';
                    fsm <= IDLE;
                end if;

            when others =>
                fsm <= IDLE;
        end case;

        if bool(dav_d(2)) then
            wraddr <= (wraddr + 1);
            c_wraddr <= (c_wraddr + 1);
        end if;
        if (signed(resize(c_wraddr, PIX_BITS+1)) = (VIDEO_XSIZE - 1)) then
            c_wraddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
        end if;
        if (signed(resize(wraddr, PIX_BITS+1)) = (VIDEO_XSIZE - 1)) then
            wraddr <= to_unsigned((2 ** PIX_BITS) - 1, PIX_BITS);
        end if;
    end if;
end process row_filter_new_SEQ_LOGIC;

row_filter_new_DELAY_LOGIC: process (clk, rst) is
begin
    if (rst = '1') then
        rddata_d(0) <= to_signed(0, BUFFER_WIDTH);
        rddata_d(1) <= to_signed(0, BUFFER_WIDTH);
        rddata_d(2) <= to_signed(0, BUFFER_WIDTH);
        rddata_d(3) <= to_signed(0, BUFFER_WIDTH);
        diff_d(0) <= to_signed(0, DIFF_FIFO_WIDTH);
        diff_d(1) <= to_signed(0, DIFF_FIFO_WIDTH);
        diff_d(2) <= to_signed(0, DIFF_FIFO_WIDTH);
        diff_d(3) <= to_signed(0, DIFF_FIFO_WIDTH);
        c_rddata_d(0) <= to_unsigned(0, LIN_BITS+1);
        c_rddata_d(1) <= to_unsigned(0, LIN_BITS+1);
        c_rddata_d(2) <= to_unsigned(0, LIN_BITS+1);
        c_rddata_d(3) <= to_unsigned(0, LIN_BITS+1);
        dav_d(0) <= '0';
        dav_d(1) <= '0';
        dav_d(2) <= '0';
        dav_d(3) <= '0';
        sobel_d(0) <= '0';
        sobel_d(1) <= '0';
        sobel_d(2) <= '0';
        sobel_d(3) <= '0';
    elsif rising_edge(clk) then
        dav_d(0) <= dav_o;
        sobel_d(0) <= sobel_fifo_out(SOBEL_FIFO_WIDTH-1);
        diff_d(0) <= signed(diff_fifo_out);
        rddata_d(0) <= signed(rddata);
        c_rddata_d(0) <= unsigned(c_rddata);
        for i in 0 to (4 - 1)-1 loop
            c_rddata_d((i + 1)) <= c_rddata_d(i);
            dav_d((i + 1)) <= dav_d(i);
            sobel_d((i + 1)) <= sobel_d(i);
            diff_d((i + 1)) <= diff_d(i);
            rddata_d((i + 1)) <= rddata_d(i);
        end loop;
    end if;
end process row_filter_new_DELAY_LOGIC;

row_filter_new_ADD_PIPE: process (clk, rst) is
begin
    if (rst = '1') then
        wrdata_d(0) <= to_signed(0, BUFFER_WIDTH);
        wrdata_d(1) <= to_signed(0, BUFFER_WIDTH);
        wrdata_d(2) <= to_signed(0, BUFFER_WIDTH);
        wrdata_d(3) <= to_signed(0, BUFFER_WIDTH);
        c_wrdata_d(0) <= to_unsigned(0, LIN_BITS+1);
        c_wrdata_d(1) <= to_unsigned(0, LIN_BITS+1);
        c_wrdata_d(2) <= to_unsigned(0, LIN_BITS+1);
        c_wrdata_d(3) <= to_unsigned(0, LIN_BITS+1);
    elsif rising_edge(clk) then
        if (sobel_d(2) = '0') then
            c_wrdata_d(0) <= c_rddata_d(0);
            wrdata_d(0) <= (diff_d(2) + rddata_d(0));
        else
            c_wrdata_d(0) <= (c_rddata_d(0) + 1);
            wrdata_d(0) <= rddata_d(0);
        end if;
    end if;
end process row_filter_new_ADD_PIPE;

row_filter_new_MEMORY_WRITE: process (fsm, pingpong, wrdata_d, c_wrdata_d, dav_d, r_wrreq_d, r_wrdata_d, clear_buffer) is
begin
    if (fsm = CLEARBUFFER) then
        wrdata <= to_unsigned(0, BUFFER_WIDTH);
        c_wrdata <= to_unsigned(0, LIN_BITS+1);
    else
        wrdata <= unsigned(wrdata_d(0)(BUFFER_WIDTH-1 downto 0));
        c_wrdata <= c_wrdata_d(0);
    end if;
    wrreq(0) <= stdl(bool(dav_d(3)) or bool(clear_buffer));
    c_wrreq(0) <= stdl(bool(dav_d(3)) or bool(clear_buffer));
    rdreq <= '1';
    c_rdreq <= '1';
    r_rdreq(0) <= '1';
    r_rdreq(1) <= '1';
    r_wrdata(to_integer(pingpong)) <= r_wrdata_d;
    r_wrreq(to_integer(pingpong))(0) <= r_wrreq_d;
end process row_filter_new_MEMORY_WRITE;


row_filter_new_VIDEO_OUT_PROCESS: process (clk, rst) is
begin
    if (rst = '1') then
        video_o_v <= '0';
        video_o_h <= '0';
        video_data(0) <= to_signed(0, DIFF_FIFO_WIDTH);
        video_data(1) <= to_signed(0, DIFF_FIFO_WIDTH);
        video_data(2) <= to_signed(0, DIFF_FIFO_WIDTH);
        video_data(3) <= to_signed(0, DIFF_FIFO_WIDTH);
        video_data(4) <= to_signed(0, DIFF_FIFO_WIDTH);
        enable_d <= '0';
        r_rdaddr(0) <= to_unsigned(2**(r_rdaddr(0)'length)-1, PIX_BITS);
        r_rdaddr(1) <= to_unsigned(2**(r_rdaddr(0)'length)-1, PIX_BITS);
        video_data_out <= to_signed(0, BUFFER_WIDTH);
        video_o_datai <= std_logic_vector(to_unsigned(0, BITWIDTH));
        video_o_eoi <= '0';
        video_dav(0) <= '0';
        video_dav(1) <= '0';
        video_dav(2) <= '0';
        video_dav(3) <= '0';
        video_dav(4) <= '0';
        video_o_davi <= '0';
        video_bad(0) <= '0';
        video_bad(1) <= '0';
        video_bad(2) <= '0';
        video_bad(3) <= '0';
        video_bad(4) <= '0';
        video_o_badi <= '0';
    elsif rising_edge(clk) then
        video_o_v <= video_i_v;
        video_o_h <= video_i_h;
        video_o_eoi <= video_i_eoi;
--        video_data(0) <= signed(resize(unsigned(video_i_data), DIFF_FIFO_WIDTH));
        video_data(0) <= signed(resize(unsigned(video_i_data1), DIFF_FIFO_WIDTH));
        video_dav(0) <= video_i_dav;
        video_bad(0) <= video_i_bad;
        if bool(video_i_v) then
            enable_d <= enable;
        end if;
        if bool(video_i_h) then
            r_rdaddr(to_integer(1 - to_signed(pingpong, 2))) <= to_unsigned((2 ** r_rdaddr(0)'length) - 1, PIX_BITS);
        end if;
        if bool(video_i_dav) then
            r_rdaddr(to_integer(1 - to_signed(pingpong, 2))) <= (r_rdaddr(to_integer(1 - to_signed(pingpong, 2))) + 1);
        end if;
        for i in 0 to (5 - 1)-1 loop
            video_data((i + 1)) <= video_data(i);
            video_dav((i + 1)) <= video_dav(i);
            video_bad((i + 1)) <= video_bad(i);
            
        end loop;
        video_data_out <= (video_data(2) - signed(r_rddata(to_integer(1 - to_signed(pingpong, 2)))));
        if bool(enable_d) then
            --video_o_data <= std_logic_vector(unsigned(video_data_out(BITWIDTH-1 downto 0)));
            
            if(video_data_out>((2**(BITWIDTH))-1))then
                video_o_datai <= std_logic_vector(to_unsigned((2**(BITWIDTH))-1,video_o_datai'length));
            else
                video_o_datai <= std_logic_vector(unsigned(video_data_out(BITWIDTH-1 downto 0)));
            end if;
            
            
--            video_o_datai <= std_logic_vector(unsigned(video_data_out(BITWIDTH-1 downto 0)));
        else
            --video_o_data <= std_logic_vector(resize(unsigned(video_data(3)), BITWIDTH));
            video_o_datai <= std_logic_vector(resize(unsigned(video_data(3)), BITWIDTH));
        end if;
        video_o_davi <= video_dav(3);
        video_o_badi <= video_bad(3);
    end if;
end process row_filter_new_VIDEO_OUT_PROCESS;

----------------------------------------------------------------------------------------------------------------------------------------
row_filter_new_VIDEO_SELECT_PROCESS: process (clk, rst) is
begin
    if(rst='1') then
        video_o_data <= (others=>'0');
        video_o_dav <= '0';
        select_channel <= "00";
    elsif (rising_edge(clk)) then
        if(video_i_v='1') then
            select_channel <= threshold_mult(7 downto 6);
        end if; 
        if(select_channel="10") then
            video_o_data <= video_box_data;
            video_o_dav <= video_box_dav;
        elsif (select_channel="01") then
            video_o_data <= video_sobel_data & "0" & x"000";
            video_o_dav <= video_sobel_dav;
        else
            video_o_data <= video_o_datai;
            video_o_dav <= video_o_davi;
            video_o_bad <= video_o_badi;
        end if;
    end if;
end process row_filter_new_VIDEO_SELECT_PROCESS;
----------------------------------------------------------------------------------------------------------------------------------------

row_filter_new_MUX_PROCESS: process (clk, rst) is
    variable quo: signed(BUFFER_WIDTH-1 downto 0);
begin
    if (rst = '1') then
        r_wrreq_d <= '0';
        r_wrdata_d <= to_unsigned(0, BUFFER_WIDTH);
    elsif rising_edge(clk) then
        r_wrreq_d <= '0';
        for i in 0 to NUM_DIV-1 loop
            if (dn(i) = '1') then
                if bool(q_negative(i)) then
                    quo := signed((0 - signed(quotient(i))));
                    r_wrdata_d <= unsigned(quo((BUFFER_WIDTH +1 - 1)-1 downto 0));
                else
                    r_wrdata_d <= unsigned(quotient(i));
                end if;
                r_wrreq_d <= '1';
            end if;
        end loop;
    end if;
end process row_filter_new_MUX_PROCESS;

--i_row_filter: TOII_TUVE_ila
--PORT MAP (
--    clk => clk_100,
--    probe0 => probe0
--);

--probe0(0)<=video_i_v;
--probe0(1)<=video_i_h;
--probe0(2)<=video_i_dav;
--probe0(3)<=video_i_eoi;
--probe0(17 downto 4) <= video_i_data;
--probe0(32 downto 18) <= std_logic_vector(video_data(3));
--probe0(33) <= video_dav(3);
----gen1:for i in 0 to NUM_DIV-1 generate
----    probe0(34+i) <= st(i);
----    probe0(50+i) <= dn(i);
----end generate gen1;
--probe0(43 downto 34) <= std_logic_vector(rdaddr);
--probe0(53 downto 44) <= std_logic_vector(c_rdaddr);
--probe0(63 downto 54) <= std_logic_vector(wraddr);
--probe0(65 downto 64) <= "00";
--probe0(89 downto 66) <= std_logic_vector(rddata);
--probe0(99 downto 90) <= std_logic_vector(c_rddata);
--probe0(123 downto 100) <= std_logic_vector(r_wrdata_d);
--probe0(124) <= r_wrreq_d;
--probe0(134 downto 125) <= std_logic_vector(xcnt);
--probe0(135) <= stop_read;
--probe0(136) <= pingpong;
--probe0(137) <= clear_buffer;
--probe0(145 downto 138) <= std_logic_vector(st_cnt(2));
--probe0(155 downto 146) <= std_logic_vector(r_wraddr(0));
--probe0(179 downto 156) <= r_rddata(0);
----probe0(180) <= video_sobel_data;
--probe0(194 downto 180) <= video_box_diff;
--probe0(195) <= '0';

end architecture MyHDL;